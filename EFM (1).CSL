PROGRAM The Edinburgh Forest Model (EFM)

   !A process-based (or mechanistic) forest plantation ecosystem simulator.
   !The efm.csl source file works ok in windows 7 (32bit) running ACSL11.8.4
   !Speed is 1 minute for 5 yrs (12 (?6 if you shut down other possibly
   !competing processes) s / yr).  Maxt = 1/128 default. 
   !A 60-year rotation takes 12 minutes.
   !Beech use maxt = 1/256. Sometimes in self-thinning mode for Sitka one can
   !use maxt = 1/64.
   !Compilation: Compaq Visual Fortran 6.6-1877-47BAQ; compiles in 36 s.
   !Use double precision, translator and runtime table sizes of 200000.
   !See efm.prj
   !To look for significant edits, eg. search for eg " 2017 ".

                         !CONTENTS                             
                         !========

!TEST DATA   
!INTRODUCTION                                                         
!INITIAL                                                              
          !Changing the start time of a simulation                    
          !ACSL run control parameters                                
     !CONSTANTS                                                       
          !Start counter initialization and updating                 
          !Rotation counter initialization and updating              
     !ENVIRONMENTAL VARIABLES                                        
          !Seasonally varying environment                            
          !Diurnally varying environment                             
     !ENVIRONMENTAL DATA: initialization                             
          !Diurnal environmental data                                
          !Daily environmental data                                  
          !Monthly environmental data - 12 months (average
             !monthly data and interpolation                         
          !Climatological data input (CLINO)                         
          !Monthly environmental data over many years from a weather
             !generator                                              
          !Climate data                                              
     !ENVIRONMENTAL PARAMETERS                                       
          !Acceleration due to gravity, gravity, 9.81 m2 s-1.
          !Air pressure, Pair (Pa) 
          !Ammonium concentration in atmosphere, Namm_atm_vpb (pmol mol-1)
          !Carbon dioxide, CO2air (also potentially affected by climate change)
          !Daylength and latitude                                    
          !Fertilizer applications - initial                         
          !Nitrogen deposition from atmosphere into the soil ammonium and
             !nitrate pools, INenv_Namm_hayr, INenv_Nnit_hayr (kg N ha-1 yr-1) 
          !Radiation                                                 
          !Rain                                                      
          !Reference height of wind speed etc                        
          !Relative humidity                                         
          !Temperature                                               
          !Wind speed                                                
     !HEADERS for output files                                       
          !Daily environmental data output (header)                  
          !Diurnal environmental data output (header)                
          !Debug daily data (header)                                 
          !Debug diurnal data (header)                               
     !TREE SUBMODEL - STATE VARIABLES AND INITIAL VALUES             
          !Foliage, le (leaf)                                        
          !Branches, br                                              
          !Buds, bud                                                 
          !Stems, st                                                 
          !Coarse roots, co                                          
          !Fine roots and mycorrhiza, fi                             
          !Tree products, pt, pr                                     
          !Phenology initialization                                  
     !SOIL AND LITTER SUBMODEL - STATE VARIABLES AND INITIAL VALUES
          !Clay fraction                                             
          !Protected fraction                                        
          !C:N ratios is stabilized SOM                              
          !Fractions of C in dying biomass entering unprotected
             !and protected SOM pools (uSOM and pSOM)                
     !WATER SUBMODEL - STATE VARIABLES                               
     !APHID SUBMODEL - STATE VARIABLES AND INITIAL VALUES            
     !INITIAL VALUES - SCALING AND CALCULATION                       
          !Tree initial values                                       
          !Calcics section (conditional initialization)              
          !Scale restored state variables                            
          !Other initializations                                     
     !THINNING (initial section)                                     
     !FIRE (Initial Section)                                         
     !TEMPERATURE FUNCTION - initial calculations                    
     !PHENOLOGY (initial)                                            
     !TREE PARAMETERS - initial calculations                         
     !APHID initial section                                          
     !COUNTERS - initialization                                      
!END !INITIAL                                                        
!DERIVATIVE                                                          
          !Run termination condition                                 
          !maxt changed during run - recalculations                  
               !Thinning recalculations                              
          !Pruning changed during run - recalculations               
     !TIME                                                           
     !ONCE-A-YEAR BLOCK                                              
     !ONCE-A-DAY BLOCK                                               
          !Daily environmental data input                            
          !Monthly environmental data input over many years 
             !from a weather generator and interpolation             
          !Astronomy                                                 
               !Solar declination
               !Solar elevation at noon
               !Day length
               !Dawn and dusk
               !Solar azimuth at dawn
               !Sign of azimuth angle
               !Southern hemisphere
          !Carbon dioxide concentration                              
          !Radiation; bright sunshine hours                          
               !Radiation from interpolated bright sunshine hours
               !Daily light receipt
               !Mean light flux density
               !Daily fraction of bright sunshine hours
          !Mean daily air and soil temperatures                      
          !Rain                                                      
          !Relative humidity (RH)                                    
          !Environmental N deposition                                
          !Diurnal temperature wave times for air temperature        
          !Wind speed                                                
          !Output of daily environmental data to file                
          !Temperature function for light saturated photosynthesis   
          !Mineralization multiplier, tillage                        
          !Debug daily data to file                                  
     !DIURNALLY VARYING QUANTITIES                                   
          !Diurnal data input                                        
          !Geometry of sun                                           
               !Solar elevation
               !Solar azimuth
          !Flag daytime or nighttime using light_on                  
          !Light, jPARsc (J PAR m-2 s-1)                             
               !Light absorbed by the canopy
          !Instantaneous net radiation, jNetRsc (J m-2 s-1)          
          !Irradiance fractions: direct solar, diffuse               
          !Air temperature                                           
          !Soil temperature                                          
          !Rain                                                      
          !Relative humidity (RH)                                    
          !Wind speed                                                
          !Ammonia N concentration in air, Namm_atm (kg NH3 N m-3)   
          !Carbon dioxide concentration in air, CO2air (kg CO2 m-3)  
     !OUTPUT OF DIURNAL ENVIRONMENT DATA TO FILE, diurnout.dat       
     !TEMPERATURE                                                    
          !Plant parameters                                          
          !Soil and root processes                                   
          !N uptake as distributed between Namm and Nnit pools       
          !Photosynthesis, temperature effects                       
               !alpha, initial slope
               !Pmax, light saturated photosynthesis
          !Ammonia volatilization in the foliage                     
     !WATER FUNCTIONS                                                
!TREE SUBMODEL                                                       
          !Phenology                                                 
               !Dormancy2, dorm2 pool. State variable signifying 
                    !end of dormancy                                 
               !Competence, comp pool. State variable allowing 
                    !response to forcing temperatures                
               !Budburst, budb pool. State variable denoting 
                    !progress towards budburst                       
               !Dormancy1, dorm1 pool. State variable signifying
                         !beginning of dormancy                      
                    !Budsopening
                    !Leaf senescence
                    !Leaf fall
     !FIRE                                                           
          !Pulse function for fire events                            
               !Time of end of last fire event (fire lasts 1 day)    
          !Effect of fire on soil temperature and mineralization     
          !Effect of fire on the trees                               
          !Calculation of tree fluxes from fire event                
               !Buds (state variable Mbud)
               !Foliage
               !Branches
               !Stem
               !Coarse roots
               !Fine roots
               !Aggregated C,N fluxes from tree
          !Effects of fire on surface litter                         
     !NUMBER OF STEMS, nstems (stems m-2)                                    
    
          !Thinning and thinning fluxes (th)                          
          !Self-thinning (sn)                                         
               !Birth/generation of new stems
               !Stem death
     !SEEDS, nseeds                                                   
     !BUDS (bud), Mbud (kg structural dry mass stem-1)                
          !Input                                                      
          !Outputs                                                    
          !Differential equation
          !C, N, and water contents of buds
          !Buds opening
          !Checks on bud C, N and water balances                     
     !FOLIAGE (le = leaf)                                            
          !Variables                                                 
          !Foliage senescence rate constants                          
          !Leaf area and leaf area index                              
          !Stomatal conductance                                       
          !Light interception and photosynthesis                      
             !Pmax, asymptote of leaf photosynthetic response         
             !alpha, initial slope of leaf light response equation    
             !Canopy photosynthesis                                   
                !Numerical integration                                
                !NRH. No acclimation. No sun/shade                    
                !NRH. Acclimation. No sun/shade                       
                !NRH. Acclimation. Sun/shade                         
             !Isoprene emission by foliage                            
          !Foliage N output to atmosphere                             
          !Photosynthetic N pool, MNph, MNph_can (canopy)             
          !Leaf area, Aleaf (m2 stem-1)                               
          !C substrate flux from foliage (le) to branches (br)        
          !Respiration fluxes                                         
          !Fluxes between age categories and fluxes to litter         
          !Outputs to/from self-thinning/generation of new stems (sn) 
          !Outputs to pruning                                         
          !Differential eqns                                          
          !Foliage balance checks                                     
     !BRANCHES (br)                                                   
          !Variables                                                  
          !Growth rates                                              
          !Branch surface area, Abr (m2 stem-1)                       
          !C substrate flux from branches (br) to stem (st)           
          !N substrate flux from branches (br) to foliage (le)        
          !Respiration fluxes                                         
          !Fluxes to litter                                           
          !Outputs to/from self-thinning/generation of new stems      
          !Outputs to pruning                                         
          !Differential eqns                                          
          !Branches balance checks                                    
     !STEM (st)                                                       
          !Variables                                                  
          !Growth rates                                               
          !Stem geometry                                              
          !C substrate flux from stem (st) to coarse roots (co)       
          !N substrate flux from stem (st) to branches (br)           
          !Respiration fluxes                                         
          !C storage. Synthesis and breakdown.                        
          !Fluxes to litter                                           
          !Outputs to/from self-thinning/generation of new stems      
          !Outputs to pruning                                         
          !Differential eqns                                          
          !Stem balance checks                                        
     !COARSE ROOTS (co)                                               
          !Variables                                                  
          !Growth rates                                               
          !C substrate flux from coarse roots (co) to fine roots 
               !and mycorrhiza (fi)                                   
          !N substrate flux from coarse roots to stem                 
          !Respiration fluxes                                         
          !Fluxes to litter                                           
          !Outputs to/from self-thinning/generation of new stems      
          !Outputs to pruning                                         
          !Differential eqns                                          
          !Coarse roots balance checks                                
     !FINE ROOTS and MYCORRHIZA (fi)                                  
          !Variables                                                  
          !N uptake by the fine roots and mycorrhiza                  
          !Growth rates                                               
          !N substrate flux from fine roots (fi) to coarse roots (co) 
          !Respiration fluxes                                         
          !Exudation fluxes                                           
          !Age transfer fluxes and fluxes to litter                   
          !Outputs to/from self-thinning/generation of new stems      
          !Outputs to pruning                                         
          !Differential eqns                                          
          !Fine roots and mycorrhiza balance checks                    
          !Fine root density                                          
     !TREE VARIABLES                                                  
          !Whole-tree variables                                       
          !Tree balance checks                                        
!SOIL AND LITTER SUBMODEL                                             
     !Parameters                                                      
     !Temperature functions                                           
     !Water functions modifying soil and surface litter biochemistry  
     !Surface litter pools (metabolic, cellulose, lignin)             
          !Inputs of C, N to surface litter pools                     
          !Outputs of C, N from surface litter pools                  
               !Respiration from the outputs                       
               !C and N inputs generated to other pools               
          !Differential equations                                     
          !Totals for surface litter                                  
     !Soil litter pools (metabolic, cellulose, lignin)                
          !Inputs of C, N to soil litter pools                        
          !Outputs of C, N from soil litter pools                     
               !Respiration from the outputs                          
               !C and N inputs generated to other pools               
          !Differential equations                                     
          !Totals for soil litter                                     
     !Surface and soil litter totals                                  
     !Charcoal pool in soil, Char                                     
     !Soluble C (carbon substrate) in soil, Csol                      
          !Inputs, outputs, differential equation 
     !Ammonium N pool, Namm                                          
          !Inputs, outputs, differential equation
     !Nitrate N pool, Nnit                                           
          !Inputs, outputs, differential equation
     !Gross, net mineralization and immobilization                 
     !Soil microbial biomass pool, Cbio                              
          !Input (growth), outputs, differential equation
     !Unprotected SOM, CuSOM, NuSOM                                  
          !Inputs, outputs, differential equations
     !Protected SOM, CpSOM, NpSOM                                    
          !Inputs, outputs, differential equations
     !Stabilized SOM, CsSOM, NsSOM                                   
          !Inputs, outputs, differential equations

     !Totals for soil and litter submodel                            
          !Variables, fluxes, balance checks
!WATER SUBMODEL                                                      

!TERMINAL                                                            

!TEST DATA (File efm.cmd must be present)
   !Evergreen. Eskdale sinusoidal environment (internally generated).
      !test !This is a procedure in the file of runtime commands, efm.cmd,
      !which is opened automatically when efm.csl is run. To run test,
      !type <test>.
      !       T 0.                 TAIR 1.84318104       JPARDY 561688.993
      !     LAI 0.00300000         NMIN 1.0000D-03          WLE 0.02400000

      !       T 1.00000000         TAIR 1.80210802       JPARDY 573100.844
      !     LAI 0.00300056         NMIN 9.8755D-04          WLE 0.02447819

   
      !gotest60
      !With thinning.  At 60 years, YC (Vptr_hayr) = 9.6, LAI = 6.8.

   !Deciduous (b = beech).
      !gotestb
      !           T 0.                 TAIR 1.84318104       JPARDY 561688.993
      ! LAI_1AUG15H 5.5555D+33         NMIN 1.0000D-03          WFI 0.02400000

      !           T 365.000000         TAIR 1.84318104       JPARDY 561688.993
      ! LAI_1AUG15H 0.01086770         NMIN 0.00213044          WFI 0.03713718

      !           T 730.000000         TAIR 1.84318104       JPARDY 561688.993
      ! LAI_1AUG15H 0.07068567         NMIN 0.00184934          WFI 0.07234269
 
      !gotestb90
      !With thinning. At 90 years, YC = 1.97, LAI_1Aug15h 4.7.



!INTRODUCTION
   !Program developed and written by John Thornley.
   !E-mail address:  johnthornley@waitrose.com

   !Professional address:
      !John Thornley
      !Centre for Ecology and Hydrology (CEH)
      !Edinburgh Research Station
      !Bush Estate, Penicuik
      !Midlothian EH26 0QB, Scotland.
         !Tel: 0131 445 4343;  fax 0131 445 3943.

   !Home address (I work from home):
      !John Thornley,
      !6 Makins Road,
      !Henley-on-Thames,
      !Oxfordshire RG9 1PP, UK.
         !Tel: + 44 (0) 1491 577346.
         !Material faxed to CEH is sent on to me immediately and usually
         !gets to me within 24 hours.

   !Program is written in ACSL (Advanced Continuous Simulation Language):
      !AEgis Research,
      !919-B Willowbrook Drive, Huntsville, AL 35802, USA.
      !Phone 256 881 0947  Fax 256 883 5516  Email admin@aegis.com
   
   !The source program, efm.csl, is freely available from John Thornley,
      !Email johnthornley@waitrose.com.
      !It can be downloaded from http://masseyblogs.ac.nz/hurleypasturemodel/
      !hurley-pasture-model/programme-access-and-download/.
   !Execution speed (with default settings):
      !ACSL 11 (Jan 2000), Windows, Watcom Fortran (?), double precision:
      !pc pentium/550,
      !1 year takes 13 secs with an integration interval maxt of 
      !11.25 minutes (1/128 day). Sitka mode.
      !5 y = 1 minute 5 secs. 100 y = 22 m. 1000 y = 3 h 40 m.
      !5000 y = 18 h.
      !Similar speed in DOS ACSL 11 (using Watcom Fortran). 
      !If diurnal data are read in, it is slower.
      !Beech: necessary to use maxt = one512th (2.8125 minutes), with
         !1 year taking 50 secs.  90 years takes 75 minutes.
   
      !Sometimes (eg self-thinning mode) maxt = one64th day = 22.5 minutes
         !can be used (instead of default maxt = one128th)
         !and the program is stable.
   
      !To translate set tablespace (dos acsl 11, file acsl.opt) = 200 000.
   
   !Defaults are:
      !ialg = 3, Euler integration.
      !maxt = 1/128 d = 11.25 minutes.  
      !Beech: maxt = 1/512 d = 2.8125 minutes.  Procedure <beech> in
      !file efm.cmd makes the required changes for beech.
   
   !Switches.
      !To display all the switches, at runtime, type <d s_*>.
      !The most immportant switches are as follows:
      !s_aphid = 0, aphidvr = 0.  To enable the aphid submodel, then set
         !s_aphid = 1, aphidvr = 1.  Type <aphid> to switch on the aphid 
         !sub-model.  Type <aphid 0> to disable the sub-model..
         !Set aphidvr = 0 causes the aphid state variables to remain at
         !their initial values.  See proced aphid. 
         !Constant s_aphid = 0, aphidvr = 0 !Default values.
      !s_diurnal = 1, diurnally varying environment, 5 diurnally changing
               !variables:
               ! radiation, jPARsc; air temperature (dry bulb), Tair;
               ! rain; wind; relative humidity (RH).
               !Diurnally constant variables are: Tsoil, rain.
          !If we set s_diurnal = 0, then these 5 variables are constant over
               !each day.  
               !Do godid in efm.cmd.
      !s_fire = 0, no fire event is occurring.
         !s_fire is used for switching on wild fires and prescribed fires.
         !Fires associated with end-of-rotation, clear felling, then
         !fire and replanting, are dealt with separately (not yet coded).
      !s_prune = 0, no pruning is applied.
      !s_rotate = 0, no rotation applied (rotation = clear felling at end of 
         !simulation, reinitialization and replanting.
      !s_seasonal = 1, seasonally varying environment (radiation,
                  !daylength, air temperature, soil temperature,
                  !humidity, rainfall).
      !s_selfthin = 0, no self-thinning, plantation model dies (default).
         !If s_selfthin = 1, then model runs in natural forest mode, with
         !self-thinning and generation of new stems.  Stem height:diameter
         !ratio is constant in natural forest mode: rhdstem = rhdstem0 = 60.
         !See allovr (variable allometry) below.
         !"sn" denotes self-thin (note "st" denotes stem).
      !s_thin = 0, no thinning.
      !s_water = 1, water submodel running.  If s_water = 0, then water
         !relations have no effect on the model.  Also set watervr = 0
         !(water variables constant) so the water submodel does not blow up.
   
   !To stop groups of state variables changing:
      !allovr = 1, stem height:diameter ratio rhdstem varies.
         !Variable allometry is for plantation mode only.
         !If allovr = 0, then rhdstem = rhdstem0, a constant = 60.
         !In natural forest mode, rhdstem is constant = rhdstem0 = 60 always.
      !treevr = 1, soilvr = 1;  watervr = 1, s_water = 1;
         !the tree, litter, soil and water submodels are all switched on.
         !If *vr = 0, this stops the submodel state variables from changing.
   
   
      !Notes.  
         !1. The calculation of the radiation-driven component of
            !transpiration, OWle_rad_gnd, as calculated by the
            !Penman-Monteith eqn is in error at low LAI's. This is
            !not a programming error. Eg cf OWle_rad_gnd with OWle_vdg_gnd
            !at low LAI.  OWle_rad_gnd decreases as LAI**2.  This is because
            !at low LAI, we should treat the plantation as individual trees,
            !each with a canopy resistance and a boundary layer resistance.
            !The big leaf model is no longer applicable.  However, this bug
            !is of no consequence because at low LAI there is low 
            !transpiration and no water stress.
         !2. Occasionally, Nsurf_li_met (N content of the surface litter
            !metabolic pool, kg N m-2) may go negative, due to demand for
            !N from this pool for Csurf_li_met and Csurf_li_lig.
            !This can be tolerated and does not lead to simulation failure.
         !3. Reference height for meteorological measurements, href (m).
            !The default value for this is 50 m.  If a different value 
            !was used, then this needs to be reset at runtime (eg, in
            !response to the acsl prompt, type <set href = 10> say. 
   
   !Scope of model:
      !uniform stands of identical trees of a single species;
      !C, N and water are accounted for;
      !foliage, branches, stem, coarse roots, fine roots and mycorrhiza;
      !meristem, structure, C and N  substrates;
      !soil and water submodels are based on Hurley Pasture Model (HPM);
      !Thornley, 1998, chapters 5 and 6.
   
   !Processes represented are:
      !light interception, photosynthesis, isoprene emission, growth, 
      !growth respiration, maintenance respiration,
      !within-plant transport, litter production, transpiration,
      !plant N uptake, internal N recycling, exudation of C and N,
      !mineralization, non-symbiotic N fixation, nitrication,
      !immobilization,
      !denitrification, volatilization, fertilizer application,
      !atmospheric N deposition, leaching, management thinning,
      !self-thinning/regrowth (under development).
      !Fire: wild fires and prescribed fires.
   
   !Environmental data:
      !The model is driven by instantaneous values of
         !radiation (photosynthetically active radiation = PAR);
         !net radiation. It is assumed that net radiation is 1.4 * PAR;
         !air and soil temperatures;
         !rainfall, humidity, windrun.
   
   !Changes under consideration but not implemented:
      !Should uN (N uptake rate) depend on root depth?
      !Calculate canopy photosynthesis numerically, layer by layer, and
         !allow the needle photosynthetic parameters to vary through the
         !canopy (execution time increases greatly if this is done)
      !Litter from various sources (foliage, branches, stems, course and
         !fine roots has very different decay characteristics
         !(Mike Hornung, Merlewood).
      !Phosphorus often limits the growth of Sitka spruce - so much so
         !that there may be no response to N because P is so short
         !(Tony Harrison, Merlewood).
      !N absorption through the foliage.  Omitted.  Tried it out. 
         !It has no effect.


   !Notes
      !Typical dry weights for 2-3 year old transplants (Sitka spruce) are:
         !Roots     Stem (including branches)    Needles    Root:shoot
         !1.8 g     2.6 g                        3.3 g      0.3
         !These are only a rough guide; in other cultural conditions root
         !dry weight can be close to the shoot dry weight, giving a root:
         !shoot ratio close to unity (Douglas Deans, ITE).
      !Foliage and branches must increase to a maximum (dry matter) and then
         !decline;  cf. Ford (1982); data on 16, 18 year-old Sitka spruce
      !Canopy photosynthesis calculated analytically for maximum execution
         !speed; program written for efficient execution.
      !When simulating plantation growth/death (even-aged monocultures),
         !there is no self-thinning, and s_selfthin = 0, by default.  
         !To turn on self-thinning, set s_selfthin = 1.
         !Eventually, in plantation mode, tree death occurs.
         !That is, the model becomes unstable numerically.  This is 
         !interpreted as tree death.
      !It is possible for a substrate concentration to increase even when
         !all the fluxes are out of the pool. This baffling behaviour may
         !arise because the pool volume (or dry matter) is decreasing even
         !faster than the quantity of substrate in the pool is decreasing.
      !Care: due to fortran 4 treating upper- and lower-case characters
         !as the same.  
      !Disk cache does not affect execution speed, but does
         !affect translation etc. when the hard disk is much used.
      

INITIAL
   !This section is only carried out after a <start>, usually at t = 0 (see
   !below). It is procedural. Neither the translator nor the compiler flag
   !a bug if you use a variable before it is assigned a value.
   !You simply get a baffling execution failure. So take care.
   !Best not to put executable statements before here.

   !Define a character string for storing the name of the file in 
   !a restore/file = 'ipfile.sav' command.
         CHARACTER filenameiv * 12
         Constant filenameiv = 'ivfile.sav' !Default name for ipfile.sav.

   !Changing the start time of a simulation
      VARIABLE t, tic = 0
      !Note (01/04/2020). Setting tic = 10 (say) causes program failure. 
      !Not fixed.
      !This statement allows time to be offset by starting the simulation
      !at say time t = 10, by typing <set tic = 10> at runtime.  
      !Note t = 10 is the beginning
      !of Julian day number 11 (11 Jan).
      !To start on Julian day number 60, (e.g. 1 March), set tic = 59.
      !Do not set tic to a negative number. Failure or nonsense occur.
      !Deciduous simulations must always start on 1 January because of
      !initialization of the phenology submodel.
   
   !ACSL run control parameters
      Algorithm ialg = 3    !Euler method of integration.
      Cinterval cint = 1.0  !day. cint is the communication interval.
                            !cint = time interval at which results are output
                            !to the screen (if nciout = 1), or saved to the
                            !scratch file (.rrr) for plotting,
                            !and printing (if nciprn = 1).
      Maxterval maxt = 0.00781250000000   !1/128 of a day, 11.25 minutes.
         !Sometimes it is necessary (for numerical stability) to change 
         !the integration interval, maxt.
         !Occasionally maxt = one64th (22.5 minutes) works ok and runs
         !faster. !To change maxt at runtime, type eg <set maxt = one1024th>.
         !We set:
            denmaxt = maxt !To help with debugging. / maxt is used sometimes.
            !den denotes denominator.  <d den*> d(isplays) most quantities
            !used in denominators, and can help locate / 0 failures.
      nsteps nsteps = 1  !This ensures that the integration interval is maxt.
      Constant tstop = 0 !day. Simulation stops if t .GE. tstop

   !CONSTANTS 
      Constant minus_one = - 1.0
      Constant pi = 3.1415926536, twopi = 6.2831853072
      Constant c2pi360 = 0.017453293          !2 * pi / 360
      Constant c2pi365 = 0.0172142            !2 * pi / 365
      Constant c24pi = 7.6394373              !24 / pi
      Constant ln2 = 0.69314718056            !Log to base e of 2.
      Constant zero = 0
      Constant c1E_20 = 1.0E-20               !10**-20.
      Constant c1E_17 = 1.0E-17               !10**-17.
      Constant c1E_15 = 1.0E-15               !19**-15.
      Constant c1E_14 = 1.0E-14               !19**-14.
      Constant c1E_10 = 1.0E-10               !10**-10.
      Constant c1E_6 =  1.0E-6                !10**-6.
      Constant c0x00001 = 0.00001
      Constant c0x0001 = 0.0001
      Constant c0x001 = 0.001
      Constant c0x01 = 0.01
      Constant c0x1 = 0.1
      Constant oneOVER365 = 0.0027397260274   !1 / 365.
      Constant quarter = 0.25
      Constant c0x25 = 0.25
      Constant third = 0.333333333333333333
      Constant c0x49 = 0.49 !0.5 less than 0.1, to make a simulation stop at
          !0.5 by setting tstop = 0.49.
      Constant half_0x00390625 = 0.49809375 !0.5 - half default maxt of 1/128
      Constant half = 0.5
      Constant c0x625 = 0.625                 !day = 15 h.
      Constant twothirds = 0.66667
      Constant one = 1.0
      Constant c1x5 = 1.5
      Constant fivethirds = 1.6667
      Constant two = 2.0
      Constant three = 3.0
      Constant four = 4.0
      Constant five = 5.0
      Constant eight = 8.0
      Constant ten = 10.0

      INTEGER i0;   Constant i0 = 0
      INTEGER i1;   Constant i1 = 1
      INTEGER i2;   Constant i2 = 2
      INTEGER i3;   Constant i3 = 3
      INTEGER i4;   Constant i4 = 4
      INTEGER i5;   Constant i5 = 5
      INTEGER i6;   Constant i6 = 6
      INTEGER i7;   Constant i7 = 7
      INTEGER i8;   Constant i8 = 8
      INTEGER i9;   Constant i9 = 9
      INTEGER i10;  Constant i10 = 10
      INTEGER i11;  Constant i11 = 11
      INTEGER i12;  Constant i12 = 12
      INTEGER i13;  Constant i13 = 13
      INTEGER i14;  Constant i14 = 14
      INTEGER i15;  Constant i15 = 15
      INTEGER i16;  Constant i16 = 16
      INTEGER i17;  Constant i17 = 17
      INTEGER i18;  Constant i18 = 18
      INTEGER i19;  Constant i19 = 19
      INTEGER i20;  Constant i20 = 20
      INTEGER i21;  Constant i21 = 21

      INTEGER i365; Constant i365 = 365
      INTEGER i3650;  Constant i3650 = 3650
      INTEGER i36500;  Constant i36500 = 36500
      INTEGER ilarge; Constant ilarge = 77777777 !A large integer. But not
                 !as large as the value assigned initially to all integers,
                 !which is 555555333 is unassigned.
   
     !Julian day numbers for some particular days.
      INTEGER j21Jun; Constant j21Jun = 172 !21 Jun midsummer.
      INTEGER j1Jul;  Constant j1Jul = 182  !1 July.
      INTEGER j1Aug;  Constant j1Aug = 214  !1 August.
      INTEGER j21Dec; Constant j21Dec = 355 !21 December midwinter.
 
      Constant onehourdy = 0.0416666667 !1 hour in units of days.
         !c3600 / c86400 = 1 / 24 = 0.0416666667
         !Compare this with the usual maxt = 0 0078125 and cint = 1 day.
         !Note 1 / 0.0078125 = 128. 
      Constant onehourdyV10 = 0.004166666667 !which is smaller than maxt.
      Constant c10 = 10
      Constant c12 = 12                       !12 months in the year.
      Constant c15 = 15
      Constant c18 = 18
      Constant c20 = 20
      Constant c24 = 24                       !Number of hours in day.
      Constant c30 = 30
      Constant c44 = 44
      Constant c60 = 60                       !Number of minutes in hour.
      Constant c90 = 90
      Constant c99x9999 = 99.9999
      Constant c100 = 100
      Constant c180 = 180
      Constant c200 = 200
      Constant c350 = 350                     !for use with CO2vpm = 350.
      Constant c360 = 360
      Constant c3600 = 3600          !s hour-1.  Number of seconds in an hour.
      Constant c365 = 365            !365 days in the year; units: days/year.
      Constant c670 = 670                     !days, about 22 month_r. Aphids
      Constant c700 = 700                     !for use with CO2vpm = 700.
      Constant c1000 = 1.0e3         !1000.0.
      Constant c1440 = 1440          !Number of minutes in a day.
      Constant c1yr = 365            !Number of days in 1 year. 
      Constant c2yrs = 730           !Number of days in 2 years. 
      Constant c3yrs = 1095          !Number of days in 3 years. 
      Constant c5yrs = 1825          !Number of days in 5 years. 
      Constant c6yrs = 2190          !Number of days in 6 years. eg co c6yrs,
      Constant c7yrs = 2555          !Number of days in 7 years. or
      Constant c8yrs = 2920          !Number of days in 8 years. go c8yrs 365
      Constant c9yrs = 3285          !Number of days in 9 years.
      Constant c11yrs = 4015         !Number of days in 11 years.
      Constant c12yrs = 4380         !Number of days in 12 years.
      Constant c21yrs = 7665         !Number of days in 21 years.
      Constant c25yrs = 9125         !Number of days in 25 years.
      Constant c30yrs = 10950        !Number of days in 30 years.
      Constant c51yrs = 18615        !Number of days in 51 years.
      Constant c60yrs = 21900        !Number of days in 60 years.
      Constant c90yrs = 32850        !Number of days in 90 years.
      Constant c101yrs = 36865       !Number of days in 101 years.
      Constant c10000 = 10000.0      !number of m2 per hectare.
      Constant c86400 = 86400.0      !s day-1.  Number of seconds in a day.
      Constant c1E6 = 1.0e6          !10**6.
      Constant c1E7 = 1.0e7          !10**7. Converts kg m-2 to g ha-1.
      Constant c1E8 = 1.0e8          !10**8. 
      Constant c3650000 = 3650000.0  !For converting m-2 day-1 to ha-1 year-1.
      Constant c365e6 = 365000000.0  !For converting J year-1 to MJ day-1.
                                     !or, 1 million years (in days).
      Constant clarge = 7.7777e17     !An easily recognizable large number.
      Constant csmall = 7.7777e-17    !An easily recognizable small number.
      Constant one16th =   0.06250000000000   !1/16 of a day, 1.50 hours.
      Constant one24th =   0.04166666666666667!1/24 of a day, 1 hour.
      Constant one32nd =   0.03125000000000   !1/32 of a day, 45 minutes.
      Constant one64th =   0.01562500000000   !1/64 of a day, 22.50 minutes.
      Constant one120th =  0.00833333333333333!1/120 of a day, 12 minutes.
      Constant one128th =  0.00781250000000   !1/128 of a day, 11.25 min.
      Constant one256th =  0.00390625000000   !1/256 of a day,  5.625 min.
      Constant one512th =  0.00195312500000   !1/512 of a day,  2.8125 min.
      Constant one1024th = 0.00097656250000   !1/1024 of a day, 1.40625 min.
      Constant one2048th = 0.00048828125000   !1/2048 of a day, 0.703125 min.
      Constant half_an_hour = 0.02083333333333!day.
      Constant one_hour = 0.04166666666666667 !day.
      Constant two_hour = 0.08333333333333333 !day.
      !yyy

   !It is useful to be able to number runs in a cmd file. This we do with
      INTEGER runno  
      Constant runno = 77777777 
               !Set this to a large easily recognizable integer.
   
   !Start counter initialization and updating
      INTEGER nstart, year_accum
             !nstart keeps track of number of starts executed.
             !year_accum counts the number of integer years of the whole
                !session.

      IF ( nstart .GT. ilarge ) THEN !True only for 1st start of a session.
           nstart = i1          !when nstart = 555555333 and ilarge = 77777777
           year_accum = i0     !Year accumulator for the whole session.
      ELSE
           nstart = nstart + i1 !nstart = 2 means we are executing or have
                                !executed the 2nd start.
      ENDIF


   !Rotation counter initialization and updating
      !irotate is involved in data input initialization.
      INTEGER irotate !Rotation counter. 1, 2, ...
      Constant s_rotate = 0  !Rotation switch. Default is no rotation.
           one_s_rotate = one - s_rotate 
      IF ( s_rotate .EQ. one ) THEN      !Rotation is switched on.
         IF ( irotate .GT. ilarge ) THEN !True on 1st rotation.
              irotate = i1               !Set to 1.
         ELSE                            !True on 2nd and later rotations.
              irotate = irotate + i1     !add 1 to irotate.
         ENDIF
            !irotate = number of current rotation, initialized to 1.
            !irotate = 1, 2, & .  If irotate = 2, the plantation has been
            !cleared once, and we are in the 2nd rotation.
      ENDIF
            

   !ENVIRONMENTAL VARIABLES
      !Variables
         !daylengthhr hour day-1. Daylength (daily value).
         !jPARdy   J m-2 day-1.   Daily (PAR) radiation receipt.
         !jPARsc   J m-2 s-1.     Instantaneous (PAR) radiation flux.
         !RH (range: 0 to 1).     Relative humidity (instantaneous value).
         !Tair     C.             Air temperature (instantaneous value).
         !Tsoil    C.             Soil temperature (daily mean).
         !Wind     m s-1.         Wind speed (instantaneous value).

      !Seasonally varying environment.  If
         Constant s_seasonal = 1 !with this default value the following
            !environmental variables vary seasonally:
               !air temperature (daily max and min);
               !day length (a daily variable - not instantaneous)
               !soil temperature;
               !radiation;
               !rainfall;
               !relative humidity (daily max and min);
               !wind (daily max and min).
         !If s_seasonal = 0, then there is no seasonal variation.
         !   Mean annual values are used.
         !   Day length is constant at 12 h.
   
      !Diurnally varying environment.  If
         Constant s_diurnal = 1   !this default value gives diurnal variation
                                  !of
               !air temperature, radiation, relative humidity, wind.
         !Set s_diurnal = 0, then there is no diurnal variation.
         !Mean daily values are applied (care - radiation).
                  one_s_diurnal = one - s_diurnal !Working variable.
      

   !ENVIRONMENTAL DATA: initialization
      
      !Diurnal environmental data (di)
         !If diurnally varying environmental data are supplied, then type 
         !<set s_diurnal_dat = 1.0> at runtime.
         !The data can be in the default filename, diurnal.dat, or in
         !a file which is named at runtime: 
         !e.g. <set filenamedi = 'Zurichdi.dat'>.
         Constant s_diurnal_dat = 0.0  !Default value. 
                                       !No diurnal data supplied.
              one_s_diurnal_dat = one - s_diurnal_dat !Working variable.
         CHARACTER filenamedi * 20
         Constant filenamedi = 'diurnal.dat'      !Default name for filenamedi.
         CHARACTER linedumpdi * 120 !A place for dumping lines.
         CHARACTER Title_di_data_file * 120 !Store the title array.
         tdi_dump = -one !Initialize this to <1, so that diurnal data output
                         !can occur.
         year_di0 = 2000 !Initialize this, because year_di0 is used
                         !for output of diurnal data, even when this
                         !diurnal data input section is not used.
 
        INTEGER ilogd; 
        ilogd = i0 
        !CALL LOGD ( .true. ) !0
        ilogd = ilarge !ilarge is 77777777, small than the unassigned integer
                       !variable of 5555555533
!This worked ok. In the nonsorted Initial block.

         IF ( s_diurnal_dat .EQ. one ) THEN !
                     !CALL LOGD statements are for use when debugging.
                     !ACSL Reference Manual, section 4.68, pages 4-55 to 4-56.
                     LOGICAL calllogd !If calllogd = .true. output occurs.
                     Constant calllogd = .false.  !Default value
            OPEN (UNIT = 50, FILE = filenamedi); REWIND 50
            READ (50, *) Title_di_data_file !Read the title line.
            READ (50, *) linedumpdi         !Read and dump a line.
            READ (50, *) latitude_deg_di    !Read in latitude.
            READ (50, *) linedumpdi; READ (50, *) linedumpdi
            READ (50, *) linedumpdi; READ (50, *) linedumpdi
                    !Read and dump the next four lines.
               INTEGER year_di0, year_di1, year_di2, &
                       JulianDy_di1, JulianDy_di2, day_di1, day_di2, &
                       month_di1, month_di2
                         !hour_di? and minute_di? (if used)
                         !are left as decimal variables.
            !Now read the first data line of the file:
            !NOTA BENE : The minutes input option has been commented out.
      !        READ (50, *) minute_di1, hour_di1, day_di1, month_di1, &
               READ (50, *)             hour_di1, day_di1, month_di1, &
                            JulianDy_di1, year_di1, PAR_di1, Tair_di1, &
                            Tsoil_di1, rain_di1, wind_di1, RH_di1
               year_di0 = year_di1  !Store this first year value.
               t_di1 = ( year_di1 - year_di0 ) * c365 + JulianDy_di1 - one &
                        + hour_di1 / c24 !+ minute_di1 / c1440      !NOTA BENE.
            !and read the second data line of the file:
      !        READ (50, *) minute_di2, hour_di2, day_di2, month_di2, &
               READ (50, *)             hour_di2, day_di2, month_di2, &
                            JulianDy_di2, year_di2, PAR_di2, Tair_di2, &
                            Tsoil_di2, rain_di2, wind_di2, RH_di2
               t_di2 = ( year_di2 - year_di0 ) * c365 + JulianDy_di2 - one &
                        + hour_di2 / c24 !+ minute_di2 / c1440     !NOTA BENE. 
   
            ixtra_days_rw_di = 0 !Initialize this to zero.  It is used when 
                                 !rewinding the diurnal.dat file to keep time
                                 !on track.
         ENDIF !End of IF ( s_diurnal_dat .EQ. one ) THEN ! block.
      
      !Daily environmental data.  Daily data is input.
         !If daily environmental data are supplied for input, 
         !then type <set s_daily_dat = 1> at runtime.
         !The data can be in the default filename, daily.dat, or in a
         !file which is named at runtime: e.g. set filenamedy = 'Zurichdd.dat'.
          Constant s_daily_dat = 0.0   !Default, no daily data supplied.
               one_s_daily_dat = one - s_daily_dat
      
         CHARACTER filenamedy * 20
         Constant filenamedy = 'daily.dat' !Default name for filenamedy.
         CHARACTER linedumpdy * 120        !A place for dumping lines.
         CHARACTER Title_daily_dat_file * 70 !Store the title array.
         INTEGER idaymo_dy 
         idaymo_dy = i1   !Reset this in case it is zero, because of a previous
                          !run in this session inputting daily data, which
                          !would cause execution to stop at t = 0.
      
         IF ( s_daily_dat .EQ. one ) THEN
            OPEN (UNIT = 50, FILE = filenamedy); REWIND 50
            READ (50, *) Title_daily_dat_file !Read the title line.
            READ (50, *) latitude_deg_dy !Read in latitude from daily.dat file.
            READ (50, *) linedumpdy; READ (50, *) linedumpdy
            READ (50, *) linedumpdy; READ (50, *) linedumpdy
               !Read and dump the next four records of daily data file,
               !default name is daily.dat. 
         ENDIF
    
      !Monthly environmental data - 12 months (average) monthly data and
         !interpolation
         !This section reads in 12 months of average monthly data, and by
            !interpolation, gives arrays daily data values.
         !Monthly data are from Meteorological Office (Bracknell, UK):
            !Tables of temperature, relative humidity, precipitation and
            !sunshine for the world. Part III Europe and the Azores.
         !Declare arrays to hold the monthly data as in the Met tables:
            ARRAY Tmax_mon(12), Tmin_mon(12) !deg C. Average daily max and min
                                             !temperatures.
            ARRAY RHmaxz_mon(12), RHminz_mon(12) !%. Average of am, pm RH
                                             !observations. 
            ARRAY pption_mon(12)  !Average monthly precipitation in mm.
            ARRAY bshrs_mon(12)   !Average monthly duration of bright sunshine
                                  !hours.
         !Declare arrays for transformed data (still monthly averages):
            ARRAY RHmax_mon(12), RHmin_mon(12), &
                  raind_mon(12), & !Rain in m day-1.
                  bshrsd_mon(12)   !This is bshrs per day.
         ARRAY days_per_month(12)  !Days per month (no leap years).
           !The efm does not take any account of leap years.
            Constant days_per_month = 31, 28, 31,   30, 31, 30, &
                                      31, 31, 30,   31, 30, 31
         
         ARRAY dpm(12) !An array for storing days_per_month.
         INTEGER dpm
               Constant dpm = 31, 28, 31,   30, 31, 30, &
                              31, 31, 30,   31, 30, 31
               !idpm is not used, only for output convenience.
         !Value of time variable t at midpoint of each month:
            !15.5,   45,   74.5,  105, 135.5, 166, &
            !196.5, 227.5, 258,   288.5, 319, 349.5
         ARRAY Jmpm(12)  !Julian midpoint month. Not necessarily an integer.
            !Add 0.5 to time t of midpoint of the month (e.g. 15.5 for Jan)
            !to get a Julian midpoint of the month.  
            !For Jan this is 16 Jan, with 15 days
            !before and 15 days after.  
            !For Feb, there is no integer midpoint day.
            Constant Jmpm =  16,  45.5, 75,    105.5, 136, 166.5, &
                            197, 228,  258.5,  289, 319.5, 350
         ARRAY J1st_day_mon(12)  !1st day of each month using Julian counting.
            Constant J1st_day_mon = 1, 32, 60,   91, 121, 152, &
                                  182, 213, 244,  274, 305, 335
      
      
         Constant s_months12_dat = 0  !Default. 
                                      !Do not read in months12.dat file.
         !To read in mean monthly environmental data,
         !type <set s_months12_dat = 1> or <months12_dat> at runtime.
                 one_s_months12_dat = one - s_months12_dat
         INTEGER imonth !index for addressing the months.
         CHARACTER filenamem12 * 20
         Constant filenamem12 = 'months12.dat' !Default filename for 12 
                                               !months of mean monthly data.
         CHARACTER blank20 * 20 !This character array is 20 blanks.  
                  !It is used for setting filenames to blanks.
         Constant blank20 = '                    ' !Initialize blank20.
                            !12345678901234567890  with 20 blanks.
         IF ( s_months12_dat .EQ. one ) THEN
            OPEN (UNIT = 50, FILE = filenamem12); REWIND 50
               !At runtime, filenamem12 may be reset to
               !Zurich.dat or whatever with: <set filenamem12 = 'zurich.dat'>
            CHARACTER linedumpm12 * 120 !Dump for a line of characters.
            READ (50, *) linedumpm12  !Read and dump a title line.
            READ (50, *) latitude_deg_m12
               !Read in latitude from months12.dat file.
            READ (50, *) a_Angstrom_m12, b_Angstrom_m12
               !Read in location-specific constants for the Angstrom formula.
            READ (50, *) linedumpm12  !Read and dump another title line.
            READ (50, *) INenv_Namm_hayr_m12  !kg N ha-1 year-1.
               INenv_Namm_m12 = INenv_Namm_hayr_m12 / c3650000 !kg N m-2 day-1.
            READ (50, *) fclay_m12  !Clay fraction, for fclay.
            READ (50, *) linedumpm12  !Read and dump another title line.
            DO mo_dat_loop imonth = 1, 12
               READ (50, *) Tmax_mon ( imonth ), Tmin_mon ( imonth ), &
                  RHmaxz_mon ( imonth ), RHminz_mon ( imonth ), &
                  pption_mon ( imonth ), bshrs_mon ( imonth )
                     !bshrs_mon: bright sunshine hours per month.
               
               !Convert units where required:
                  RHmax_mon ( imonth ) = c0x01 * RHmaxz_mon ( imonth )
                  RHmin_mon ( imonth ) = c0x01 * RHminz_mon ( imonth )
                                              !RH is in range 0 to 1.
                  raind_mon ( imonth ) = pption_mon ( imonth ) * 0.001 &
                           / days_per_month ( imonth )  !Units now m day-1.
                  bshrsd_mon ( imonth ) = bshrs_mon ( imonth ) &
                                     / days_per_month ( imonth )
                  !Bright sunshine hours are now h per day, monthly average.
            mo_dat_loop..CONTINUE
            CLOSE ( UNIT = 50)
      
         !Generate daily data for the year from the monthly means.
               !Interpolate linearly between monthly average values placed 
               !at the mid-point of each month to obtain daily values.
               !NOTE: many of the variable names used here for interpolated
               !data, *_int, are the same as used below for interpolated
               !CLINO monthly data.
               !Arrays for the interpolated daily data are:
   !               ARRAY Tmax_int(365), Tmin_int(365), &
   !                     RHmax_int(365),  RHmin_int(365), &
   !                     rain_int(365), bshrs_int(365) 
                   !These are declared below.
            !The main DO loop begins: 
            INTEGER iJulianm12, iJulianm12p306
            DO int_end iJulianm12 = 1, 365
               !First calculate month  ( imonth ), and day of month (idaymo), 
                  !from iJulianm12, Julian day number:
                  iJulianm12p306 = iJulianm12 + 306
                  IF ( iJulianm12p306 .GT. 365 ) &
                       iJulianm12p306 = iJulianm12p306 - 365
                     imonth = INT ( ( iJulianm12p306 + 91.3 ) / 30.6 )  
                     idaymo = INT ( iJulianm12p306 - 30.6 * imonth + 92.3 )  
                  IF ( imonth .GE. 13 ) &
                     imonth = imonth - 12
         
            !First half of January:
            IF ( iJulianm12 .LT. Jmpm (1) ) THEN 
               m_interp1 = ( iJulianm12 + c365 - Jmpm ( 12 ) ) / & 
                           ( Jmpm ( 1 ) + c365 - Jmpm ( 12 ) )
               !Air temperature, maximum (deg C):
                  Tmax_int ( iJulianm12 ) = Tmax_mon ( 12 ) + &
                     ( Tmax_mon ( 1 ) - Tmax_mon ( 12 ) ) * m_interp1
               !Air temperature, minimum (deg C):
                  Tmin_int ( iJulianm12 ) = Tmin_mon ( 12 ) + &
                     ( Tmin_mon ( 1 ) - Tmin_mon ( 12 ) ) * m_interp1
               !Relative humidity, early morning measurement (0 to 1):
                  RHmax_int ( iJulianm12 ) = RHmax_mon ( 12 ) + &
                     ( RHmax_mon ( 1 ) - RHmax_mon ( 12 ) ) * m_interp1
               !Relative humidity, afternoon measurement (0 to 1):
                  RHmin_int ( iJulianm12 ) = RHmin_mon ( 12 ) + &
                     ( RHmin_mon ( 1 ) - RHmin_mon ( 12 ) ) * m_interp1
               !Rainfall (m day-1):
                  rain_int ( iJulianm12 ) = raind_mon ( 12 ) + &
                     ( raind_mon ( 1 ) - raind_mon ( 12 ) ) * m_interp1
               !Bright sunshine hours (hours day-1):
                  bshrs_int ( iJulianm12 ) = bshrsd_mon ( 12 ) + &
                     ( bshrsd_mon ( 1 ) - bshrsd_mon ( 12 ) ) * m_interp1
         
            !Second half of every month from January to November:
            ELSE &
            IF ( ( imonth .LE. i11 ) .AND. &
                   Jmpm ( imonth )  .LE.  iJulianm12  .AND. &
                        ( iJulianm12 .LT. J1st_day_mon ( imonth + i1 ) ) &
               ) THEN 
               m_interp2 = ( iJulianm12 - Jmpm ( imonth ) ) / & 
                          ( Jmpm ( imonth + 1 ) - Jmpm ( imonth ) )
               Tmax_int ( iJulianm12 ) = Tmax_mon ( imonth ) + &
                  ( Tmax_mon ( imonth + 1 ) - Tmax_mon ( imonth ) ) &
                                                            * m_interp2
               Tmin_int ( iJulianm12 ) = Tmin_mon ( imonth ) + &
                  ( Tmin_mon ( imonth + 1 ) - Tmin_mon ( imonth ) ) &
                                                            * m_interp2
               RHmax_int ( iJulianm12 ) = RHmax_mon ( imonth ) + &
                  ( RHmax_mon ( imonth + 1 ) - RHmax_mon ( imonth ) ) &
                                                            * m_interp2
               RHmin_int ( iJulianm12 ) = RHmin_mon ( imonth ) + &
                  ( RHmin_mon ( imonth + 1 ) - RHmin_mon ( imonth ) ) &
                                                            * m_interp2
               rain_int ( iJulianm12 ) = raind_mon ( imonth ) + &
                  ( raind_mon ( imonth + 1 ) - raind_mon ( imonth ) ) &
                                                            * m_interp2
               bshrs_int ( iJulianm12 ) = bshrsd_mon ( imonth ) + &
                  ( bshrsd_mon ( imonth + 1 ) - bshrsd_mon ( imonth ) ) &
                                                            * m_interp2
         
            !First half of every month from February to December:
            ELSE & 
            IF (  ( imonth .GE. i2 ) .AND. &
                   J1st_day_mon ( imonth ) .LE. iJulianm12 .AND. &
                          ( iJulianm12 .LT. Jmpm ( imonth )  ) &
               ) THEN 
               m_interp3 = ( Jmpm ( imonth ) - iJulianm12 ) / & 
                           ( Jmpm ( imonth ) - Jmpm ( imonth - 1 ) )
               Tmax_int ( iJulianm12 ) = Tmax_mon ( imonth ) - &
                  ( Tmax_mon ( imonth ) - Tmax_mon ( imonth - 1 ) ) &
                                                            * m_interp3
               Tmin_int ( iJulianm12 ) = Tmin_mon ( imonth ) - &
                  ( Tmin_mon ( imonth ) - Tmin_mon ( imonth - 1 ) ) &
                                                            * m_interp3
               RHmax_int ( iJulianm12 ) = RHmax_mon ( imonth ) - &
                  ( RHmax_mon ( imonth ) - RHmax_mon ( imonth - 1 ) ) &
                                                            * m_interp3
               RHmin_int ( iJulianm12 ) = RHmin_mon ( imonth ) - &
                  ( RHmin_mon ( imonth ) - RHmin_mon ( imonth - 1 ) ) &
                                                            * m_interp3
               rain_int ( iJulianm12 ) = raind_mon ( imonth ) - &
                  ( raind_mon ( imonth ) - raind_mon ( imonth - 1 ) ) &
                                                            * m_interp3
               bshrs_int ( iJulianm12 ) = bshrsd_mon ( imonth ) - &
                  ( bshrsd_mon ( imonth ) - bshrsd_mon ( imonth - 1 ) ) &
                                                            * m_interp3
            !Last half of December:    
            ELSE IF ( Jmpm ( 12 ) .LE. iJulianm12 ) THEN 
               m_interp4 = ( iJulianm12 - Jmpm ( 12 ) ) / & 
                           ( Jmpm ( 1 ) + c365 - Jmpm ( 12 ) )
               Tmax_int ( iJulianm12 ) = Tmax_mon ( 12 ) + &
                  ( Tmax_mon ( 1 ) - Tmax_mon ( 12 ) ) * m_interp4
               Tmin_int ( iJulianm12 ) = Tmin_mon ( 12 ) + &
                  ( Tmin_mon ( 1 ) - Tmin_mon ( 12 ) ) * m_interp4
               RHmax_int ( iJulianm12 ) = RHmax_mon ( 12 ) + &
                  ( RHmax_mon ( 1 ) - RHmax_mon ( 12 ) ) * m_interp4
               RHmin_int ( iJulianm12 ) = RHmin_mon ( 12 ) + &
                  ( RHmin_mon ( 1 ) - RHmin_mon ( 12 ) ) * m_interp4
               rain_int ( iJulianm12 ) = raind_mon ( 12 ) + &
                  ( raind_mon ( 1 ) - raind_mon ( 12 ) ) &
                                                    * m_interp4
               bshrs_int ( iJulianm12 ) = bshrsd_mon ( 12 ) + &
                  ( bshrsd_mon ( 1 ) - bshrsd_mon ( 12 ) ) &
                                                    * m_interp4
            ENDIF
            int_end..CONTINUE  !End of DO int_end interpolation loop.
         ENDIF !IF ( s_months12_dat .EQ. one ) THEN

      !End of monthly data input and interpolation from 12-month mean
      !monthly data file.
   
    
      !CLINO. Climatological normals. Tables from the World Meteorological
         !Office (WMO). WMO/OMM - No. 847. 1961 - 1990 (30-year) averages. 
         !Monthly data for the 12 calendar months.

         !This section reads in 12 months of average monthly data.  Default
            !data file is CLINO.dat.
         !Declare arrays to hold the monthly data as in the CLINO tables:
            ARRAY AtmPhPa_CLINO(12)  !hPa. Atmospheric pressure in 
                                  !hectopascals or units of 100 Pa.
            ARRAY Tmean_CLINO(12) !deg C. Monthly mean temperatures.
            ARRAY Tmax_CLINO(12), Tmin_CLINO(12) !deg C. Daily maximum
                                  !and daily minimum temperatures.
            ARRAY Tabsmax_CLINO(12), Tabsmin_CLINO(12) !Highest and lowest
                                  !temperatures observed during the period
                                  !specified in the data file.
            ARRAY VapPhPa_CLINO(12)   !hPA. Mean vapour pressure.
            ARRAY RHmeanpc_CLINO(12)  !per cent (%). Mean relative humidity.
            ARRAY RHmaxpc_CLINO(12), RHminpc_CLINO(12) !percent (%).
                                  !Average of mean daily maximum and
                                  !minimum relative humidity observations.
                                             !observations.
            ARRAY bshrsmo_CLINO(12) !hours per month. Average monthly 
                                  !duration of bright sunshine hours.
            ARRAY wind_CLINO(12)  !m s-1. Mean wind speed.
            ARRAY pptnmmmo_CLINO(12) !Average monthly precipitation in mm.

         !Declare arrays for any transformed monthly data:
            ARRAY RHmean_CLINO(12), RHmax_CLINO(12), RHmin_CLINO(12), &
                  pptn_CLINO(12), bshrs_CLINO(12), AtmP_CLINO(12), &
                  VapP_CLINO(12)

         !These commented-out declarations are made below.
         !ARRAY days_per_month(12)  !Days per month (no leap years).
           !The efm does not take any account of leap years.
         !   Constant days_per_month = 31, 28, 31,   30, 31, 30, &
         !                             31, 31, 30,   31, 30, 31
         !Value of time variable t at midpoint of each month:
            !15.5,   45,   74.5,  105, 135.5, 166, &
            !196.5, 227.5, 258,   288.5, 319, 349.5
         !ARRAY Jmpm(12)  !Julian midpoint month. Not necessarily an integer.
            !Add 0.5 to time t of midpoint of the month (e.g. 15.5 for Jan)
            !to get a Julian midpoint of the month.  
            !For Jan this is 16 Jan, with 15 days
            !before and 15 days after.  
            !For Feb, there is no integer midpoint day.
         !   Constant Jmpm =  16,  45.5, 75,    105.5, 136, 166.5, &
         !                   197, 228,  258.5,  289, 319.5, 350
         !ARRAY J1st_day_mon(12)  !1st day of each month using Julian counting.
            !Constant J1st_day_mon = 1, 32, 60,   91, 121, 152, &
            !                      182, 213, 244,  274, 305, 335
      
         Constant s_CLINO_dat = 0  !Default. 
                                   !Do not read CLINO data.
         !To read in CLINO mean monthly environmental data,
         !type <set s_CLINO_dat = 1> or <CLINO> at runtime.
                 one_s_CLINO_dat = one - s_CLINO_dat
         !INTEGER imonth !index for addressing the months.
         CHARACTER filenameCLINO * 20
         Constant filenameCLINO = 'CLINO.dat' !Default filename for 12 
                              !months of CLINO style mean monthly data.
         IF ( s_CLINO_dat .EQ. one ) THEN
            OPEN (UNIT = 50, FILE = filenameCLINO); REWIND 50
            !Search down for CLOSE ( UNIT = 50 )   
            !At runtime, filenameCLINO may be reset to
               !sault.dat or whatever with: <set filenameCLINO = 'sault.dat'>
            CHARACTER linedumpCLINO * 120 !Dump for a line of characters.
            READ (50, *) linedumpCLINO  !Read and dump a title line.
            READ (50, *) latitude_deg_CLINO
               !Read in latitude from CLINO.dat file.
            READ (50, *) a_Angstrom_CLINO, b_Angstrom_CLINO
               !Read in location-specific constants for the Angstrom formula.
            READ (50, *) linedumpCLINO;  READ (50, *) linedumpCLINO
                        !Read and dump two title lines.
            READ (50, *) INenv_Namm_hayr_CLINO            !kg N ha-1 year-1.
               INenv_Namm_CLINO = INenv_Namm_hayr_CLINO / c3650000 
                                                          !kg N m-2 day-1.
            READ (50, *) fclay_CLINO  !Clay fraction, for fclay.

            READ (50, *) linedumpCLINO; READ (50, *) linedumpCLINO
            READ (50, *) linedumpCLINO; READ (50, *) linedumpCLINO  
            READ (50, *) linedumpCLINO; READ (50, *) linedumpCLINO
            READ (50, *) linedumpCLINO; READ (50, *) linedumpCLINO  
            READ (50, *) linedumpCLINO; READ (50, *) linedumpCLINO

             !Use this input statement if a mean RH is given. Otherwise
             !use the input statement below which has been commented out.
            DO CLINO_dat_loop imonth = 1, 12
               READ (50, *) AtmPhPa_CLINO ( imonth ), &
                  Tmean_CLINO ( imonth ), &
                  Tmax_CLINO ( imonth ), Tmin_CLINO ( imonth ), &
                  Tabsmax_CLINO ( imonth ), Tabsmin_CLINO ( imonth ), &
                  VapPhPa_CLINO ( imonth ), &
                  RHmeanpc_CLINO ( imonth ), &
                  bshrsmo_CLINO ( imonth ), wind_CLINO ( imonth ), &
                  pptnmmmo_CLINO ( imonth )

                  RHmaxpc_CLINO ( imonth ) = clarge
                  RHminpc_CLINO ( imonth ) = clarge

               !Use the statement below if RHmax and RHmin are given
               !in the data file (rather than mean RH).
!              READ (50, *) AtmPhPa_CLINO ( imonth ), &
!                  Tmean_CLINO ( imonth ), &
!                  Tmax_CLINO ( imonth ), Tmin_CLINO ( imonth ), &
!                  Tabsmax_CLINO ( imonth ), Tabsmin_CLINO ( imonth ), &
!                  VapPhPa_CLINO ( imonth ), &
!                  RHmaxpc_CLINO ( imonth ), RHminpc_CLINO ( imonth ), &
!                  bshrsmo_CLINO ( imonth ), wind_CLINO ( imonth ), &
!                  pptnmmmo_CLINO ( imonth )

!                  RHmeanpc_CLINO ( imonth ) = clarge
                     !bshrsmo_CLINO: bright sunshine hours per month.
                     !pptnmmmo_CLINO: rain fall (mm) per calendar month.
               
               !Convert units where required:
                  AtmP_CLINO ( imonth ) = c100 * AtmPhPa_CLINO ( imonth ) !Pa.
                  VapP_CLINO ( imonth ) = c100 * VapPhPa_CLINO ( imonth ) !Pa.
                  RHmean_CLINO ( imonth ) = c0x01 * RHmeanpc_CLINO ( imonth )
                  RHmax_CLINO ( imonth ) = c0x01 * RHmaxpc_CLINO ( imonth ) 
                                  !RH is now in range 0 to 1.
                  RHmin_CLINO ( imonth ) = c0x01 * RHminpc_CLINO ( imonth )
                  pptn_CLINO ( imonth ) = pptnmmmo_CLINO ( imonth ) * 0.001 &
                           / days_per_month ( imonth )  !Units now m day-1.
                  bshrs_CLINO ( imonth ) = bshrsmo_CLINO ( imonth ) &
                                           / days_per_month ( imonth )
                  !Bright sunshine hours are now h per day, monthly average.
            CLINO_dat_loop..CONTINUE
            CLOSE ( UNIT = 50 )

      
         !Generate daily data for the year from the monthly means.
            !Interpolate linearly between monthly average values placed at the
            !mid-point of each month to obtain daily values.
            !Arrays for the interpolated daily data are:
               ARRAY AtmP_int(365),  Tmean_int(365), &
                     Tmax_int(365),  Tmin_int(365), &
                     VapP_int(365),  RHmean_int(365), &
                     RHmax_int(365), RHmin_int(365), &
                     bshrs_int(365), rain_int(365), &
                     wind_int(365)
         
         !The main DO loop begins:
               !NOTE: many of the variable names used here for interpolated
               !data, *_int, are the same as used above for interpolated
               !months12 monthly data.
         INTEGER iJulianCLINO, iJulianCLINO306
         DO int_CLINO_end iJulianCLINO = 1, 365
               !First calculate month (imonth), and day of month (idaymo), 
                  !from iJulianCLINO, Julian day number
                  !(using numerical algorithm):
                  iJulianCLINO306 = iJulianCLINO + 306
                  IF ( iJulianCLINO306 .GT. 365 ) &
                        iJulianCLINO306 = iJulianCLINO306 - 365
                     imonth = INT ( ( iJulianCLINO306 + 91.3 ) / 30.6 )  
                     idaymo = INT ( iJulianCLINO306 - 30.6 * imonth + 92.3 ) 

                  IF ( imonth .GE. 13 ) &
                     imonth = imonth - 12
         
            !First half of January:
            IF ( iJulianCLINO .LT. Jmpm (1) ) THEN 
               m_interp1 = ( iJulianCLINO + c365 - Jmpm ( 12 ) ) / & 
                           ( Jmpm ( 1 ) + c365 - Jmpm ( 12 ) )
               !Atmospheric pressure (Pa):
                  AtmP_int ( iJulianCLINO ) = AtmP_CLINO ( 12 ) + &
                     ( AtmP_CLINO ( 1 ) - AtmP_CLINO ( 12 ) ) * m_interp1
               !Mean air temperature (deg C):
                  Tmean_int ( iJulianCLINO ) = Tmean_CLINO ( 12 ) + &
                     ( Tmean_CLINO ( 1 ) - Tmean_CLINO ( 12 ) ) * m_interp1
               !Air temperature, maximum (deg C):
                  Tmax_int ( iJulianCLINO ) = Tmax_CLINO ( 12 ) + &
                     ( Tmax_CLINO ( 1 ) - Tmax_CLINO ( 12 ) ) * m_interp1
               !Air temperature, minimum (deg C):
                  Tmin_int ( iJulianCLINO ) = Tmin_CLINO ( 12 ) + &
                     ( Tmin_CLINO ( 1 ) - Tmin_CLINO ( 12 ) ) * m_interp1
               !Vapour pressure (Pa):
                  VapP_int ( iJulianCLINO ) = VapP_CLINO ( 12 ) + &
                     ( VapP_CLINO ( 1 ) - VapP_CLINO ( 12 ) ) * m_interp1
               !Relative humidity, mean (0 to 1):
                  RHmean_int ( iJulianCLINO ) = RHmean_CLINO ( 12 ) + &
                     ( RHmean_CLINO ( 1 ) - RHmean_CLINO ( 12 ) ) * m_interp1
               !Relative humidity, early morning measurement (0 to 1):
                  RHmax_int ( iJulianCLINO ) = RHmax_CLINO ( 12 ) + &
                     ( RHmax_CLINO ( 1 ) - RHmax_CLINO ( 12 ) ) * m_interp1
               !Relative humidity, afternoon measurement (0 to 1):
                  RHmin_int ( iJulianCLINO ) = RHmin_CLINO ( 12 ) + &
                     ( RHmin_CLINO ( 1 ) - RHmin_CLINO ( 12 ) ) * m_interp1
               !Bright sunshine hours (hours day-1):
                  bshrs_int ( iJulianCLINO ) = bshrs_CLINO ( 12 ) + &
                     ( bshrs_CLINO ( 1 ) - bshrs_CLINO ( 12 ) ) * m_interp1
               !Mean wind speed (m s-1):
                  wind_int ( iJulianCLINO ) = wind_CLINO ( 12 ) + &
                     ( wind_CLINO ( 1 ) - wind_CLINO ( 12 ) ) * m_interp1
               !Rainfall (m day-1):
                  rain_int ( iJulianCLINO ) = pptn_CLINO ( 12 ) + &
                     ( pptn_CLINO ( 1 ) - pptn_CLINO ( 12 ) ) * m_interp1
         
            !Second half of every month from January to November:
            ELSE &
            IF ( ( imonth .LE. i11 ) .AND. &
                   Jmpm ( imonth )  .LE.  iJulianCLINO  .AND. &
                     ( iJulianCLINO  .LT.  J1st_day_mon ( imonth + i1 ) ) &
               ) THEN 
               m_interp2 = ( iJulianCLINO - Jmpm ( imonth ) ) / & 
                          ( Jmpm ( imonth + 1 ) - Jmpm ( imonth ) )
               !Atmospheric pressure (Pa):
                  AtmP_int ( iJulianCLINO ) = AtmP_CLINO ( imonth ) + &
                     ( AtmP_CLINO ( imonth + 1 ) - AtmP_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Mean air temperature (deg C):
                  Tmean_int ( iJulianCLINO ) = Tmean_CLINO ( imonth ) + &
                  ( Tmean_CLINO ( imonth + 1 ) - Tmean_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Air temperature, maximum (deg C):
                  Tmax_int ( iJulianCLINO ) = Tmax_CLINO ( imonth ) + &
                     ( Tmax_CLINO ( imonth + 1 ) - Tmax_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Air temperature, minimum (deg C):
                  Tmin_int ( iJulianCLINO ) = Tmin_CLINO ( imonth ) + &
                     ( Tmin_CLINO ( imonth + 1 ) - Tmin_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Vapour pressure (Pa):
                  VapP_int ( iJulianCLINO ) = VapP_CLINO ( imonth ) + &
                     ( VapP_CLINO ( imonth + 1 ) - VapP_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Relative humidity, mean (0 to 1):
                  RHmean_int ( iJulianCLINO ) = RHmean_CLINO ( imonth ) + &
                  ( RHmean_CLINO ( imonth + 1 ) - RHmean_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Relative humidity, early morning measurement (0 to 1):
                  RHmax_int ( iJulianCLINO ) = RHmax_CLINO ( imonth ) + &
                  ( RHmax_CLINO ( imonth + 1 ) - RHmax_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Relative humidity, afternoon measurement (0 to 1):
                  RHmin_int ( iJulianCLINO ) = RHmin_CLINO ( imonth ) + &
                  ( RHmin_CLINO ( imonth + 1 ) - RHmin_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Bright sunshine hours (hours day-1):
                  bshrs_int ( iJulianCLINO ) = bshrs_CLINO ( imonth ) + &
                  ( bshrs_CLINO ( imonth + 1 ) - bshrs_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Mean wind speed (m s-1):
                  wind_int ( iJulianCLINO ) = wind_CLINO ( imonth ) + &
                     ( wind_CLINO ( imonth + 1 ) - wind_CLINO ( imonth ) ) &
                                                 * m_interp2
               !Rainfall (m day-1):
                  rain_int ( iJulianCLINO ) = pptn_CLINO ( imonth ) + &
                     ( pptn_CLINO ( imonth + 1 ) - pptn_CLINO ( imonth ) ) &
                                                 * m_interp2
         
            !First half of every month from February to December:
            ELSE & 
            IF (  ( imonth .GE. i2 ) .AND. &
                   J1st_day_mon ( imonth ) .LE. iJulianCLINO .AND. &
                          ( iJulianCLINO  .LT.  Jmpm ( imonth )  ) &
               ) THEN 
               m_interp3 = ( Jmpm ( imonth ) - iJulianCLINO ) / & 
                           ( Jmpm ( imonth ) - Jmpm ( imonth - 1 ) )
   
               !Atmospheric pressure (Pa):
                  AtmP_int ( iJulianCLINO ) = AtmP_CLINO ( imonth ) - &
                     ( AtmP_CLINO ( imonth ) - AtmP_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Mean air temperature (deg C):
                  Tmean_int ( iJulianCLINO ) = Tmean_CLINO ( imonth ) - &
                  ( Tmean_CLINO ( imonth ) - Tmean_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Air temperature, maximum (deg C):
                  Tmax_int ( iJulianCLINO ) = Tmax_CLINO ( imonth ) - &
                     ( Tmax_CLINO ( imonth ) - Tmax_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Air temperature, minimum (deg C):
                  Tmin_int ( iJulianCLINO ) = Tmin_CLINO ( imonth ) - &
                     ( Tmin_CLINO ( imonth ) - Tmin_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Vapour pressure (Pa):
                  VapP_int ( iJulianCLINO ) = VapP_CLINO ( imonth ) - &
                     ( VapP_CLINO ( imonth ) - VapP_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Relative humidity, mean (0 to 1):
                  RHmean_int ( iJulianCLINO ) = RHmean_CLINO ( imonth ) - &
                  ( RHmean_CLINO ( imonth ) - RHmean_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Relative humidity, early morning measurement (0 to 1):
                  RHmax_int ( iJulianCLINO ) = RHmax_CLINO ( imonth ) - &
                  ( RHmax_CLINO ( imonth ) - RHmax_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Relative humidity, afternoon measurement (0 to 1):
                  RHmin_int ( iJulianCLINO ) = RHmin_CLINO ( imonth ) - &
                  ( RHmin_CLINO ( imonth ) - RHmin_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Bright sunshine hours (hours day-1):
                  bshrs_int ( iJulianCLINO ) = bshrs_CLINO ( imonth ) - &
                  ( bshrs_CLINO ( imonth ) - bshrs_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Mean wind speed (m s-1):
                  wind_int ( iJulianCLINO ) = wind_CLINO ( imonth ) - &
                     ( wind_CLINO ( imonth ) - wind_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
               !Rainfall (m day-1):
                  rain_int ( iJulianCLINO ) = pptn_CLINO ( imonth ) - &
                     ( pptn_CLINO ( imonth ) - pptn_CLINO ( imonth - 1 ) ) &
                                                 * m_interp3
   
            !Last half of December:    
            ELSE IF ( Jmpm ( 12 ) .LE. iJulianCLINO ) THEN 
               m_interp4 = ( iJulianCLINO - Jmpm ( 12 ) ) / & 
                           ( Jmpm ( 1 ) + c365 - Jmpm ( 12 ) )
   
               !Atmospheric pressure (Pa):
                  AtmP_int ( iJulianCLINO ) = AtmP_CLINO ( 12 ) + &
                     ( AtmP_CLINO ( 1 ) - AtmP_CLINO ( 12 ) ) * m_interp4
               !Mean air temperature (deg C):
                  Tmean_int ( iJulianCLINO ) = Tmean_CLINO ( 12 ) + &
                     ( Tmean_CLINO ( 1 ) - Tmean_CLINO ( 12 ) ) * m_interp4
               !Air temperature, maximum (deg C):
                  Tmax_int ( iJulianCLINO ) = Tmax_CLINO ( 12 ) + &
                     ( Tmax_CLINO ( 1 ) - Tmax_CLINO ( 12 ) ) * m_interp4
               !Air temperature, minimum (deg C):
                  Tmin_int ( iJulianCLINO ) = Tmin_CLINO ( 12 ) + &
                     ( Tmin_CLINO ( 1 ) - Tmin_CLINO ( 12 ) ) * m_interp4
               !Vapour pressure (Pa):
                  VapP_int ( iJulianCLINO ) = VapP_CLINO ( 12 ) + &
                     ( VapP_CLINO ( 1 ) - VapP_CLINO ( 12 ) ) * m_interp4
               !Relative humidity, mean (0 to 1):
                  RHmean_int ( iJulianCLINO ) = RHmean_CLINO ( 12 ) + &
                     ( RHmean_CLINO ( 1 ) - RHmean_CLINO ( 12 ) ) * m_interp4
               !Relative humidity, early morning measurement (0 to 1):
                  RHmax_int ( iJulianCLINO ) = RHmax_CLINO ( 12 ) + &
                     ( RHmax_CLINO ( 1 ) - RHmax_CLINO ( 12 ) ) * m_interp4
               !Relative humidity, afternoon measurement (0 to 1):
                  RHmin_int ( iJulianCLINO ) = RHmin_CLINO ( 12 ) + &
                     ( RHmin_CLINO ( 1 ) - RHmin_CLINO ( 12 ) ) * m_interp4
               !Bright sunshine hours (hours day-1):
                  bshrs_int ( iJulianCLINO ) = bshrs_CLINO ( 12 ) + &
                     ( bshrs_CLINO ( 1 ) - bshrs_CLINO ( 12 ) ) * m_interp4
               !Mean wind speed (m s-1):
                  wind_int ( iJulianCLINO ) = wind_CLINO ( 12 ) + &
                     ( wind_CLINO ( 1 ) - wind_CLINO ( 12 ) ) * m_interp4
               !Rainfall (m day-1):
                  rain_int ( iJulianCLINO ) = pptn_CLINO ( 12 ) + &
                     ( pptn_CLINO ( 1 ) - pptn_CLINO ( 12 ) ) * m_interp4
   
            ENDIF
            int_CLINO_end..CONTINUE
                     !End of DO int_CLINO_end interpolation loop.
         ENDIF !IF ( s_CLINO_dat .EQ. one ) THEN

      !End of CLINO monthly data input and interpolation from 12-month mean
      !monthly data file.
   
   
      !Monthly environmental data over many years from a weather generator
         !Initial block for reading in header from monthly data files
         !extending over many years. eg monthsnn.dat.
         Constant s_monthsnn_dat = 0  !Default value. Do not read in
            !monthly data extending over years from weather generated file.
             one_s_monthsnn_dat = one - s_monthsnn_dat !Working variable.
   
         !Read header from monthly data file (default = monthsnn.dat):
            IF ( s_monthsnn_dat .EQ. one .AND. irotate .GT. ilarge ) THEN
               OPEN (UNIT = 51, FILE = filenamemnn); REWIND 51
               CHARACTER filenamemnn * 20
               Constant filenamemnn = 'monthsnn.dat'
                        !Default filename for monthly data.
               !At runtime, filenamemnn may be reset to eg Hampshir.mon
               !or whatever with: <set filenamemnn = 'Hampshir.mon'>
               CHARACTER linedumpmnn * 120 !Dump for a line of characters.
               READ (51, *) linedumpmnn         !Read and dump a title line.
               READ (51, *) latitude_deg_mnn    !Read in latitude.
               READ (51, *) fbshrsmean_mnn, fbshrsvar_mnn
                  !Read in location-specific constants mean and amplitude
                  !(sinusoidal) of fraction of possible bright
                  !sunshine hours. This is needed because photosynthesis
                  !from sun and shade leaves is computed separately.
                  !Eskdalemuir: fbshrsmean = 0.26 fbshrsvar = 0.10
                  !Ie, in winter, the sun shines from 0.26 - 0.1 = 0.16 of the
                  !daylight hours.  In summer, for 0.36 of the daylight hours.
               READ (51, *) linedumpmnn  !Read and dump another line.
               READ (51, *) linedumpmnn  !Read and dump another line.
               READ (51, *) INenv_Namm_hayr_mnn  !kg N ha-1 year-1.
                           !N deposition into Namm soil pool.
                  INenv_Namm_mnn = INenv_Namm_hayr_mnn / c3650000
                                                          !kg N m-2 day-1.
               READ (51, *) linedumpmnn  !Read and dump another line.
               READ (51, *) fclay_mnn       !Clay fraction, for fclay.
               READ (51, *) linedumpmnn  !Read and dump another title line.
               READ (51, *) linedumpmnn  !Read and dump another title line.
               imonth_mon2 = 555555333 !We need to re-initialize this, so
                     !that we know that we are in the first half of January.
                     !It may be zero otherwise if end of file was reached
                     !in an earlier run.
            ENDIF ! ( s_monthsnn_dat .EQ. one .AND. irotate .GT. ilarge ) THEN
         !End: Many-year monthly data initial section.
   
   
      !Climate data (cd)
         !These are read in from file climate.dat if switch s_cd = 1.
         !Currently file climate.dat only contains data on temperature,
         !CO2, and N deposition.
         Constant s_cd = 0  !Default value. Switch for reading and
         !activating the climate.dat file. <Set s_cd = 1> to switch on.
                  one_s_cd = one - s_cd  !Working variable.
         
         !Declare integers and vector arrays for the climate data:
         INTEGER nyrsofcd    !Number of years of climate data (e.g. 25).
         INTEGER iyearcd_A   !For the integer year numbers (e.g. 1860, 1919)
         ARRAY iyearcd_A(30) !Array.
            DO iyearcd_Aloop iz = 1, 30
               iyearcd_A(iz) = 0                     !Initialize to zero.
            iyearcd_Aloop..CONTINUE

         ARRAY delTcd_A(30), CO2cd_A(30), Ndepcd_A(30)
            !delT Temperature (deg C) relative to 1961-1990 mean).
            !CO2  CO2 concentration (vpm).
            !Ndep N deposition into Namm soil mineral pool (kg N ha-1 year-1).
      
               iyearcd_A1 = 0 !This must have a value, even if no climate
                              !data is read in.
      
         CHARACTER filenamecd * 20
         Constant filenamecd = 'climate.dat' 
                 !Default filename for climate data file.
      
         IF ( s_cd .EQ. one ) THEN
               OPEN (UNIT = 50, FILE = filenamecd); REWIND 50
               CHARACTER linedumpcd * 120 !Dump for a line of characters.
               READ (50, *) linedumpcd !Read and dump a title line.
               READ (50, *) nyrsofcd  !Read in number of years of climate data.
               READ (50, *) linedumpcd !Read and dump another title line.
               INTEGER icd, iyearcd_A1
               DO cd_loop icd = 1, nyrsofcd
                  READ (50, *) iyearcd_A(icd), delTcd_A(icd), &
                               CO2cd_A(icd), Ndepcd_A(icd)
               cd_loop..CONTINUE
               CLOSE ( UNIT = 50 )
               iyearcd_A1 = iyearcd_A(1)  !Preserve this value, as
                  !iyearcd_A(1) is incremented in the Terminal block.
               year_index_max = iyearcd_A(nyrsofcd) - iyearcd_A1 + 1  
                  !year_index is used to address the interpolated array. 
                  !Sometimes, it is wished to continue the simulation after the
                  !last year of inputted climate data, ie, after
                  !iyearcd_A(nyrsofcd),
                  !using the last year of inputted climate data to define a
                  !constant climate for further years.
                  !So that the defined arrays are not exceeded, year_index
                  !is not allowed to exceed year_index_max.
      
            !Generate yearly data from the climate data values.
               !Interpolate linearly between values provided to obtain values
                  !for each year.
               !Number of years spanned by climate data:
                  INTEGER nyrscd
                          nyrscd = iyearcd_A(nyrsofcd) - iyearcd_A(1) + 1
                  !e.g. 2100 - 1850 + 1 = 251 years between 1850 and 2100
                  !inclusive.
               !Arrays for the interpolated annual values are:
                  ARRAY delTcd_int(300), CO2cd_int(300), &
                        Ndepcdhayr_int(300), Ndepcd_int(300)
      
               !DO loop begins:
                  icd = 1  !Address 1st year of climate data.
                  DO int_loop icd_int = 1, nyrscd
                     !Actual year addressed is:
                        INTEGER iyear_act
                        iyear_act = iyearcd_A(1) + icd_int - i1
                                   !e.g. 1850 onwards.
                     IF ( iyear_act .EQ. iyearcd_A(icd + i1) ) THEN
                        icd = icd + 1  !Move to the next data interval.
                     ENDIF
                         delyearz1 = iyear_act - iyearcd_A(icd) 
                           !Difference between present
                           !year and the lst year for which there are data.
                         delyearz2 = iyearcd_A(icd+1) - iyearcd_A(icd)
                            !Difference between last year for which there are
                            !data, and the next year for which there are data.
                         IF ( delyearz2 .NE. zero ) THEN
                            m_cd = delyearz1 / delyearz2 !multiplier.
                         ELSE
                            m_cd = zero
                         ENDIF
                            delTcd_int(icd_int) = delTcd_A(icd) + &
                               (delTcd_A(icd+1) - delTcd_A(icd)) * m_cd
                            CO2cd_int(icd_int) = CO2cd_A(icd) + &
                               (CO2cd_A(icd+1) - CO2cd_A(icd)) * m_cd
                            Ndepcdhayr_int(icd_int) = Ndepcd_A(icd) + &
                               (Ndepcd_A(icd+1) - Ndepcd_A(icd)) * m_cd
                         !Convert units (kg N ha-1 year-1 to kg N m-2 day-1):
                            Ndepcd_int(icd_int) = &  !kg N m-2 day-1.
                            Ndepcdhayr_int(icd_int) / c3650000
                  int_loop..CONTINUE
         ENDIF  !of IF ( s_cd .EQ. one ) block.
      !End of Climate data (cd) section.
   

   !ENVIRONMENTAL PARAMETERS
      !Acceleration due to gravity
         Constant gravity = 9.81 !m2 s-1.

      !Pair
         Constant Pair = 101325.0 !Pa. Default value of Pair is
                                  !standard atmospheric pressure.
   
      !Ammonia concentration in atmosphere
         !at reference height href = 50 m (default value of href).
         Constant Namm_atm_vpb = 2.0 !volumes per billion volumes, or
                                     !picomols per mol.
                !At STP, 1 vpb NH3 = 10-9 * 17 * 1000 / 22.4136
                != 0.76 micrograms NH3 m-3. ok, 20/11/20.
                !Namm_atm_STP2vpb_kgNammNm_3 (kg ammonium N m-3) is
                 Namm_atm_STP2vpb_kgNammNm_3 = (Namm_atm_vpb / 1.0E9) &
                                     * rmmN / 22.4136
        ! rmmN = 14.007  Check this is ok. OK 23/11/2020.        

   
      !Carbon dioxide (CO2) and climate change (cc)
         Constant s_CO2cc = 0   !CO2 climate change (cc) switch.
                                !if s_CO2cc = 1, then CO2 increases linearly
                                !by CO2inc_yr per year.
         Constant CO2vpmc = 350 !vpm (micromol mol-1). 
                  !CALL LOGD(.TRUE.) 
         IF ( CO2vpmcz .GT. clarge .OR. s_CO2cc .EQ. zero ) &
              CO2vpmcz = CO2vpmc
                  !CALL LOGD(.TRUE.) 
                                !Constant CO2 concentration 
                                                       !in micromols mol-1.
                                !CO2vpmcz is set to CO2vpmc 
                                !on first start of the session, or,
                                !when s_CO2cc = 0.
                                !If s_CO2cc = 1, climate change is switched
                                !on, and CO2vpmcz is updated in the 
                                !Terminal section.  Search "CO2vpmcz =".
         Constant CO2inc_yr = 3 !vpm.  Annual increase of atmospheric CO2 if
                                !s_CO2cc = 1.
         Constant yrsCO2offset = 0 !year.  For offsetting the year when CO2
                                !increase begins.
   
      !Daylength and latitude
         Constant latitude_degc = 55.27 !degrees.
            !This default value is for 
            !Eskdalemuir, southern Scotland.
               !Latitude_degc = 55.27 degrees. 55 deg 19 min N. 242 m.
               !Daylength, midsummer, 17.2 hours.
            !Hurley, Southern Britain.
               !Latitude_degc = 51.54 degrees. 51 deg 32.5 min N. c. 50 m.
               !Daylength, midsummer, 16.4 hours.
            !Note that the southern Britain (Hurley) environment can be
               !applied by typing <hurley> to address the procedure hurley
               !in the forest.cmd file which is read by default when forest
               !is run.  <eskdal> sets the environment back to southern 
               !Scotland (Eskdalemuir).
         !Latitude in radians is calculated in Initial Section.
         !Daylength is calculated from latitude and time of year each day.

         !Set latitude either to its default value latitude_degc, or to
         !the value read in from monthly, daily, or diurnal data files:
            latitude_deg1 = one_s_months12_dat * one_s_CLINO_dat &
                            * one_s_daily_dat &
                            * one_s_diurnal_dat * one_s_monthsnn_dat &
                                                * latitude_degc &
                            + s_months12_dat * latitude_deg_m12    &
                            + s_CLINO_dat * latitude_deg_CLINO  &
                            + s_monthsnn_dat * latitude_deg_mnn &
                            + s_daily_dat * latitude_deg_dy    &
                            + s_diurnal_dat * latitude_deg_di 
                                                       !latitude in degrees.
            IF ( latitude_deg1 .EQ. c90 ) THEN    !This is to prevent failure
                 latitude_deg = 89.999            !from 1 / cos(latitude)
            ELSE IF ( latitude_deg1 .EQ. (- c90) ) THEN
                 latitude_deg = - 89.999
            ELSE
                 latitude_deg = latitude_deg1  !Latitude in degrees.
            ENDIF
                 latit_deg = latitude_deg !For output only.

            latitude = latitude_deg * twopi / 360             !radians.
            sin_latitude = SIN( latitude )
            cos_latitude = COS( latitude )
            tan_latitude = TAN( latitude )
            sincos_latitude = sin_latitude * cos_latitude


      !Fertilizer applications - initial
         !These calculations are placed here for efficiency.  We have moved
         !them down to where tfert1-4 are assigned values.
!         tfert1plus1 = tfert1 + one  ;  tfert2plus1 = tfert2 + one
!         tfert3plus1 = tfert3 + one  ;  tfert4plus1 = tfert4 + one
!         yfert1 = tfert1 / c365      ;  yfert2 = tfert2 / c365
!         yfert3 = tfert3 / c365      ;  yfert4 = tfert4 / c365
!         INTEGER iyfert1             ;  iyfert1 = tfert1 / c365 !yyy

      !Nitrogen deposition from atmosphere
         !Ammonia N into soil ammonia pool:
         Constant INenv_Namm_hayrc = 10 !kg N ha-1 year-1. Eskdalemuir value.
                  INenv_Nammc = INenv_Namm_hayrc / c3650000
                                               ! = 2.74e-6 !kg N m-2 day-1.
         !Constant INenv_Namm_hayrc = 50  !50 kg N ha-1 year-1. Hurley.
   
         !Nitrate N into soil nitrate pool:
         Constant INenv_Nnit_hayrc = 0  !kg N ha-1 year-1. Eskdalemuir value.
                  INenv_Nnitc = INenv_Nnit_hayrc / c3650000
                                               ! = 0 !kg N m-2 day-1.

         !Table of values for N inputs:
            !kg N m-2 day-1  kg N ha-1 year-1
            !1.37e-6          5
            !2.74e-6         10
            !4.11e-6         15
            !5.48e-6         20
            !13.7e-6 =       50 / (10000 * 365)
            !27.4e-6        100
         
      !Radiation
         !Angstrom equation parameters (used if sunshine hours are input):
            Constant a_Angstromc = 0.19  !Dimensionless. Eskdalemuir.
            Constant b_Angstromc = 0.62  !Dimensionless. Eskdalemuir.
           !Constant a_Angstromc = 0.24  !Dimensionless. Southern England.
           !Constant b_Angstromc = 0.54  !Dimensionless. Southern England.
            !Jones HG. 1992 (2nd edition). Plants and Microclimate. Cambridge.
               !p. 21.
            !JA Martinez-Lozano et al. 1984. Agricultural & Forest Meterology
            !33, 109-124.  Table II, III, IV.  There is a range of estimates
            !of a and b, even for a given location.  These may need to be
            !changed when
            !reading in monthly data for different locations:
               a_Angstrom = a_Angstromc * one_s_months12_dat &
                                        * one_s_CLINO_dat + &
                            a_Angstrom_m12 * s_months12_dat + &
                            a_Angstrom_CLINO * s_CLINO_dat
               b_Angstrom = b_Angstromc * one_s_months12_dat &
                                        * one_s_CLINO_dat + &
                            b_Angstrom_m12 * s_months12_dat + &
                            b_Angstrom_CLINO * s_CLINO_dat
         !Other radiation parameters:
            Constant solar_constant = 1370  !W m-2. 
               !The solar constant is the total radiant flux density normal to
               !the solar beam incident on the top of the atmosphere.
         Constant fAngstrom_PAR = 0.28
            !Factor converts J of radiation given by Angstrom formula to PAR, 
            !adjusted to give about the right answer at Kew for 20 June of
            !jPARdy = 9.0e6 J PAR m-2 day-1.
         !Constant jPARdymn = 4.8e6, jPARdyvar = 4.1e6   !J m-2 day-1. Hurley.
            !Mean and amplitude (sinusoidal) of daily PAR, as at Hurley.
         Constant jPARdymn = 3.8e6, jPARdyvar = 3.3e6 !J m-2 day-1.          
                                                      !Eskdalemuir.
         Constant tjPAR = 81  !days.  Phase of the radiation sinusoid.
            !Radiation is maximum on 21 June.
            !365/4 = 91.  81 + 91 = 172.  iJulian( 21June ) = 172.

         !Fraction of bright sunshine hours, fbshrs.
         !Constant fbshrsmean_sin = 0.30, fbshrsvar_sin = 0.14 !Hurley.
            !Mean and amplitude (sinusoidal) of fraction of possible bright
            !sunshine hours, as at Hurley (Kew).
            Constant fbshrsmean_sin = 0.26, fbshrsvar_sin = 0.10  !Eskdalemuir.
         Constant tfbshrs = 81  !days.  Phase of the sinusoid.
            !Maximum on 21 June.
         !Bright sunshine hours, mean and seasonal variance:
            fbshrsmean = s_monthsnn_dat * fbshrsmean_mnn &
                + one_s_monthsnn_dat * fbshrsmean_sin
            fbshrsvar = s_monthsnn_dat * fbshrsvar_mnn &
                + one_s_monthsnn_dat * fbshrsvar_sin
  
      !Rain
         !Hurley:
            !Constant rainmn = 0.00180822 !m day-1. Mean rainfall over year.
               !At Hurley, annual rainfall = 0.660 m year-1 = 660 / 365 = 
               !1.81 mm day-1.
            !Constant rainvr = 0.00060174 !m day-1. Annual variation in
                                          !rainfall.
            !Constant train = 233 !days. Phase of rain sinusoid.
               !Rainfall is maximum on 20 November.
         !Eskdalemuir (Southern Scotland): 
            Constant rainmn = 0.00418356, rainvr = 0.00139, train = 244
                !Annual rainfall is 1.53 m year-1.
                !Rainfall is maximum on 1 December.??

      !Reference height for wind speed and other measurements:
         Constant href = 50 !m. If this is too low, ie below tree height, then
                            !the program fails in the boundary layer 
                            !conductance calculation. 
                            !Search <gBoundaryLayer =>.  
   
      !Relative humidity (RH, RHmax.. for dawn, RHmin.. for 1500 h):
         !Constant RHmaxmn = 0.8, RHmaxvr = 0.1        !Kew, roughly.
         Constant RHmaxmn = 0.84, RHmaxvr = 0.07   !Eskdalemuir, roughly.
            !RHmaxmn: mean over the year of the dawn RH measurement.
            !RHmaxvr: seasonal amplitude of the dawn RH measurement.
         !Constant RHminmn = 0.7, RHminvr = 0.1        !Kew, roughly.
         Constant RHminmn = 0.75, RHminvr = 0.13   !Eskdalemuir, roughly.
            !RHminmn: mean over the year of the 1500 h RH measurement.
            !RHminvr: seasonal amplitude of the 1500 h RH measurement.
         !Constant tRH = 273 !day.  Phase of the seasonal RH wave. Kew.
            !Maximum of daily mean value (RHmax + RHmin)/2 = RHdymn
            !occurs 30 Dec.
         Constant tRH = 240 !day.  Maximum on 28 November. !Eskdalemuir.
            !It is assumed that dawn and 1500 h RH values have the
            !same seasonal phase.  
   
      !Temperature
      !Air temperatures:
         Constant Tairmaxmn = 11,  Tairmaxvr = 7   !o C. Eskdalemuir.
         Constant Tairminmn = 4,   Tairminvr = 5   !o C. Eskdalemuir.
                 !Tairmaxmn = 14,  Tairmaxvr = 7   !o C. Hurley.
                 !Tairminmn = 6.5, Tairminvr = 5.5 !o C. Hurley.
         IF ( Tairmaxmnz .GT. clarge ) THEN
              !.OR. Tairmaxmnz .NE. Tairmaxmn &
              !.OR. Tairminmnz .NE. Tairminmn ) THEN !Occurs only on 1st start,
               !of if we have reset Tairmaxmn or Tairminmn. See proced ce 
               !in efm.cmd.
              Tairmaxmnz = Tairmaxmn; Tairminmnz = Tairminmn
         ENDIF
            !Tairmaxmnz: mean over year of daily maximum air temperature.
            !Tairmaxvr: seasonal amplitude of daily maximum air temperature.
            !Tairminmnz: mean over year of daily minimum air temperature.
            !Tairminvr: seasonal amplitude of daily minimum air temperature.
         Constant tTair = 115 !days.  Phase of the seasonal air temperature
            !wave.  It is assumed that daily maxima and minima have the
            !same seasonal phase.  Maximum is on 25 July.
   
      !Soil temperatures (10 cm) (no diurnal variation):
         Constant Tsoilmn = 8.5, Tsoilvr = 6  !Eskdalemuir.
                 !Tsoilmn = 10,  Tsoilvr = 6  !o C. Hurley.
         IF ( Tsoilmnz .GT. clarge ) THEN
              Tsoilmnz = Tsoilmn
         ENDIF
            !Tsoilmnz, mean over the year of the mean daily soil temperature.
            !Tsoilvr, amplitude of the mean daily soil temperature.
         Constant tTsoil = 116 !days.  Phase of the seasonal air temperature.
            !wave.  Maximum is on 26 July.
         !The Hurley soil values are close to the 10 cm depth values at
         !Hurley, Maidenhead, UK.   
   
      !Temperature and climate change:
         !Temperatures may all increase slowly due to climate change (cc).
         Constant s_Tcc = 0   !Temperature climate change switch.
            !s_Tcc = 0, annual temperatures are constant.
            !s_Tcc = 1, temperatures increase linearly at an annual rate of
               !Tinc_yr.
            Constant Tinc_yr = 0.03 !oC year-1. Annual increase of temperature
                                                !if s_Tcc = 1.
            Constant yrsToffset = 0 !year. For offsetting the year when 
                                    !the temperature increase begins.
   
      !Wind speed (Eskdalemuir):
         Constant windmaxmn = 6, windmaxvr = 1.5 !m s-1.
            !windmaxmn: mean over year of daily maximum wind speed.
            !windmaxvr: seasonal amplitude of daily maximum wind speed.
         Constant windminmn = 2, windminvr = 0.5  !m s-1.
            !windminmn: mean over year of daily minimum wind speed.
            !windminvr: seasonal amplitude of daily minimum wind speed.
         Constant twind =  25 !days.  Phase of the seasonal wind speed
             !wave.  It is assumed that daily maxima and minima have the
             !same seasonal phase.  Maximum is on 26 April.
         !Hurley:
            !Constant windmaxmn = 1.5, windmaxvr = 1    !m s-1.
            !Constant windminmn = 0.5, windminvr = 0.4  !m s-1.
            !twind assumed unchanged.
   
   !End of ENVIRONMENTAL PARAMETERS block.



   !HEADERS for output files
      !Daily environmental data (ded) output (header)
      !ded are output to file dailyout.dat
      !in a form suitable for re-input if required (eg, as in daily.dat).
      !This block is placed here because latitude_deg may be assigned a
      !value in the Monthly Data Input section just above.
      !This can large data files in long runs, therefore it is turned
      !off in default.
      Constant s_dy_dat_out = 0
      IF ( s_dy_dat_out .EQ. one .OR. s_daily_dat .EQ. one ) THEN
         !If we want daily data output, and also if we are reading daily data
         !in from the file daily.dat with s_daily_dat = one.
         OPEN (unit = 60, file = 'dailyout.dat');  REWIND 60
         CHARACTER quote * 1
         Constant quote = ''''
         WRITE ( 60, * ) quote, Title_daily_dat_file, quote
            !Write title of daily data file in quotes.
            !If daily data is not read in, this is simply blank.
         WRITE ( 60, 600 ) latitude_deg
         600..FORMAT ( 1x, F6.2, '  = latitude in decimal degrees.', &
            /1x, 1h', 'Radiation (PAR): MJ PAR m-2 day-1. ', &
            'Temperatures: degrees Celsius.  Rain: mm day-1.', 1h', &
            /1x, 1h', 'wind, daily mean: m s-1. ', &
            'RH = relative humidity: RHmax, RHmin, about dawn, 15 h.', 1h', &
            /1x, 1h', 'Atmospheric N deposition: mg N m-2 day-1, ', &
            'into soil ammonium and nitrate pools.', 1h', &
            /1x, 1h', 'Actual variables output: idaymo, imonth, iJulian, ', &
            'iyear_dy, jPARdye_6, Tairmax, Tairmin, Tsoildyc, ' &
            /1x, 1h',  'rainmm, winddymn, RHmax, RHmin, ' &
             'INenv_Namm_mg, INenv_Nnit_mg.', 1h', &
            /1x, 1h', 'day month JulianDay year  PAR ', &
            'Tairmax Tairmin Tsoildyc rainmm winddymn RHmax RHmin NdepNamm' &
            ' NdepNnit', 1h')
      ENDIF  !This is a heading for the file dailyout.dat.


      !Diurnal environmental data output (header)
         !If diurnal environmental data are required to be output, then
         !type <set s_di_dat_out = 1.0> at runtime.  Diurnal data are output
         !to the file diurnout.dat.
         Constant s_di_dat_out = 0.0  !Default value, no diurnal data output.
         !This block is placed here because latitude_deg may be assigned a
         !value in the Monthly Data Input section just above.
         IF ( s_di_dat_out .EQ. one ) THEN
            OPEN (unit = 61, file = 'diurnout.dat');  REWIND 61
   !        CHARACTER quote * 1     !Declared above.
   !        Constant quote = ''''   !ditto.
            WRITE ( 61, * ) quote, Title_di_data_file, quote
               !Write title of diurnal data file in quotes.
            WRITE ( 61, 610 ) latitude_deg
   !        The next format statement is for minute hour day month etc.
   !        610..FORMAT ( 1x, 1h', 'Data must begin 1 Jan 0 h.', 1h', &
   !           /1x, F6.2, '  = latitude in decimal degrees.', &
   !           /1x, 1h', 'Radiation (PAR): J PAR m-2 s-1. ', &
   !           'Temperatures: degrees Celsius.', 1h', &
   !           /1x, 1h', 'Rain: mm h-1. ', &
   !           'Wind: m s-1.', 1h', &
   !           '  RH = relative humidity (fraction).' 1h', &
   !           /1x, 1h', '   ', 1h', &
   !           /1x, 1h', 'minute hour day month JulianDay year   PAR ', &
   !           'Tair  Tsoil  rain wind    RH', 1h')
   !        The next format statement is for hour day month etc.
            610..FORMAT ( 1x, 1h', 'Data must begin 1 Jan 0 h.', 1h', &
               /1x, F6.2, '  = latitude in decimal degrees.', &
               /1x, 1h', 'Radiation (PAR): J PAR m-2 s-1. ', &
               'Temperatures: degrees Celsius.', 1h', &
               /1x, 1h', 'Rain: mm h-1. ', &
               'Wind: m s-1.', 1h', &
               '  RH = relative humidity (fraction).' 1h', &
               /1x, 1h', '   ', 1h', &
               /1x, 1h',        'hour day month JulianDay year   PAR ', &
               'Tair  Tsoil  rain wind    RH', 1h')
            !This is a heading for the file diurnout.dat.
   
         ENDIF !end if IF ( s_di_dat_out .EQ. one ) THEN block.
      

      !Debug daily data (header)
         !If debug daily data are required to be output, then
         !type <set debug_dy = 1.0> at runtime.  Daily data are output
         !to the file debugdy.dat.
         Constant debug_dy = 0.0
         !Default value, no debug daily data output.
         IF ( debug_dy .EQ. one ) THEN
            OPEN (unit = 62, file = 'debug_dy.dat');  REWIND 62
            WRITE ( 62, 620 )
            620..FORMAT ( 1x, 'Debug data, daily output', &
               /1x, 11x, 't', 8x, 'year', 6x, 'idaymo', 6x, 'imonth')
            !This is a heading for the file debugdy.dat.
         ENDIF

      !Debug diurnal data (header) 
         !Data is output to 2 files: debugdi1.dat, debugdi2.dat.
            !Open 2 files:
             OPEN (unit = 63, file = 'debugdi1.dat');  REWIND 63
             WRITE ( 63, 623 ) 
             623..FORMAT ( 1x, 'debugdi1.dat: diurnal data debug file', &
                  /1x, 3x, 't', 18x, 'tdi_dump,', 10x, 'hour day month ', &
                  'JulianDay year')

             OPEN (unit = 64, file = 'debugdi2.dat');  REWIND 64
             WRITE ( 64, 630 ) maxt
             630..FORMAT ( 1x, 'debugdi2.dat: debug data', &
             ' output every maxt', &
             /1x, 'maxt = ', f14.8, &
             /1x, 13x, 't', 8x, 'year', 6x, 'idaymo', 6x, 'imonth')
             !This is a heading for the file debugdi2.dat.


   !TREE SUBMODEL - STATE VARIABLES AND INITIAL VALUES
      !If treevr (tree varies) = 0, then all the tree state variables
         !remain constant at their initial values 
         !(This does not include the masses of water in the tree components: 
         ! Wi, i = le (foliage), fi (fine roots).  See WATER SUBMODEL).
         Constant treevr = 1  !Default value of treevr.
      
      !All the tree initial values with dimensions of per stem 
         !(e.g. Al0z, MlC, but not nstems or tree dimensions)
         !are multiplied by sctreeic
         !in the Initial Section and put into e.g. Al0, MlC0, etc.
         !Default is with sctreeic = 1 so the initial values are unchanged.
      
      !Foliage, le (leaf)
         !Leaves can be separately scaled by scleafic.
         !Aleaf1,2,3,4   leaf area (single-sided area, ie just counting the
            !upper side), 4 age categores.
            Constant Aleaf10z = 0.003, Aleaf20z = 0.003, &
                     Aleaf30z = 0.003, Aleaf40z = 0.003 
                                                   !m2 leaf stem-1.
                     
         !MCSle  foliage C substrate.
            Constant MCSle0z = 0.04e-3             !kg C substrate stem-1.
            !This, divided by MXle0, gives an initial C concn of 0.02.
         !MNSle  foliage N substrate
            Constant MNSle0z = 0.02e-3             !kg N substrate stem-1.
            !This, divided by MXle0, gives an initial N concn of 0.01.
         !MNph  photosynthetic N in upper leaves of foliage.
            Constant MNph0z = 0.02e-3         !kg photosynthetic N stem-1. 
            !This, divided by MXle0, gives an initial Nph concn of 0.01.
         !MXle1, 2, 3, 4  foliage structure, 4 age categories.
            Constant MXle10z = 0.0005, MXle20z = 0.0005, MXle30z = 0.0005, &
                     MXle40z = 0.0005               !kg structural DM stem-1.
                    !Therefore MXle at t = 0, = 0.002:
                     MXle0z = MXle10z + MXle20z + MXle30z + MXle40z 
                                                    !kg structural DM stem-1.
                     MNXle0z = fNleX * MXle0z     !kg structural le N stem-1.
   
      !Branches, br
         !MCSbr  branch C substrate.
            Constant MCSbr0z = 1.5e-5           !kg C substrate stem-1.
            !This, divided by MXbrm0, gives an initial C concn of 0.015.
         !MNSbr  branch N substrate.
            Constant MNSbr0z = 1.5e-5           !kg N substrate stem-1.
            !This, divided by MXbrm0, gives an initial N concn of 0.015.
         !MXbr  branch structure.
            Constant MXbr0z = 0.001             !kg structural DM stem-1.
         !MXbrm  branch meristem.
            Constant MXbrm0z = 0.001            !kg structural DM stem-1.    
                     MNXbr0z = fNbrX * MXbr0z !kg structural br N stem-1.

   
      !Buds, bud
         !Mbud  bud mass.
            Mbud0z = c0x1 * MXbrm0z             !kg structural DM stem-1.
                    !equal to 0.1 * MXbrm, branch meristem mass.
         
      !Stems, st
         !dstem, diameter (average) of stems, m.
         !hstem, height of stems, m.
            !Initial values are calculated in the Initial section, assuming
            !a given initial height:diameter ratio, rhdstem0, from MsX.
         !MCSst  stem C substrate.
            Constant MCSst0z = 1.0e-5      !kg C substrate stem-1.
            !This, divided by MXstm0, gives an initial C concn of 0.01.
         !MCstorest  stem C substrate storage.
            Constant MCstorest0z = 1.0e-5      !kg C store stem-1.
         !MXstm  stem meristem.
            Constant MXstm0z = 0.001       !kg XDM stem-1.
         !MNSst  stem N substrate.
            Constant MNSst0z = 2.0e-5      !kg N substrate stem-1.
            !This, divided by MXstm0, gives an initial N concn of 0.02.
         !MXst  stem structure.
            Constant MXst0z = 0.001        !kg XDM stem-1
                     MNXst0z = fNstX * MXst0z !kg structural st N stem-1.

         !nstems, number of stems per unit area.
            Constant nstems0z = 0.25       !stems m-2.
            IF ( nstems0 .GT. clarge ) nstems0 = nstems0z
                        !0.25 # (m2 ground)-1; equivalent to 2500 ha-1,
                        !or a spacing of 2 m between trees on a square grid.
            !The IF statement ensures that nstems0 is initialized only on
            !the first start of a session.
            !nstems is constant at nstems0 if there is no thinning
            !(with s_thin = 0, the default value), and no self-thinning or
            !generation, ie s_selfthin = 0 (default value).
            !If s_selfthin = 1, then self-thinning/generation of new stems
            !can change nstems.
             nstems_eq = csmall ! = 7.7777e-17 !A small number.
             !nstems_eq is not used in any calculations. Only as a dummy
             !which can be reset and output. 
             !See selfthin.cmd "s nstems_eq = "
         
      !Coarse roots, co
         !MCSco  coarse roots C substrate.
            Constant MCSco0z = 0.9e-5      !kg C substrate stem-1.
            !This, divided by MXcom0, gives an initial C concn of 0.009.
         !MNSco  coarse roots N substrate.
            Constant MNSco0z = 2.5e-5      !kg N substrate stem-1.
            !This, divided by MXcom0, gives an initial N concn of 0.025.
         !MXco  coarse roots structure.
            Constant MXco0z = 0.001        !kg structural DM stem-1.
         !MXcom  coarse roots meristem.
            Constant MXcom0z = 0.001       !kg structural DM stem-1.
                     MNXco0z = fNcoX * MXco0z !kg structural co N stem-1.

         
      !Fine roots and mycorrhiza, fi
         !MCSfi  fine roots and mycorrhiza C substrate.
            Constant MCSfi0z = 0.01e-3     !kg C substrate stem-1.
            !This, divided by MXfi0 + MXfim0, gives an initial 
            !substrate C concn of 0.005.
         !MNSfi  fine roots and mycorrhiza N substrate.
            Constant MNSfi0z = 0.06e-3     !kg N substrate stem-1.
            !This, divided by MXfi0 + MXfim0, gives an initial 
            !substrate N concn of 0.03.
         !MXfi1, 2, 3, 4  fine roots and mycorrhiza structure.  
            !4 age categories.
            Constant MXfi10z = 0.00025, MXfi20z = 0.00025, &
                     MXfi30z = 0.00025, MXfi40z = 0.00025 
                                                  !kg structural DM stem-1.
                     MXfi0z = MXfi10z + MXfi20z + MXfi30z + MXfi40z !Total.
                     MNXfi0z = fNfiX * MXfi0z   !kg structural fi N stem-1.

         !MXfim  fine roots and mycorrhiza meristem.
            Constant MXfim0z = 0.001      !kg structural DM stem-1.
         !rort  density of fine root structural dry matter.
            Constant rort0z = 1           !kg structural DM m-3 soil.
      
      !Tree products, pt, pr [kg C, N, W (water) m-2]
         !Decaying (d) products of thinning (pt):
            !Cptd, Nptd, Wptd
               IF ( Cptd0 .GT. clarge ) THEN
                    Cptd0 = 0.0; Nptd0 = 0.0; Wptd0 = 0.0
               ENDIF
                  !We do this because we might be beginning the 2nd rotation
                  !of a clear-felled plantation, in which case the product 
                  !pools are updated in the "terminal" section, and we do
                  !not want to re-initialize them.
   
         !Decaying (d) products of rotations (pr):
            !Cprd, Nprd, Wprd
               IF ( Cprd0 .GT. clarge ) THEN
                    Cprd0 = 0.0; Nprd0 = 0.0; Wprd0 = 0.0
               ENDIF
   

      !Phenology initialization
         Constant s_deciduous = 0  !Conifer default. 
         !For deciduous mode, "set s_deciduous = 1".
         !Date used in the phenology section:
         !INTEGER j21Jun; Constant j21Jun = 172 Declared above.
            !Julian day number of 21 June (midsummer).
   
         tdumpphenol = clarge !7.7777D+17
                        !A large number. This ensures that the phenology
                        !section is executed at t = 0, even when the last
                        !run stopped at t = 0. tdumpphenol is also used
                        !to ensure that the phenology section is only
                        !executed once at each time point.
   
         Constant budburst0 = 0; budburst = budburst0
         dormant = 0 !These settings do not affect Sitka, only beech.
         days_dormancy = 0 !Accumulator for the days of dormancy.
         Constant s_leaf0 = 1
               !Default value of s_leaf is for Sitka. Leaves are present.
         Constant scleafic0 = 1 !Scales leaf initial values.
            IF ( s_deciduous .EQ. one ) THEN !deciduous trees:
                 s_leaf = zero       !No leaves present.
                 scleafic = zero     !Make leaf initial values zero.
                 budsopening = zero  !Buds are not opening.
            ELSE !evergreens (Sitka):            
                 s_leaf = s_leaf0; scleafic = scleafic0
                     !Leaves are initially present.
                     !Their initial values may be scaled.
                 budsopening = one   !Buds may open.
            ENDIF

         !Leaf fall. Set leaf fall indicator and all leaf fall fluxes to zero.
                       leaf_fall = zero; one_leaf_fall = one 
                       OAleaf1_lf = zero;  OAleaf2_lf = zero
                       OAleaf3_lf = zero;  OAleaf4_lf = zero
                       OXle1_lf =  zero;   OXle2_lf = zero
                       OXle3_lf =  zero;   OXle4_lf = zero
                       OCSle_lf =  zero;   ONSle_lf = zero
                       ONph_lf =   zero;   OWle_lf = zero
         !Initialize some phenology variables at t = 0, solely so that
         !one is not misled by these items having plausible values from
         !a previous run.  They are assigned values during a run.
            jbudb = ilarge;    idaymobudb = ilarge;    imonthbudb = ilarge;
            month_rbudb = ilarge;
            idaymobudsstopopening = ilarge;    
            imonthbudsstopopening = ilarge;
            month_rbso = clarge;   jdorm1 = ilarge;   idaymodorm1 = ilarge;  
            imonthdorm1 = ilarge;  month_rdorm1 = clarge; 
            jleaf_fall = ilarge;   idaymoleaf_fall = ilarge; 
            imonthleaf_fall = ilarge;   month_rleaf_fall = clarge; 
            jdorm2 = ilarge;  idaymodorm2 = ilarge;  imonthdorm2 = ilarge;  
            month_rdorm2 = clarge; days_dormant = clarge; 
            dormantya = clarge;   budburstya = clarge;   
            budsopeningya = clarge; 
            s_leafya = clarge;    leaf_fallya = clarge;  
            tbudb = clarge;  tdorm1 = clarge;  tdorm2 = clarge;  
            tleaf_fall = clarge;  tbudsstopopening = clarge;

      
   !SOIL AND LITTER SUBMODEL - STATE VARIABLES AND INITIAL VALUES
      !Cbio          kg DM m-2. Soil microbial biomass dry matter.
      !Char          kg C m-2.  Charcoal pool in litter and soil.
                               !Forest fires produces charcoal.
      !Csol          kg C m-2.  C pool in carbohydrate (soluble C) pool.
      !Csoil_li_met  kg C m-2.  C in soil litter, metabolic.
      !Csoil_li_cel  kg C m-2.  C in soil litter, cellulose.
      !Csoil_li_lig  kg C m-2.  C in soil litter, lignin.
      !Csurf_li_met  kg C m-2.  C in surface litter, metabolic.
      !Csurf_li_cel  kg C m-2.  C in surface litter, cellulose.
      !Csurf_li_lig  kg C m-2.  C in surface litter, lignin.
      !CpSOM         kg C m-2.  C in protected soil organic matter.
      !CsSOM         kg C m-2.  C in stabilized soil organic matter.
      !CuSOM         kg C m-2.  C in unprotected soil organic matter.
      !Namm          kg N m-2.  Ammonium N in soil.
      !Nnit          kg N m-2.  Nitrate N in soil.
      !Nsoil_li_met  kg N m-2.  N in soil litter, metabolic.
      !Nsurf_li_met  kg N m-2.  N in surface litter, metabolic.
         !The cel and lig soil and surface litter pools have fixed C/N
         !ratios, and so the N contents of these pools are not state variables.
      !NpSOM         kg N m-2.  N in protected soil organic matter.
      !NsSOM         kg N m-2.  N in stabilized soil organic matter.
      !NuSOM         kg N m-2.  N in unprotected soil organic matter.
      
      !Initial values of the soil and litter submodel state variables
         IF ( Char0 .GT. clarge ) THEN !Char is charcoal pool.
           !Initialization takes place on the first start of a session.
            Char0 = 0.0    !kg C m-2.
            Csol0 = 0.0005 !kg C m-2.  Assuming 0.1 m3 water
                 !(m2 ground)-1  (i.e. a 10 cm depth of water), then this
                 !is equivalent to a solution concentration of
                 !0.0005 / 0.1 = 0.005 kg C m-3 water = 0.005 g litre-1
            Csoil_li_met0 = 0.0025 
            Csoil_li_cel0 = 0.1
            Csoil_li_lig0 = 0.15
            Csurf_li_met0 = 0.0025
            Csurf_li_cel0 = 0.1
            Csurf_li_lig0 = 0.15
            CuSOM0 = 0.4
            CpSOM0 = 4
            CsSOM0 = 6
            Cbio0 = 0.2
            Namm0 = 0.0007
            Nnit0 = 0.0003
            Nsoil_li_met0 = 0.0005
            Nsurf_li_met0 = 0.0005
            NuSOM0 = 0.04 ! CuSOM0 / 10.
            NpSOM0 = 0.4  ! CpSOM0 / 10.
            NsSOM0 = 0.5  ! CsSOM0 / 12.
         ENDIF
         
         !If soilvr (soil variable switch) = 0, then all soil state variables
            !remain constant at their initial values above.
            Constant soilvr = 1  !is the default value of soilvr.

      !Clay fraction, fclay
         fclay = s_months12_dat * fclay_m12 + s_CLINO_dat * fclay_CLINO &    
                                            + s_monthsnn_dat * fclay_mnn &
                 + one_s_months12_dat * one_s_CLINO_dat &
                                  * one_s_monthsnn_dat * fclay_default
                !fclay_m12 is input from the monthly environmental data file
                !when s_months12_dat = 1, etc for fclay_CLINO and fclay_mnn.
      
      !Protected fraction
         !Fraction of carbon in decaying litter lignin component that gets
         !protected:
            fClit_prot = c_lit_prot * fclay !depends on clay fraction, fclay.
                        !c_lit_prot is a parameter (given below).

      !C:N ratios is stabilized SOM
         !rCNsSOM is C/N ratio in stabilized SOM pool (sSOM):
            rCNsSOMmax = rCNsSOM_sandymax + c_sSOMclay * fclay &
                                   * ( rCNsSOM_claymax - rCNsSOM_sandymax ) 
            rCNsSOMmin = rCNsSOM_sandymin + c_sSOMclay * fclay &
                                   * ( rCNsSOM_claymin - rCNsSOM_sandymin ) 
            !The max and min values depend on clay fraction fclay. 
            !Actual value of rCNsSOM depends on Nmin dynamically:
            !Nmin = 0 gives maximum, Nmin very large gives minimum.
      
      !Fractions of C in dying biomass entering unprotected and protected
            !SOM pools (uSOM and pSOM):
             fCbioD_uSOM = fCbioD_uSOM_sandy &
               + c_bioDclay * fclay &
               * ( fCbioD_uSOM_clay - fCbioD_uSOM_sandy )
             fCbioD_pSOM = one - fCbioD_uSOM

   !WATER SUBMODEL - STATE VARIABLES
      !Wle   kg water stem-1.   Foliage water.    
      !Wfi   kg water stem-1.   Fine roots and mycorrhiza water.
      !Wsoil kg water m-2.      Soil water.
         !Initial values of Wle0 and Wfi0 are calculated below because
         !of possible rescaling of foliage and fine root masses.

      !Calculate mass of water in soil at field capacity as an 
         !initial value for soil water (kg water m-2):
            Wsoil0z1 = dsoil * roW * thetasoil_max  
               Constant roW = 1000  !kg m-3.  Density of water.
               Constant thetasoil_max = 0.4  !m3 water (m3 soil)-1.
                       !Maximum value of soil relative water content.
               Constant dsoil = 1   !m.  Soil depth.


   !APHID SUBMODEL - STATE VARIABLES AND INITIAL VALUES
      !Units used: Aphid number per stem.
       Constant s_aphid = 0, aphidvr = 0 !Default values.
         !To enable the aphid submodel (switch it on), then set
         !s_aphid = 1, aphidvr = 1.  Or type <aphid> to switch on, 
         !<aphid 0> to disable.
         !<Set aphidvr = 0> causes the aphid state variables to remain at
         !their initial values.
      !The aphid submodel is based largely on Newman's model for the grass
         !aphid.  Some references are:
      !Newman JA, Gibson DJ, Parsons AJ, Thornley JHM. 2003. How predictable 
         !are aphid population responses to elevated CO2? 
         !Journal of Animal Ecology 72: 556-566.
      !Dixon AFG. 1998. Aphid Ecology (2nd edition). Chapman & Hall.
         !ISBN 0 412 741806.  Pp 300. 77.65. Good but expensive.
      !Day KR, Halldorsson G, Harding S, Straw NA (eds). 1998. The Green
         !Spruce Aphid in Western Europe: Ecology, Status, Impacts and
         !Prospects for Management. Forestry Commission Technical Paper 24.
         !ISBN 0 85538 354 2. 105 pp.
         !The Research Communications Officer, Forest Research,
         !Alice Holt Lodge, Wrecclesham, Farnham, Surrey GL10 4LH, UK.
   
      !Alate (winged), in instars 1 to 4, and adults, a:
         !ala1-4, alaa
      !Apterous (wingless), in instars 1 to 4, adults, a:
         !apt1-4, apta
         !No discrimination is made between aphids on the different aged
         !needles, e.g. Aleaf1, ..., Aleaf4, although it is known that aphids
         !do not feed on the current year's needles, ie not on Aleaf1.  The 
         !aphids reside on Aleaf2, 3, 4. See "Aleaf_aph = ".
      !Initial values of state variables [aphid number stem-1]:
         Constant ala10 = 0.0, ala20 = 0.0, ala30 = 0.0, &
                  ala40 = 0.0, alaa0 = 0.0, &
                  apt10 = 0.0, apt20 = 0.0, apt30 = 0.0, &
                  apt40 = 0.0, apta0 = 0.0
         !There is no facility for scaling any initial values. An initial
         !value be set in the proced aphid in efm.cmd, e.g. aphid 1 10 
         !turns the aphid submodel on, and sets alaa0 to 10, 10 adult
         !alate (winged) aphids have flown in.


   !INITIAL VALUES - SCALING AND CALCULATION
      !Tree initial values
         !Multiplier sctreeic (default value 1) can be
         !used to scale all the tree initial values which have dimensions of
         !per stem.
         Constant sctreeic = 1
         !Similarly, with scleafic (above), leaf initial values can be scaled.
         !Here we first calculate *0z1 values.  See below for more explanation.

         !Foliage, le (leaves)
            Aleaf10z1 = sctreeic * scleafic * Aleaf10z
            Aleaf20z1 = sctreeic * scleafic * Aleaf20z
            Aleaf30z1 = sctreeic * scleafic * Aleaf30z
            Aleaf40z1 = sctreeic * scleafic * Aleaf40z
            MCSle0z1 =  sctreeic * scleafic * MCSle0z
            MNSle0z1 =  sctreeic * scleafic * MNSle0z
            MNph0z1 =   sctreeic * scleafic * MNph0z
            MXle10z1 =  sctreeic * scleafic * MXle10z
            MXle20z1 =  sctreeic * scleafic * MXle20z
            MXle30z1 =  sctreeic * scleafic * MXle30z
            MXle40z1 =  sctreeic * scleafic * MXle40z
            MXle0z1 = MXle10z1 + MXle20z1 + MXle30z1 + MXle40z1
            Wle0z1 = rWXlec * MXle0z1
               Constant rWXlec = 12 !kg water (kg structural DM)-1.
                             !Mass ratio of water to structural DM.
   
         !Branches, br
            MCSbr0z1 = sctreeic * MCSbr0z;    MXbrm0z1 = sctreeic * MXbrm0z
            MNSbr0z1 = sctreeic * MNSbr0z;     MXbr0z1 = sctreeic * MXbr0z
         !Buds, bud
            Mbud0z1 = sctreeic * Mbud0z       !kg dry mass stem-1.
         !Stem, st
            MCSst0z1 = sctreeic * MCSst0z;
            MCstorest0z1 = sctreeic * MCstorest0z;
            MXstm0z1 = sctreeic * MXstm0z
            MNSst0z1 = sctreeic * MNSst0z;     MXst0z1 = sctreeic * MXst0z
            !Volume of stems:
               Vstem0z1 = MXst0z1 / rostem
                       Constant rostem = 350 !kg stem structural DM m-3.
                      !rostem = 350 is stem structural density for spruce.
                      !Densities (Handbook of Chemistry and Physics, 1967/8):
                      !  spruce: 0.48 to 0.70 g cm3;
                      !  beech:  0.70 to 0.90 g cm3. 
                      !We take rostem (beech) = 500 kg stem structural DM m-3.

            !Height and diameter of stems:
               dstem0z1 = ( four * Vstem0z1 / ( pi * rhdstem0 ) ) ** 0.333333
               hstem0z1 = rhdstem0 * dstem0z1
               Constant rhdstem0 = 60   !Dimensionless.  Initial ratio of
                                        !hstem : dstem.

         !Coarse roots, co
            MCSco0z1 = sctreeic * MCSco0z;    MXcom0z1 = sctreeic * MXcom0z
            MNSco0z1 = sctreeic * MNSco0z;     MXco0z1 = sctreeic * MXco0z
   
         !Fine roots and mycorrhizas, fi 
            MCSfi0z1 = sctreeic * MCSfi0z;    MXfim0z1 = sctreeic * MXfim0z
            MNSfi0z1 = sctreeic * MNSfi0z     !kg N substrate stem-1.
            MXfi10z1 = sctreeic * MXfi10z;    MXfi20z1 = sctreeic * MXfi20z
            MXfi30z1 = sctreeic * MXfi30z;    MXfi40z1 = sctreeic * MXfi40z
            MXfi0z1 = MXfi10z1 + MXfi20z1 + MXfi30z1 + MXfi40z1
                                             !Total for 4 age categories.
               MXfitot0z1 = MXfim0z1 + MXfi0z1  !See foliage section above.
            Wfi0z1 = rWXfic * MXfitot0z1  
               Constant rWXfic = 12 !kg water (kg structural DM)-1.
                             !Mass ratio of water to structural DM.
   
            rort0z1 = sctreeic * rort0z  !Root density.
      
      !It is convenient to calculate "seedling" values (*_sdlg) of tree
      !state variables (SV) and other tree variables.  We do this now. 
      !Note there are no "*0z1 =" statements below.
        !Buds
         Mbud_sdlg = Mbud0z1             !kg bud DM stem-1. Mbud is a SV.
         MCbud_sdlg = fCbud * Mbud_sdlg  !kg bud C stem-1.
         MNbud_sdlg = fNbud * Mbud_sdlg  !kg bud N stem-1.
         MWbud_sdlg = rWXbud * Mbud_sdlg !kg bud water stem-1.

        !Foliage
         MCSle_sdlg = MCSle0z1           !kg substrate C stem-1. SV.
         MNSle_sdlg = MNSle0z1           !kg substrate N stem-1. SV.
         MNph_sdlg = MNph0z1             !kg photosynthetic N stem-1. SV.
         MXle1_sdlg = MXle10z1           !kg structural DM stem-1. SV.
         MXle2_sdlg = MXle20z1           !kg structural DM stem-1. SV.
         MXle3_sdlg = MXle30z1           !kg structural DM stem-1. SV. 
         MXle4_sdlg = MXle40z1           !kg structural DM stem-1. SV.
         Aleaf1_sdlg = Aleaf10z1         !m2 (leaf area) stem-1. SV.
         Aleaf2_sdlg = Aleaf20z1         !m2 (leaf area) stem-1. SV.
         Aleaf3_sdlg = Aleaf30z1         !m2 (leaf area) stem-1. SV. 
         Aleaf4_sdlg = Aleaf40z1         !m2 (leaf area) stem-1. SV.

         MXle_sdlg = MXle1_sdlg + MXle2_sdlg + MXle3_sdlg + MXle4_sdlg
                                         !kg structural DM stem-1.
         MCXle_sdlg = fCleX * MXle_sdlg  !kg structural C stem-1.
         MNXle_sdlg = fNleX * MXle_sdlg  !kg structural N stem-1.
         MCle_sdlg = MCSle_sdlg + MCXle_sdlg !kg C stem-1.
         MNle_sdlg = MNSle_sdlg + MNph_sdlg + MNXle_sdlg !kg N stem-1.

         Wle_sdlg = Wle0z1               !kg water stem-1.

        !Branches
         MCSbr_sdlg = MCSbr0z1             !kg substrate C stem-1. SV.
         MNSbr_sdlg = MNSbr0z1             !kg substrate N stem-1. SV.
         MXbr_sdlg = MXbr0z1               !kg structural DM stem-1. SV.
         MXbrm_sdlg = MXbrm0z1             !kg structural DM stem-1. SV.
         MCXbr_sdlg = fCbrX * MXbr_sdlg    !kg structural C stem-1.
         MCXbrm_sdlg = fCbrm * MXbrm_sdlg  !kg structural C stem-1.
         MNXbr_sdlg = fNbrX * MXbr_sdlg    !kg structural N stem-1.
         MNXbrm_sdlg = fNbrm * MXbrm_sdlg  !kg structural N stem-1.
         MCbr_sdlg = MCSbr0z1 + MCXbr_sdlg + MCXbrm_sdlg !kg C stem-1.
         MNbr_sdlg = MNSbr0z1 + MNXbr_sdlg + MNXbrm_sdlg !kg N stem-1.

        !Stems
         MCSst_sdlg = MCSst0z1             !kg substrate C stem-1. SV.
         MNSst_sdlg = MNSst0z1             !kg substrate N stem-1. SV.
         MXst_sdlg = MXst0z1               !kg structural DM stem-1. SV.
         MXstm_sdlg = MXstm0z1             !kg structural DM stem-1. SV.
         MCstorest_sdlg = MCstorest0z1     !kg stem storage stem-1. SV.
         MCXst_sdlg = fCstX * MXst_sdlg    !kg structural C stem-1.
         MCXstm_sdlg = fCstm * MXstm_sdlg  !kg structural C stem-1.
         MNXst_sdlg = fNstX * MXst_sdlg    !kg structural N stem-1.
         MNXstm_sdlg = fNstm * MXstm_sdlg  !kg structural N stem-1.
         MCst_sdlg = MCSst0z1 + MCstorest_sdlg &
                              + MCXst_sdlg + MCXstm_sdlg    !kg C stem-1.
         MNst_sdlg = MNSst0z1 + MNXst_sdlg + MNXstm_sdlg    !kg N stem-1.

        !Coarse roots
         MCSco_sdlg = MCSco0z1             !kg substrate C stem-1. SV.
         MNSco_sdlg = MNSco0z1             !kg substrate N stem-1. SV.
         MXco_sdlg = MXco0z1               !kg structural DM stem-1. SV.
         MXcom_sdlg = MXcom0z1             !kg structural DM stem-1. SV.
         MCXco_sdlg = fCcoX * MXco_sdlg    !kg structural C stem-1.
         MCXcom_sdlg = fCcom * MXcom_sdlg  !kg structural C stem-1.
         MNXco_sdlg = fNcoX * MXco_sdlg    !kg structural N stem-1.
         MNXcom_sdlg = fNcom * MXcom_sdlg  !kg structural N stem-1.
         MCco_sdlg = MCSco0z1 + MCXco_sdlg + MCXcom_sdlg !kg C stem-1.
         MNco_sdlg = MNSco0z1 + MNXco_sdlg + MNXcom_sdlg !kg N stem-1.

        !Fine roots and mycorrhizae
         MCSfi_sdlg = MCSfi0z1             !kg substrate C stem-1. SV.
         MNSfi_sdlg = MNSfi0z1             !kg substrate N stem-1. SV.
         MXfi1_sdlg = MXfi10z1; MXfi2_sdlg = MXfi20z1 !kg structural DM 
         MXfi3_sdlg = MXfi30z1; MXfi4_sdlg = MXfi40z1 !stem-1. 4 SVS.
         MXfi_sdlg = MXfi1_sdlg + MXfi2_sdlg + MXfi3_sdlg + MXfi4_sdlg 
                                           !kg structural DM stem-1.
                                           !kg structural DM stem-1. 4 SVS.
         MXfim_sdlg = MXfim0z1             !kg structural DM stem-1. SV.
         MCXfi_sdlg = fCfiX * MXfi0z1      !kg structural C stem-1.
         MCXfim_sdlg = fCfim * MXfim_sdlg  !kg structural C stem-1.
         MNXfi_sdlg = fNfiX * MXfi_sdlg    !kg structural N stem-1.
         MNXfim_sdlg = fNfim * MXfim_sdlg  !kg structural N stem-1.
         MCfi_sdlg = MCSfi0z1 + MCXfi_sdlg + MCXfim_sdlg   !kg C stem-1.
         MNfi_sdlg = MNSfi0z1 + MNXfi_sdlg + MNXfim_sdlg   !kg C stem-1.

         Wfi_sdlg = Wfi0z1                 !kg water stem-1. 



      !Calcics section (conditional initialization).
         !Calculate initial conditions.
         !Insertion of *0z1 values into actual initial conditions, *0.
         !In order that the runtime commands REINIT possibly with RESTORE
         !can be used to write other state variable values into the initial
         !conditions, we need to be able to skip this section, where we write
         !*0z1 variables into the actual initial values.
         LOGICAL calcics 
                !Logical switch for Calculation of Initial Conditions.
         Constant calcics = .TRUE. !Default value is TRUE, so the tree
                !state variables have their usual (possibly scaled) values.

         IF ( calcics ) THEN !Calculate initial conditions for tree state
            !variables, *0.  The *0 variables are used in the
            !* = INTEG( D*, *0 ) statements. D = d/dt.
            !We put *0z1 variables into *0.  
            !Tree initial values - multiplier sctreeic (default 1) can be
            !used (above) to scale all tree initial values which have
            !dimensions of per stem.  *0z values are scaled into *0z1.
            !Most (not all) *0z are specified by Constant statements.
            !A few *0z initial values are calculated from other *0z 
            !values: eg Mbud0z.

            !Now put *0z1 variables into the *0 variables. 
            !Re-initialization in the selfthin
            !mode changes the *0 variables. Putting calcics = .false. 
            !ensures that these are not returned to their usual seedling
            !values. Eg see proced init in file st.cmd.

            !Foliage, le, leaf, ph = photosynthesis
                  Aleaf10 = Aleaf10z1;  Aleaf20 = Aleaf20z1
                  Aleaf30 = Aleaf30z1;  Aleaf40 = Aleaf40z1
                  MCSle0 =  MCSle0z1;   MNSle0 =  MNSle0z1
                  MNph0 =   MNph0z1;    MXle10 =  MXle10z1
                  MXle20 =  MXle20z1;   MXle30 =  MXle30z1
                  MXle40 =  MXle40z1;   MXle0 = MXle0z1
                  Wle0 = Wle0z1
      
            !Branches, br
                     MCSbr0 = MCSbr0z1;  MXbrm0 = MXbrm0z1
                     MNSbr0 = MNSbr0z1;  MXbr0 =  MXbr0z1
      
            !Buds, bud
                     Mbud0 = Mbud0z1                 !kg dry mass stem-1.
      
            !Stem, st
                     MCSst0 = MCSst0z1;   MCstorest0 = MCstorest0z1;
                     MXstm0 = MXstm0z1
                     MNSst0 = MNSst0z1;   MXst0 =  MXst0z1
      
            !Volume of stems:
                  Vstem0 = Vstem0z1
   
            !Height and diameter of stems:
                   dstem0 = dstem0z1
                   hstem0 = hstem0z1
      
            !Coarse roots, co
                  MCSco0 = MCSco0z1;  MXcom0 = MXcom0z1
                  MNSco0 = MNSco0z1;  MXco0 = MXco0z1
         
            !Fine roots and mycorrhizas, fi 
                  MCSfi0 = MCSfi0z1;  MXfim0 = MXfim0z1
                  MNSfi0 = MNSfi0z1      !kg N substrate stem-1.
                  MXfi10 = MXfi10z1;  MXfi20 = MXfi20z1
                  MXfi30 = MXfi30z1;  MXfi40 = MXfi40z1
                  MXfi0 = MXfi0z1
                  MXfitot0 = MXfitot0z1 
                         !kg XDM in fine roots & mycorrhiza stem-1.
                  Wfi0 = Wfi0z1
                  rort0 = rort0z1
         
            !Calculate mass of water in soil at field capacity as an 
               !initial value for soil water (kg water m-2):
                  Wsoil0 = Wsoil0z1 
      
         ENDIF !End of calculation/scaling of initial conditions dependent on
               !the value of calcics.
   
      !Scale restored state variables
         IF ( scale_restored_svs0 ) THEN
            !Scale some of the initial values of state variables (svs0)
            !which have been set by a restore statement.
            LOGICAL scale_restored_svs0
            Constant scale_restored_svs0 = .FALSE.
               Constant sc_restored_svs0 = 0.5
                  !Tree state variables:
                     nstems0 = sc_restored_svs0 * nstems0
                  !Soil state variables:
                     Cbio0 = sc_restored_svs0 * Cbio0
                     Char0 = sc_restored_svs0 * Char0
                     Csol0 = sc_restored_svs0 * Csol0
                     Csoil_li_met0 = sc_restored_svs0 * Csoil_li_met0
                     Csoil_li_cel0 = sc_restored_svs0 * Csoil_li_cel0
                     Csoil_li_lig0 = sc_restored_svs0 * Csoil_li_lig0
                     Csurf_li_met0 = sc_restored_svs0 * Csurf_li_met0
                     Csurf_li_cel0 = sc_restored_svs0 * Csurf_li_cel0
                     Csurf_li_lig0 = sc_restored_svs0 * Csurf_li_lig0
                     CpSOM0 = sc_restored_svs0 * CpSOM0
                     CsSOM0 = sc_restored_svs0 * CsSOM0
                     CuSOM0 = sc_restored_svs0 * CuSOM0
                     Namm0 = sc_restored_svs0 * Namm0
                     Nnit0 = sc_restored_svs0 * Nnit0
                     Nsoil_li_met0 = sc_restored_svs0 * Nsoil_li_met0
                     Nsurf_li_met0 = sc_restored_svs0 * Nsurf_li_met0
                     NpSOM0 = sc_restored_svs0 * NpSOM0
                     NsSOM0 = sc_restored_svs0 * NsSOM0
                     NuSOM0 = sc_restored_svs0 * NuSOM0
      
                     Cptd0 = sc_restored_svs0 * Cptd0
                     Nptd0 = sc_restored_svs0 * Nptd0
                     Cprd0 = sc_restored_svs0 * Cprd0
                     Nprd0 = sc_restored_svs0 * Nprd0
         ENDIF !IF ( scale_restored_svs0 ) statement.
   
      !Other initializations
      
         !Time:
            IF ( irotate .EQ. i1 ) year_accum_rot0 = zero
               !Only set the initial value of year_accum_rot to 0 on the
               !first rotation.  year_accum_rot counts the total years of
               !all the rotations: thus after
               !5 rotations of 60 years, year_accum_rot = 300.
               !year_accum_rot is accumulated using an INTEG statement.
               !year_accum_rot0 is updated in the terminal block if
               !rotations are switched on (s_rotate = 1).
   
         !All Int_* are integrals INTEG( ) over the current run.
   
         !Tree:
             Int_LAI0 = zero
             Int_SLA0 = zero
             Int_Cle0 = zero
             Int_Nle0 = zero
             Int_Cphloem0 = zero
             Int_Nphloem0 = zero
             Int_Cfi0 = zero
             Int_Nfi0 = zero
             Int_Nph0 = zero
             Int_Nph_A0 = zero
             Int_fjPAR_Nph0 = zero
             Int_fNSle_Nph0 = zero
             Int_rCNle0 = zero
             Int_rCNfi0 = zero
             Int_CStree0 = zero
             Int_NStree0 = zero
             Int_Nletot0 = zero
             Int_Nletot_A0 = zero
             Int_Ctree0 = zero
             Int_Ntree0 = zero
             Int_fCSmai_tree0 = zero
             Int_PXDMbrm_gnd0 = zero
             Int_PXDMbud_gnd0 = zero
             Int_PXDMstm_gnd0 = zero
             Int_PXDMcom_gnd0 = zero
             Int_PXDMfim_gnd0 = zero
             Int_Onstems_fire0 = zero
         !Products:
             Int_Cptrd0 = zero
             Int_Nptrd0 = zero
         !Soil, litter:
             Int_Namm0 = zero
             Int_Nnit0 = zero
             Int_Cbio0 = zero
             Int_Csol0 = zero
             Int_Csurf_li0 = zero
             Int_Csoil_li0 = zero
             Int_Nsurf_li0 = zero
             Int_Nsoil_li0 = zero
             Int_Clitter0 = zero
             Int_Nlitter0 = zero
             Int_Csoil0 = zero
             Int_Nsoil0 = zero
             Int_CSOM0 = zero
             Int_NSOM0= zero
             Int_CliSOM0 = zero
             Int_NliSOM0= zero
         !Tree and litter:
             Int_Ctreelitter0 = zero
             Int_Ntreelitter0 = zero
         !Water:
             Int_rMSleWle0 = zero
             Int_psile0 = zero
             Int_psiOle0 = zero
             Int_psiPle0 = zero
             Int_thetale0 = zero
             Int_thetasoil0 = zero
         !System:
             Int_Csys0= zero
             Int_Nsys0 = zero
         !Environment fluxes:
             Int_jPARsc0 = zero
             Int_jPARscabs0 = zero
         !Carbon fluxes:
             Int_ICsys0 = zero
             Int_ICimm_alaa_m20 = zero !Note: ICsys = Pcan + ICimm_alaa_m2
             Int_OCsys0 = zero
             Int_OCprd0 = zero
             Int_Pcan0= zero
             Int_Pcan_IP0 = zero
             Int_Pnet0 = zero
             Int_Pmax200 = zero
             Int_Rtree_gnd0 = zero
             Int_Rtreem_gnd0 = zero
             Int_RtreeG_gnd0 = zero
             Int_Rphloem_loading_gnd0 = zero
             Int_RNnit_red_tree_gnd0 = zero
             Int_Rmin_upt_gnd0 = zero
             Int_RNmin_upt_gnd0 = zero
      
             Int_OCtree_fire_atm0 = zero
             Int_OCsurf_li_fire_atm0 = zero
      
             Int_ICsurf_li_Csol0 = zero
             Int_ICsoil_li_Csol0 = zero
             Int_ICfi_Csol0 = zero
             Int_ICbioD_Csol0 = zero
             Int_ICuSOM_Csol0 = zero
             Int_ICpSOM_Csol0 = zero
             Int_ICsSOM_Csol0 = zero     
             Int_OCsol_bioG0 = zero
             Int_OCsolR0 = zero
             Int_OCsol_lch0 = zero
             Int_Rsoil0 = zero
         !Nitrogen fluxes:
             Int_uN_gnd0 = zero
             Int_INSOM_Namm0 = zero
             Int_INSle_Nph0 = zero 
             Int_INbud_Nph0 = zero
             Int_INsys0 = zero
             Int_INfix_Namm0 = zero
             Int_INenv_dep0 = zero
             Int_ONsys0 = zero
             Int_ONprd0 = zero
             Int_ONsoil_fi0 = zero
             Int_ONSle_atm_gnd0 = zero
             Int_ONnit_lch0 = zero
             Int_ONamm_vol0 = zero
             Int_ONamm_nitrif_env0 = zero
             Int_ONnit_denit0 = zero
             Int_ONamm_nit0 = zero
             Int_ONtree_fire_atm0 = zero
             Int_ONsurf_li_fire_atm0 = zero
             Int_ONsoil_env0 = zero
             Int_ONprthd0 = zero
             Int_ONprrod0 = zero
         !Water fluxes (kg water m-2 day-1):
             Int_OWrain_int0 = zero
             Int_OWle_atm_gnd0 = zero
             Int_OWso_atm0 = zero
             Int_OWso_drain0 = zero
             Int_OWprthd0 = zero
             Int_IWsys0 = zero  !Rainfall.
             Int_OWsys0 = zero
         !Thinning fluxes:
             Int_OCtree_th0 = zero
             Int_ONtree_th0 = zero
             Int_ICth_pr0 = zero
             Int_INth_pr0 = zero
             Int_ICth_litter0 = zero
             Int_INth_litter0 = zero
         !Self-thinning:
             Int_sn_exp0     = zero
             Int_sn_expMXst0 = zero
             Int_sn_expMXtree0 = zero
         !Product fluxes:
             Int_IVpt0 = zero
      
         !Check variables: yst_fire, ysurf_li_fire.
         !Just for checking, of no model significance.  Initial values are:
            yst_fire0 = one
            ysurf_li_fire0 = one

         !Initialization of quantities used for calculating sums of slow moving
            !variables on a daily basis (search <_0h>):
               chk_dy_sum = zero
               LAR_0h_sum = zero
               SLA_0h_sum = zero
         
         
         !Initialization of quantities used in calculating sums of
            !variables extracted once per year: 
               chk_yr_sum = zero
               Pcan_IP_1Jul15h_yr_sum = zero  
               Pmax_1Jul15h_yr_sum = zero  
               alpha_1Jul15h_yr_sum = zero  
               thetale_1Jul15h_yr_sum = zero
         
               gstom_1Jul15h_yr_sum = zero  
               fgstom_Pmax_1Jul15h_yr_sum = zero  
               gstom_1Aug15h_yr_sum = zero  
               fgstom_Pmax_1Aug15h_yr_sum = zero  
               gstom_1Jul15h_sum = zero
         
               psiPle_1Jul15h_yr_sum = zero  
               thetasoil_1Jul15h_yr_sum = zero  
         
         !The following are also unassigned at t = 0, and must be initialized.
               Pcan_IP_1Jul15h = zero  
               Pmax_1Jul15h = zero  
               alpha_1Jul15h = zero  
               jPARsc_sun_1Jul15h = zero  
               fWle_1Jul15h = zero  
               thetale_1Jul15h = zero  
         
               gstom_1Jul15h = zero  
               fgstom_Pmax_1Jul15h = zero  
               gstom_1Aug15h = zero  
               fgstom_Pmax_1Aug15h = zero  
               gstom_1Jul15h_sum = zero
         
               psiPle_1Jul15h = zero  
               thetasoil_1Jul15h = zero  
   !End of INITIAL VALUES - SCALING AND CALCULATION
         
          
   !THINNING (initial section)
      !Thinning takes place over the course of one day.
      !This avoids double-valued variables. 
      !It makes life simpler if it takes place on 1 January of a year.
      !This makes the calculation of annual averages and fluxes easy.
   
      Constant s_thin = 0     !Thinning is switched on(1)/off(0).
   
      !Times of thinning, ie, the times when the thinning begins, 
         !are stored in the real array, tthin(15).
         !We allow for a maximum of 15 thinnings per rotation
         !with up to 21 rotations (see below).
   
      INTEGER nthin, nthinmax
      Constant nthin = 8  !Number of thinnings per rotation (default value).
                          !Maximum value of nthin is 15 due to array sizes:
      Constant nthinmax = 15
   
      !Eight thinning times are set in the default thinning specification.
         !Default values are for Sitka at Eskdalemuir.
         !These thinnings begin at times:
         ARRAY tthin( 15 ) 
         Constant tthin = 7300,  9125, 10950, 12775, 14600, &
                         16425, 18250, 20075, 1.0e15, 1.0e15, &
                         1.0e15, 1.0e15, 1.0e15, 1.0e15, 1.0e15  !days.
         !These numbers give 8 thinnings, at 20, 25, 30, 35, 
         !40, 45, 50, 55 years, if s_thin = 1 (default = 0).
   
             !For output only, derive the years when thinning occurs:
                  ARRAY yrthin( 15 ); INTEGER i 
                  DO yrthinloop i = 1, 15
                     yrthin( i ) = tthin( i ) / c365
                  yrthinloop..CONTINUE
      
      !Fractions of the then standing stem numbers (nstems) removed at 
      !each thinning:
         ARRAY fst_rem_th(15)
         Constant fst_rem_th = 0.45, 0.4, 0.35, 0.3, 0.25, &
                               0.2,  0.15, 0.1, 0.0, 0.0, &
                               0.0, 0.0, 0.0, 0.0, 0.0
         !The fifth thinning occurs at 40 years (14600 days) when 25% of stems
         !are removed, and 75% are left standing.
   
      !Rate constants, kthin (15)
         !These are calculated here (also potentially recalculated in the
            !Derivative section in case maxt is changed during a run).
               ARRAY kthin ( 15 )
               !Fractions of stem numbers removed by thinning, fst_rem_th , 
               !are removed during time, tau_thin (days),
               !the time taken for each thinning to occur.
                  Constant tau_thin = 1 !day.
                  maxt_D_tau_thin = maxt / tau_thin 
   
                  denmaxt = maxt !maxt appears as a denominator. This is to
                           !help with debugging. d den* gives denominators. 
                        arg1 = ( one - fst_rem_th ( 1 ) ) &
                                ** maxt_D_tau_thin 
                         !does arg1 change s maxt is altered?
               DO kthin_loop_Initial iz = 1, nthinmax 
                  kthin ( iz ) = ( one - &
                                 ( one - fst_rem_th ( iz ) ) &
                                         ** maxt_D_tau_thin &
                                 ) / maxt 
               kthin_loop_Initial..CONTINUE
   
   !End of THINNING initialization.


   !FIRE (Initial Section)
      !Fire takes place over the course of a day, which can be specified.
   
      Constant s_fire = 0     !Fire is switched on(1)/off(0).
   
      !Times of fire, ie, the times when the fire begins, 
         !are stored in the real array, tfire(10).
         !We allow for a maximum of 10 fire events per run.
   
      INTEGER nfire, nfiremax
      Constant nfire = 1  !Number of fire events per run.
                          !Maximum value of nfire is 10 due to array sizes:
      Constant nfiremax = 10
   
      !A single fire event is set in the default specification.
        !Fire events begin at the times:
         ARRAY tfire(10) 
         Constant tfire = 365,   1.0e15, 1.0e15, 1.0e15, 1.0e15, &
                         1.0e15, 1.0e15, 1.0e15, 1.0e15, 1.0e15  !days.
         !This gives a fire event at 1 year, if s_fire = 1
         !The fire lasts 1 day, the 1st January.
      
      !Fractions of the then standing stem numbers (nstems) killed at 
      !each fire event:
         ARRAY fst_kill_fire(10)
         Constant fst_kill_fire = 1.0, 1.0, 1.0, 1.0, 1.0, &
                                  1.0, 1.0, 1.0, 1.0, 1.0
                                 !Severe fire value is default.
                  fst_kill_fire1 = fst_kill_fire(1) !For output only.
         !The rate constant, kst_fire (day-1), applied to nstems is
            ARRAY kst_fire(10)
         !Fractions, fst_kill_fire, are removed during time, tau_fire (days),
            !the time taken for each fire event to occur.
            Constant tau_fire = 1 !day. Program not tested with other tau_fire.

               IF ( maxt .NE. zero ) THEN
                  nmaxt_tau_fire = tau_fire / maxt
                    !This is the number of maxt steps in tau_fire, the time 
                    !taken to complete a fire event.
                  inmaxt_tau_fire = one / nmaxt_tau_fire !Inverse quantity.  
               ELSE
                  inmaxt_tau_fire = zero
               ENDIF
   
         DO kst_fire_loop iz = 1, nfiremax
             IF ( maxt .NE. zero ) THEN
                kst_fire(iz) = ( one - ( one - fst_kill_fire(iz) ) &
                                              ** inmaxt_tau_fire ) / maxt
             ELSE
                kst_fire(iz) = zero
             ENDIF
         kst_fire_loop..CONTINUE
   
      !Initialization of time of last fire:
         Constant tlast_fire1 = 7.7777e7     !day.
                  tlast_fire = tlast_fire1   !day.
                  yrlast_fire = tlast_fire / c365 !Year of last fire.
                  yr_fireEfNd = yrlast_fire + tauyr_fire_soilT_inc
                     !Year when fire effects on soil temperature and
                     !mineralization rates end.
   
      !Effects of fire on surface litter pools.
         !Fractions of the 3 surface litter pools (all 3 pools are treated
         !the same) lost as a result of the fire event.
         ARRAY fsurf_li_fire(10)
         Constant fsurf_li_fire = 1.0, 1.0, 1.0, 1.0, 1.0, &
                                  1.0, 1.0, 1.0, 1.0, 1.0
                  fsurf_li_fire1 = fsurf_li_fire(1) !For output only.
         !The rate constants, ksurf_li_fire (day-1), are in
            ARRAY ksurf_li_fire(10)
         !Fractions, fsurf_li_fire, are removed during time, tau_fire (days),
            !the time taken for each fire event to occur.
            !Constant tau_fire = 1 !day.
   
         DO ksurf_li_fire_loop iz = 1, nfiremax
             IF ( maxt .NE. zero ) THEN
                ksurf_li_fire(iz) = ( one - ( one - fsurf_li_fire(iz) ) &
                                                  ** inmaxt_tau_fire ) / maxt
             ELSE
                ksurf_li_fire(iz) = zero
             ENDIF
         ksurf_li_fire_loop..CONTINUE
      !End of FIRE initialization.


   !TEMPERATURE FUNCTION - initial calculations
      !Plant and soil temperature (T) functions - many of the plant and soil
      !rate constants are assumed temperature-dependent,
      !with the dependence modelled by a variable polynomial function:
         !f(T) = m_fT * ( T - T0 ) ** qfT1 * ( T0p - T ) ** qfT2 / &
         !          (( Tref - T0 ) ** qfT1 * ( T0p - Tref ) ** qfT2 )
            Constant m_fT = 1 !Dimensionless multiplier of temperature
                              !function.
            Constant T0 = 0, T0p = 45  !oC. p denotes prime.
               !Temperatures at which the temperature function f(T) = 0.
            Constant qfT1 = 2 !Temperature response parameter; gives a cubic.
               !qfT1 denotes how initially (T>0) sigmoidal the response is:
                  !qfT1 = 1, quadratic, not sigmoidal,
                  !qfT1 = 2, cubic,     sigmoidal,
                  !qfT1 = 3, quartic,   more sigmoidal, etc.
                  !See Thornley & France, p. 106,  Fig. 4.6.
            Constant qfT2 = 1 !Temperature response parameter.
               !determines the steepness of the response as temperature, T,
               !approaches T0p, where again f(T) = 0.
            Constant Tref = 20 !oC. Reference temperature at which f(20) = 1.
   
            !The second line of f(T) makes f(T) = 1 at T = Tref, the reference
            !temperature (when m_fT = 1).  

            !For later use, we calculate:
               zfT = one / &
                     ( ( Tref - T0 ) ** qfT1 * ( T0p - Tref ) ** qfT2  &
                     )
            !Outside the temperature range T0 to T0p, f(T) = 0.
            !f(T) is maximum at Tmax = (qfT2*T0 + qfT1*T0p)/(qfT1 + qfT2)

         !Parameters are assumed the same for soil processes also.
         !Photosynthesis: T dependence of alpha (initial slope) and Pmax
         !(light-saturated value of P), are treated differently.  Search for
         !<fTalpha> and <fT_Pmax>.

         !We repeat the above for f(T) of aphid development. p denotes prime.
         !fTaph_dev = m_fTaph_dev * ( T - T0aph_dev ) &
         ! ** qfT1aph_dev * ( T0paph_dev - T ) ** qfT2aph_dev ) / &
         !          (( Trefaph_dev - T0aph_dev ) &
         ! ** qfT1aph_dev * ( T0paph_dev - Trefaph_dev ) ** fqfT2aph_dev )
            Constant m_fTaph_dev = 1 !Dimensionless multiplier of temperature
                                     !function.
            Constant T0aph_dev = 0, T0paph_dev = 30  !oC. 
               !Temperatures when temperature function f(T)aph_dev = 0.
            Constant qfT1aph_dev = 2, qfT2aph_dev = 1 
                      !Temperature response parameters.
               !qfT1aph_dev denotes how sigmoidal the response is:
                  !q = 1, quadratic, not sigmoidal,
                  !q = 2, cubic,     sigmoidal,
                  !q = 3, quartic,   more sigmoidal, etc.
                  !See Thornley & France, p. 106,  Fig. 4.6.
            Constant Trefaph_dev = 20 !oC. Reference temperature at which 
                  !f(20)aph_dev = 1.
            !The second line of f(T)aph_dev makes f(T)aph_dev = 1 
               !at T = Trefaph_dev, the reference
               !temperature (when m_fTaph_dev = 1).  
            !For later use, we calculate:
               zfTaph_dev = one / &
                     ( (( Trefaph_dev - T0aph_dev ) ** qfT1aph_dev ) &
                     * ( T0paph_dev - Trefaph_dev ) ** qfT2aph_dev  )
            !Outside the temperature range T0aph_dev to T0paph_dev,
            ! f(T)aph_dev = 0.

         !We repeat the above for f(Tair) of aphid fecundity.
         !fTaph_fec = m_fTaph_fec * ( T - T0aph_fec ) &
         ! ** qfT1aph_fec * ( T0paph_fec - T ) ** qfT2aph_fec / &
         !  (( Trefaph_fec - T0aph_fec ) ** qfT1aph_fec &
         !  * ( T0paph_fec - Trefaph_fec ) ** qfT2aph_fec )
            Constant T0aph_fec = 3, T0paph_fec = 30  !oC.
               !Temperatures when temperature function f(T)aph_fec = 0.
            Constant qfT1aph_fec = 2, qfT2aph_fec = 1 
                  !Temperature response parameters.
                  !See Thornley & France, p. 106,  Fig. 4.6.
            Constant Trefaph_fec = 20 !oC. Reference temperature at which 
                  !f(20)aph_fec = 1.
            !The second line of f(T)aph_fec makes f(T)aph_fec = 1 
               !at T = Trefaph_fec, the reference temperature.
            !For later use, we calculate:
               zfTaph_fec = one / &
                     ( ( Trefaph_fec - T0aph_fec ) ** qfT1aph_fec &
                        * ( T0paph_fec - Trefaph_fec ) ** qfT2aph_fec &
                     )
            !Outside the temperature range T0aph_fec to T0paph_fec,
            ! f(T)aph_fec = 0.
            !f(T)aph_fec is maximum at Tmaxaph_fec = &
            ! ( qfT2aph_fecT0 * T0aph_fec + qfT1aph_fec * T0paph_fec ) / &
            !( qfT2aph_fec + qfT1aph_fec)

   !PHENOLOGY (initial) These statements are not sorted.
   !Phenology temperature functions, fTchill, kforce.
      !Dormancy begins ---> Dormancy ends ---> Competence ---> Budburst --->
      !Dormancy begins.
      !State variables:
      ! dorm2 ----> comp ----> budb ----> dorm1 ----> dorm2 ...
      !     chilling    forcing     summer      dormancy
      !                             growth      breaking
      !with rate constants:
      !     kchill      kforce      kbudb_dorm1 kdorm1_2     day-1.

      !                             <----
      !                             kdorm1_budb
      !                             progress away from dormancy onset.
      !
      !kchill and kforce are zero-order rate constants.
      !Chilling and forcing can occur simultaneously.
      !The sharply defined events are: 
         !the beginning of dormancy, tdorm1
         !end (breaking) of dormancy, tdorm2
         !budburst, tbudb.
      !It is assumed that the first simulation begins on 1 Jan, and 
      !therefore the initial values of the state variables are set to
      !  dorm1         comp              dorm1 MU ( morphological units )
      !  0             100               0
      !giving a plant which responds to forcing.

      !Chilling.  Rate constant, kchill (day-1).
         !kchill = kchill20 * fTchill
         !fTchill is the dimensionless chilling temperature function.
         !fTchill = multfTchill * ( T - Tchillmin ) ** qchillmin * &
                              !( Tchillmax - T ) ** qchillmax
                   !multfTchill is a multipler of fTchill, 
                   !so that the maximum value of fTchill = 1.
                   !If T < Tchillmin or T > Tchillmax, then fTchill = 0.
         !The function has its maximum value at T = Tchillopt, where
            Tchillopt = &
                  ( qchillmin * Tchillmax + qchillmax * Tchillmin ) &
                  / ( qchillmin + qchillmax )
            !giving the multiplying factor (mult) or the chilling function as
            multfTchill = 1.0 / &
                    ( ( Tchillopt - Tchillmin ) ** qchillmin * &
                      ( Tchillmax - Tchillopt ) ** qchillmax )
               !multfTchill is a working variable for use below.
            Constant Tchillmin = -5 !degrees C. Minimum temperature at which
                                    !chilling occurs.
            Constant Tchillmax = 15 !degrees C. Maximum temperature at which
                                    !chilling occurs.
            Constant qchillmin = 2, qchillmax = 1 !Dimensionless.
                                    !These q factors determine how sigmoidal
                                    !the response is at each end 
                                    !(ie Tchillmin and Tchillmax), and if it
                                    !is symmetric 
                                    !(symmetric if q..max = q..min).
                                    !q = 1, quadratic, but linear at end,
                                    !q = 2, cubic,     sigmoidal,
                                    !q = 3, quartic,   more sigmoidal, etc.
      !Forcing.  See below.

      !Assume the first simulation starts on 1 Jan, the plant has fulfilled
      !its chilling requirement, and the buds can be forced, the leaves
      !are ready to open, but the temperature requirement has not been met.

           iyearbudb = 1 !Initialize this counter which is used to make
                         !sure budburst occurs once a year.
           iyearbso = 1  !Initialize this counter which is used to make
                         !sure buds-stop-opening (bso) occurs once a year.

      !Dormancy. This approaches as dorm1 increases from 0 to 100.
           Kdorm1q = Kdorm1_kXle_li ** qdorm1_kXle_li !dorm1 **q.
              Constant Kdorm1_kXle_li = 70 !Half-maximal response for
                 !increase in leaf senescence rate to approaching dormancy.
                 !This value should be compared with dorm1max_budsopening,
                 !value of dorm1 when buds stop opening.  I think
                 !Kdorm1_kXle_li > dorm1max_budsopening, so that buds stop
                 !opening before leaf senescence is increased.
              Constant qdorm1_kXle_li = 10 !Sigmoidicity of this response.
              Constant m_dorm1_kXle_li_max = 100
                 !Maximum value of the multipler of the leaf senescence
                 !rate (kXle_li).
                    m_dorm1_kXle_li_max_1 = m_dorm1_kXle_li_max - one
   !PHENOLOGY (initial) End of phenology (initial).



   !TREE PARAMETERS - initial calculations
      !Some parameter combinations for use in photosynthesis section:
            Constant kcan = 0.5          !Canopy extinction coefficient.
                                         !m2 ground (m2 leaf)-1
            Constant chileaf = 0.03      !Leaf transmission coefficient. 
                                         !Spruce needles
                                         !have a low transmittivity.
            !Beech: kcan = 0.87 from Maureen Murray (CEH) Dec 01.
                   !chileaf = 0.1     !guessed. Beech leaves are quite thin.
            Constant ksi_ph = 0.5 !Leaf photosynthesis parameter. Sitka spruce 
                                !responses are quite curved. Cannell MGR, 1987.
                                !Proc Roy Soc Edin 93B, 61-73.  Figure 1.
            kcan_mod = kcan / ( one - chileaf )  
            two_ksi_ph = two * ksi_ph
            four_ksi_ph = four * ksi_ph
   
      !Parameter in dependence of specific leaf area SLA on shoot substrate
      !C:N ratio:
         KrCNleSLAq = KrCNleSLA ** qrCNle
   
      !Stem height:diameter growth parameter: 
         KpsiPleq = KpsiPle ** qpsiPle

      !Substrate to and from (stem) storage parameters:
         KstqCSst_store = KCSst_store ** qCSst_store 
        
      !Seed section and tree death (self-thinning) section.
         one_s_seeds = one - s_seeds  !s_seeds is the switch used to make
                                      !seed section operative.
                                      !ie seed germination contributes to
                                      !nstems. See 'Instems_sn = '.
                                      !Default: s_seeds = 0.  See below.
      !Maintenance
         qNX_mai_1 = qNX_mai - one

   !APHID initial section
      !Carbon, nitrogen contents of aphids
         !Each of these 10 types of aphid has a dry mass with a content of C
         !and N in a constant ratio.  We assume
         Constant MCala1 = 1.0E-6,  MNala1 = 1.0E-6, &
                  MCala2 = 2.0E-6,  MNala2 = 2.0E-6, &
                  MCala3 = 3.0E-6,  MNala3 = 3.0E-6, &
                  MCala4 = 4.0E-6,  MNala4 = 4.0E-6, &
                  MCalaa = 5.0E-6,  MNalaa = 5.0E-6, &
                  MCapt1 = 1.0E-6,  MNapt1 = 1.0E-6, &
                  MCapt2 = 2.0E-6,  MNapt2 = 2.0E-6, &
                  MCapt3 = 3.0E-6,  MNapt3 = 3.0E-6, &
                  MCapt4 = 4.0E-6,  MNapt4 = 4.0E-6, &
                  MCapta = 5.0E-6,  MNapta = 5.0E-6       !kg C, N aphid-1.
   
      !Calculate here, for efficiency, the differences in
         !C and N contents of the different aphid stages):
         delMCala2_1 = MCala2 - MCala1;  delMNala2_1 = MNala2 - MNala1
         delMCala3_2 = MCala3 - MCala2;  delMNala3_2 = MNala3 - MNala2
         delMCala4_3 = MCala4 - MCala3;  delMNala4_3 = MNala4 - MNala3
         delMCalaa_4 = MCalaa - MCala4;  delMNalaa_4 = MNalaa - MNala4
         delMCapt2_1 = MCapt2 - MCapt1;  delMNapt2_1 = MNapt2 - MNapt1
         delMCapt3_2 = MCapt3 - MCapt2;  delMNapt3_2 = MNapt3 - MNapt2
         delMCapt4_3 = MCapt4 - MCapt3;  delMNapt4_3 = MNapt4 - MNapt3
         delMCapta_4 = MCapta - MCapt4;  delMNapta_4 = MNapta - MNapt4
                                                              !kg C, N aphid-1.
      !Apterous:alate ratio in offspring. Offspring can arise from apterous
         !(apt, wingless) females or alate (ala, winged) females. 
         !The offspring (from apterous or alate females)
         !can be apterous or alate. The apterous:alate ratio depends on
         !air temperature, aphid density, and N concentration in phloem.
         !Some constants are calculated here in the Initial section for
         !efficiency.
            !Effect of air temperature, Tair:
               KTaptq = KTapt ** qTapt !KTapt = 10, qTapt = 2
               KTalaq = KTala ** qTala !KTala = 10, qTala = 2.
            !Effect of total aphid density, roaph [aphid # (m2 leaf)-1]
               Kroaphaptq = Kroaphapt ** qroapt
               Kroaphalaq = Kroaphala ** qroala 
                   !Kroaphapt = 1000.0, qroapt = 2,
                   !Kroaphala = 1000.0, qroala = 2,
            !Effect of phloem N concentration, Nphloem:
               KNaptq = KNapt ** qNapt
               KNalaq = KNala ** qNala
            !The K... constants are given below, where these derived constants
               !K..q are used.
   
      !Mortality is equally affected in apterous and alate aphids, hence aph
         !(rather than aphapt, aphala).
         !Effect of Nphloem:
            KNaph_mortq = KNaph_mort ** qaph_Nmort
   
      !Developmental rate of apterous and alate aphids is equally affected by
         !Nphloem:
            one_fNaph_dev_min = one - fNaph_dev_min
  
   !End of APHID initial section.
   
   
   !COUNTERS - initialization
      !idaycount and iyearcount count days and years.  They are used
      !for statements in the
      !derivative section which are executed once per day or per year
      !at the beginning of each day or year.
         INTEGER idaycount
                 idaycount = tic  !See VARIABLE statement below for tic.
                                  !tic is the initial value of the time
                                  !variable t.  Normally, tic = 0.
         INTEGER iyearcount, iyearcount0
                 Constant iyearcount0 = 0;  iyearcount = iyearcount0
   

   OPEN (unit = 70, file = 'debug.out') ; REWIND 70 !Open this file for 
                                         !possible debug output. 
                      LOGICAL debugout ; debugout = .TRUE.
                      write ( 70, 1006 ) !Header for file.
                      1006..format ( 1x, 3x, 'year    ', 2x, 't', 7x, &
                                    'hour', 2x, 'MXle' 6x, &
                                    'b24acl', 4x, 'z1leW', 5x, &
                                    'z2leW', 5x, 'z3leW' )
   fIP_Pcanya = csmall
   fIP_Pcanda = csmall
   !Initialize this to -1:
   imonth_yesterday = -i1 !New statement, 2/07/19. Not yet tested.
      !19/11/2020. Gives monthbeg = .false. on 2nd start at t = 0.
      !Not sure is this matters.  Do not make changes until needed.
              
END !INITIAL


DERIVATIVE
!   PROCEDURAL
!      ilogd = i1
!      CALL LOGD( .true. ) !1
!     This causes the output list to be output to the log files.
!     This did not work without the Procedural statement
!   END

   !The main guts of the program.
   !This block is sorted into executable order when translated, and is 
   !executed every integration interval, maxt.
   !dstop displays the termt conditions.
   !This next block is copied from the terminal block below:
    t_maxt = t - maxt
    tplusmaxt1hr = t + onehourdy
    tplusmaxt = t + maxt
    tplus2maxt = t + two * maxt
    tplus5maxt = t + five * maxt
    tplus10maxt = t + ten * maxt
    tplushalfdy = t + half
    tplus1dy = t + one
    tplus10dy = t + ten
    tplus50dy = t + 50
    tplus65dy = t + 65
    tplus100dy = t + c100
    tplus200dy = t + c200
    tplus300dy = t + 300
    tplus1yr = t + c365
    tplus2yr = t + 730
    tplus5yr = t + 1825
    tplus10yr = t + 3650
   !End of block copied from terminal. 

      !Run termination condition
         termt ( t .GE. tstop &
           .OR. MCSbr .LE. zero &
           .OR. MCSst .LE. zero &
           .OR. MCSco .LE. zero &
           .OR. MCSfi .LE. zero &
           .OR. MNSfi .LE. zero & 
           .OR. Nnit  .LE. zero .OR. Namm  .LE. zero & !all above .gt. zero
           .OR. psifi .GT. psifimax &  !psifimax = 500 J (kg water)-1 = kPa. 
           .OR. Wle   .LT. zero &
           .OR. Wfi   .LT. zero &
           .OR. ( psiPle .LE. psiPle_wilt .AND. s_water .EQ. one ) &
           .OR. hstem .GT. href & !Boundary layer conductance calc fails.
           .OR. ( s_diurnal_dat .EQ. one .AND. &  !gBoundaryLayer        
                  ( zdi_t1t2 .GT. one .OR. t_di2_di1 .LE. zero ) &
                ) & !Fault in diurnal data file (ddf), or end of ddf.
           .OR. imonth_mon2 .EQ. i0 &        !End of many months (mnn) data
                            .AND. monthbeg & !file reached, and end of month. 
           .OR. idaymo_dy .EQ. i0 &          !End of daily data file reached.
          )             
              Constant psifimax = 500.0      !J (kg water)-1 = kPa. 
              Constant psiPle_wilt = -500.0  !J (kg water)-1 = kPa.
              !psiPle_wilt, pressure component of foliage water potential
              !for stopping the simulation.

         !Dump t to tdumpterminal. Used in the terminal section.
            tdumpterminal = t

      
      !Saving variables from last iteration.
         IF ( t .NE. tdump ) THEN
            tdump = t       !Dump the value of t.
            WleLast2Iter = WleLastIter 
            WleLastIter = WleLastIterz ; WleLastIterz = Wle
         ENDIF

!   PROCEDURAL
!      ilogd = i2
!      CALL LOGD( .true. ) 
      !output occurs.
!   END

        !maxt changed during run - recalculations
         !Sometimes maxt is changed during a run, followed by continue.
         !maxt-dependent quantities must be recalculated before continuing.
      IF ( maxt .NE. maxtdump ) THEN 
            maxtdump = maxt                !dump value of maxt.
            halfmaxt = half * maxt         !day.  One half of maxt.
            maxtyear = maxt / c365         !maxt in units of years, only used
                                           !in yearly averages section.
                                           !maxt is d. c365 = d / y.
            halfmaxtyear = halfmaxt / c365 !year. One half of maxt, in years.
            maxtsec = maxt * c86400        !maxt in seconds, only used in
                                           !daily and yearly averages sections.
            maxtmin = maxt * c1440         !maxt in minutes
            twomaxt = maxt + maxt          !d. 2 * maxt
   
           !To extract 12.00 hour quantities, we use
              t12h1 = half - halfmaxt  !day. Time of day just before 12.00 h.
              t12h2 = half + halfmaxt  !day. Time of day just after  12.00 h.
              !Search <12h>, or <1Jul12h>.
   
            !To extract 15.00 hour quantities, we use
               t15h1 = c0x625 - halfmaxt  !day. !Time of day just before 15 h.
               t15h2 = c0x625 + halfmaxt  !day. !Time of day just after 15 h.
               !Search <15h>, or <1Jul15h>.
   
         !Thinning
            !Calculation of the kthin from the fst_rem_th.
            !The calculation depends on the value of maxt.
            !The rate constant, kthin (day-1), applied to nstems is in
            ! ARRAY kthin ( 15 ).
            !Fractions of stem numbers removed by thinning, fst_rem_th , 
            !are removed during time, tau_thin (days),
            !the time taken for each thinning to occur.
               !Constant tau_thin = 1 !day.
               maxt_D_tau_thin = maxt / tau_thin 
   
              !denmaxt = maxt !maxt appears as a denominator. This is to help 
                                 !with debugging. d den* gives denominators.
            DO kthin_loop_Deriv iz = 1, nthinmax 
               kthin ( iz ) = ( one - &
                              ( one - fst_rem_th ( iz ) ) &
                                      ** maxt_D_tau_thin &
                              ) / maxt 
            kthin_loop_Deriv..CONTINUE

      ENDIF ! IF ( maxt .NE. maxtdump ) THEN of maxtdump section for changes
               !in maxt within a simulation.


   !Pruning changed during a run. Recalculate pruning rate constants.
      !Sometimes fraction pruned, fpruneyr, is changed during a run, 
      !followed by continue.
      !Above statement not true.  Pruning is not applied in the aphid runs.
      !If so, the k??prune need to be re-calculated before continuing.
      !ie: kle_prune etc for le is replaced by br, st, co, fi.
      Constant fpruneyr = 0.0 !year-1. Fraction pruned per year. 
              !Default value is 0% per year, continuous pruning.
      IF ( t .EQ. zero .OR. fpruneyr .NE. fpruneyrdump ) THEN 
           fpruneyrdump = fpruneyr  !dump value of fpruneyr.
              !Calculate the per day rate constants (day-1):
                    log_fpruneyr = - LOG ( one - fpruneyr )  !one = 1.0.
                   !This a a good approximation over 1 year, because there
                   !are many maxt in a year.  See kthin calculation, which
                   !does not use this approximation because thinning occurs
                   !over 1 day.
              kprune = log_fpruneyr / c365 !day-1. Pruning rate constant.
              kle_prunez = kprune          !day-1. Foliage pruning rate.
              kbr_prunez = kprune          !day-1. Branches pruning rate.
              kst_prunez = zero            !day-1. Stem pruning rate.
              kco_prunez = zero            !day-1. Coarse roots pruning rate.
              kfi_prunez = zero            !day-1. Fine roots pruning rate.
         fpruneyr_chk = one - ( one - kprune * maxt ) ** ( c365 / maxt )     
    !This should be approximately but rather accurately = fpruneyr. OK.
         !Initialize here at t = 0
         fIP_Pcanya = csmall
         fIP_Pcanda = csmall !An easily recognizable small number 7.7777D-17
            !Otherwise it has a big value (c. 1**18 at year = 0).
      ENDIF !'IF ( t .EQ. zero .OR. fpruneyr .NE. fpruneyrdump ) THEN' block

!CALL LOGD(.TRUE.)

!TIME
   !Time t is in days.  t = 0 at 00.00 hours on the first day of January.
      INTEGER tint, iday, iyear, yearno, nmaxt
         tint = INT ( t + halfmaxt )  !Integer value of t.
         iday = tint + 1  
               !iday is 1 on 1 Jan., and takes integer values, 2, 3, 4, ...
         year = t / c365  !Decimal year, runs from 0.0 upwards.
         iyear = INT ( year + halfmaxtyear )  !Integer part of year. 
                      !iyear = 0 during the first year.
         yearno = iyear + 1                   !Number the years, from 1.
         yeardec = year - iyear !Decimal fraction of current year.
         yearangle = twopi * yeardec     !Radians 0 to 2pi.
         yearangledeg = c360 * yeardec   !Degrees 0 to 360.
         IF ( maxt .NE. zero ) THEN
              nmaxt = INT ( ( t + halfmaxt ) / maxt )  !nmaxt gives an 
         ELSE                                          !integer count of
              nmaxt = ilarge                           !the number of maxt
         ENDIF                                         !in the current time.


   !Year of current rotation:
      Dyear_accum_rot = s_rotate / c365 
       year_accum_rot = INTEG( Dyear_accum_rot, year_accum_rot0 )
          yr_acc_rot = year_accum_rot !For output only.
       INTEGER iyear_accum_rot
       IF ( s_rotate .EQ. one ) &
               iyear_accum_rot = INT( year_accum_rot + halfmaxt )

   !Decimal time of day, tdec, with 0 <= tdec < 1:
      tdec = t + one - iday !day.
         !NB: do not confuse dec indicating decimal with dec meaning
         ! (solar) declination.
   !Hour of the day, hour, with 0 <= hour < 24:
      INTEGER ihour
      hour =  c24 * tdec !hours.
      hour_r = c24 * t                     !hours. Running hours.
      ihour = INT ( hour + csmall )        !integer hour.
   !Minutes:
      INTEGER iminute
      minute = c60 * ( hour - ihour )      !Minutes (decimal).
      iminute = INT ( minute + csmall )    !Minutes (integer).
   !Hour angle of sun.
      !Hour angle of sun is the angle on a horizontal plane between the sun
      !and the local meridian:  At noon the hour angle is 0.
            Constant tnoon = 0.5 !day. Decimal time of day at local noon.
         time_after_noon = tdec - tnoon    !day. 0 at noon when tdec = 0.5 d. 
         hourangle = twopi * time_after_noon     !radians.
         hourangledeg = c360 * time_after_noon  !degrees.
         sin_hourangle = SIN( hourangle )
         cos_hourangle = COS( hourangle )
         sincos_hourangle = sin_hourangle * cos_hourangle
   


!CALL LOGD(.TRUE.)
!ONCE-A-YEAR BLOCK
   !Block has statements implemented at the beginning of each year:
   !In the Initial Section the counter, iyearcount, which counts 
   !the years, is initialized to 0, with every start.
      IF ( iyearcount .EQ. iyear ) THEN !A new year is beginning.
         !Execute following block at the beginning of the year.
            LOGICAL yearbeg
            yearbeg = .TRUE. ! Flags the beginning of a new year;

            IF ( t .GT. zero ) THEN
                 year_accum = year_accum + i1 
                !Do not add 1 at t = 0.
            ENDIF

            IF ( year .GT. zero ) THEN
                 log10year = LOG10( year )
            ELSE
                 log10year = zero
            ENDIF

       !If climate data has been read in, and interpolated to give
            !yearly data (see Initial Section), then we wish to calculate
            !the actual current year (eg 1998), year_calendar, 
            !and an index, year_index,
            !for use when addressing the interpolated yearly climate data.
               INTEGER year_calendar, year_calendar_di, year_index, &
                       year_cal, year_cal_di
               year_calendar = iyearcd_A(1) + one_s_rotate * iyear &
                               + s_rotate * iyear_accum_rot
                  year_cal = year_calendar !For output only.
                  !The actual year. eg 1903. 
                  !iyearcd_A(1) is first year in the climate data, eg 1850,  
                  !see file climate.dat.
                  !Search for <climate data> for more information on 
                  !climate data.
               year_index = year_calendar - iyearcd_A1 + i1
               IF (year_index .GT. year_index_max) &
                   year_index = year_index_max
               !This prevent year_index exceeding array limits 
               !when addressing the interpolated climate data, which is in
               !arrays (eg delTcd_int() ), if climate data option is used.

            !Diurnal data used:
               year_calendar_di = year_di0 + iyear
               year_cal_di = year_calendar_di 
               !This is the actual year using the diurnal data input option.
               
               !REWIND diurnal data file.
               !Do we want to rewind the diurnal.dat file?
                  INTEGER nyears_rw_di; Constant nyears_rw_di = 10000 !years.
                  !Rewind the diurnal data file after every
                  !nyears_rw_di years.
                     INTEGER iz_rw_di !Working variable.
                     iz_rw_di = MOD( iyear, nyears_rw_di ) !MOD(x1, x2) is
                        !the remainder of ( x1 divided by x2 ).
                     IF ( s_diurnal_dat .EQ. one .AND. iz_rw_di .EQ. i0 &
                                    .AND. t .NE. zero ) THEN
                        REWIND 50
                       !CHARACTER linedumpdi * 120 
                                  !Dump for line of characters.
                        READ (50, *) linedumpdi; READ (50, *) linedumpdi
                        READ (50, *) linedumpdi
                        READ (50, *) linedumpdi; READ (50, *) linedumpdi
                        READ (50, *) linedumpdi; READ (50, *) linedumpdi
                           !The next read statement reads in the first data
                           !line from the rewound data file.
!                       READ (50, *) minute_di2, hour_di2, day_di2, &
!                          month_di2, &
                        READ (50, *)             hour_di2, day_di2, &
                           month_di2, &
                           JulianDy_di2, year_di2, PAR_di2, Tair_di2, &
                           Tsoil_di2, rain_di2, wind_di2, RH_di2
                        t_di2 = ixtra_days_rw_di + &
                        ( year_di2 - year_di0 ) * c365 + JulianDy_di2 - one &
                       + hour_di2 / c24 !+ minute_di2 / c1440  !NOTA BENE.

                        !Every time we rewind, we lose nyears_rw_di years
                        !from the time of the lines of data which are read in.
                        !We must put these back, by adding
                        INTEGER ixtra_days_rw_di
                        ixtra_days_rw_di = ixtra_days_rw_di &
                                           + i365 * nyears_rw_di 
                     ENDIF
                       !End of REWIND diurnal data file section which began
                       !with: !IF ( s_diurnal_dat .EQ. one .AND. iz_rw_di .EQ.
!   PROCEDURAL
!      ilogd = i3
!      CALL LOGD( .true. ) !3
      !output occurs.
!   END

            !Budburst (bb):
               !This is only allowed to occur once per year.
                  bb_notthisyr = .true. !Reset this to true
                        !at the beginning of each year.
                  LOGICAL bb_notthisyr

            !Leaf fall (lf):
               !This is only allowed to once per year.
                  lf_notthisyr = .true. !Reset this to true
                        !at the beginning of each year.
                  LOGICAL lf_notthisyr

         iyearcount = iyearcount + 1  !Increment the year counter

      ELSE !It is not the beginning of a year.
         yearbeg = .FALSE.
      ENDIF  !of once-a-year statements, which began with: 
      !IF ( iyearcount .EQ. iyear ) THEN !A new year is beginning.


!CALL LOGD(.TRUE.)

!ONCE-A-DAY BLOCK
   !Executed at beginning of each day, concerned with environment quantities
   !which vary from day to day through the year, and depend on parameters
   !in the preceding environmental parameters block. 

   INTEGER iJulian_1, ijulian, ijulian306, imonth, idaymo
   LOGICAL daybeg  !True at the beginning of a new day. Otherwise false.

   IF ( ( idaycount + i1 ) .EQ. iday ) THEN
      !Execute the daily routine at 0 hour.
      daybeg = .TRUE.  ! Flags the beginning of a new day;

      idaycount = idaycount + 1  !Increment the counter.
     
      !Time and the calendar:
         iJulian_1 = tint - i365 * iyear !Julian day number - 1,
                                       !running from 0 to 364.
         !Weeks.
            INTEGER iweek, iweekyr 
            iweek = i1 + tint / i7    !Count weeks, starting at 1, 2, ...
            iweekyr = i1 + iJulian_1 / i7 !Count weeks of the year, 1..52.

         iJulian = iJulian_1 + i1           !The Julian day of the year, 
                                            !starting at 1 running up to 365.
         iJulian306 = iJulian + 306
         IF ( iJulian306 .GT. i365 ) iJulian306 = iJulian306 - i365
         !The month of the year:
               INTEGER imonth_yesterday
               imonth_yesterday = imonth !Store the month yesterday.
            imonth = INT ( ( iJulian306 + 91.3 ) / 30.6 )  
         !The day of the month:
            idaymo = INT ( iJulian306 - 30.6 * imonth + 92.3 )  
         IF ( imonth .GE. 13 ) imonth = imonth - i12

         LOGICAL monthbeg; 
         IF ( imonth .NE. imonth_yesterday ) THEN
              monthbeg = .TRUE. ! Flags the beginning of a new month
         ELSE
              monthbeg = .FALSE.
         ENDIF

         !Fractional month, runs from 0 to 12 
            !(assuming all months are of equal length):
            month = ( t - iyear * i365 ) * c12 / c365  
       
         !Running month, runs from 0 to tstop x 12 / 365:
               month_r = t * c12 / c365
              !(again assuming all months are of equal length)
      !Daily environmental data input
      !Daily environmental data input, day-by-day, from file daily.dat or 
         !from a named file (see <filenamedy> above):
         !Constant s_daily_dat = 0.0, default value, declared above.
            INTEGER imonth_dy, iJulian_dy, iyear_dy
            iyear_dy = 7777 !This is given a value because it is used in
                            !a daily data output statement, even when
                            !daily data is not input (in which case it
                            !would remain undefined.
         IF ( s_daily_dat .EQ. one ) & !Read in daily data from daily.dat
            READ (50, *) &
            idaymo_dy, imonth_dy, iJulian_dy, iyear_dy, &
            MJ_PARdy_dy, Tairmax_dy, Tairmin_dy, Tsoil_dy, &
            rain_mm_dy, wind_dy, RHmax_dy, RHmin_dy, &
            INenv_Namm_mg_dy, INenv_Nnit_mg_dy
         !Put these into the right units for the program:
            jPARdy_dy = c1E6 * MJ_PARdy_dy           !J PAR m-2 day-1.
            rain_dy = rain_mm_dy / c1000             !m day-1.
            windmax_dy = wind_dy * ( one + fwind_daily_vr )
            windmin_dy = wind_dy * ( one - fwind_daily_vr )
              !fwind_daily_vr = 0.8 Fractional daily variation in wind speed.
            INenv_Namm_dy = c1E_6 * INenv_Namm_mg_dy !kg Namm N m-2 day-1.
            INenv_Nnit_dy = c1E_6 * INenv_Nnit_mg_dy !kg Nnit N m-2 day-1.


!CALL LOGD(.TRUE.) 
      !Monthly environmental data input over many years 
             !and interpolation
         !This section reads in monthly data, month by month, over possibly
         !many years. Linear interpolation gives daily data.

         !Variables used for the monthly data input from the monthly data
         !file are (eg see file monthsnn.dat):
            INTEGER iyear_mon1, iyear_mon2
               !Integer year number (eg 1902).
            INTEGER imonth_mon1, imonth_mon2
               !Integer month number. Should always be in range 1 to 12.
            !rain_mon1, rain_mon2
               !Average monthly precipitation in mm/day.
            !Tmax_mon1, Tmax_mon2, Tmin_mon1, Tmin_mon2 
               !Average daily max and min temperatures.
            !ShortWaveRad_Wm_2_mon1, ShortWaveRad_Wm_2_mon2.
               !dswf. This is (I think), daily short wave flux (400-1500 nm),
               !in W/m2, averaged over 24 h. PAR is half this value.
               !See Monteith & Unsworth: Principles of Environmental Physics
               !(1990), Table 4.1, page 38.
            !RHmaxz_mon1, RHmaxz_mon2, RHminz_mon1, RHminz_mon2
               !Average of am, pm RH observations (%).
            !wind_mon1, wind_mon2
               !Windspeed, m/s, daily average, measured maybe at the standard
               !meteorological height of 1.5 m (?).  However, the numbers
               !in the files from Maureen do seem to be far too high for this.
            !Days per month (no leap years). Declared above.
            !The efm does not take any account of leap years.
               !Constant days_per_month = 31, 28, 31,   30, 31, 30, &
               !                          31, 31, 30,   31, 30, 31
            !Value of time variable t at midpoint of each month:
               !15.5,   45,   74.5,  105, 135.5, 166, &
               !196.5, 227.5, 258,   288.5, 319, 349.5 for information.
            !Julian midpoint month. Declared above. Not necessarily an integer.
               !Add 0.5 to time t of midpoint of the month (e.g. 15.5 for Jan)
               !to get a Julian midpoint of the month.  For Jan this is
               !16 Jan, with 15 days before and 15 days after.
               !For Feb, there is no integer midpoint day.
               !Constant Jmpm =  16,  45.5, 75,    105.5, 136, 166.5, &
               !                197, 228,  258.5,  289, 319.5, 350
               !1st day of each month using Julian counting (declared above).
                  !Constant J1st_day_mon = 1, 32, 60,   91, 121, 152, &
                  !                        182, 213, 244,  274, 305, 335
!CALL LOGD(.TRUE.)
         IF ( s_monthsnn_dat .EQ. one ) THEN
            Jmpmz = Jmpm( imonth )
                   !Working variable. Julian day for midpoint of month.
            LOGICAL bool_mnn 
            bool_mnn = ( ( ( t .EQ. zero .AND. irotate .GT. ilarge ) .OR. &
                         ( iJulian .GE. Jmpmz .AND. &
                                  imonth .EQ. imonth_mon2 ) ) )
            IF ( bool_mnn ) THEN
               !time = 0 and we are beginning the 1st start, or, 
               !we are halfway or more through the current month and we
               !have not yet read in values for the next month.
!CALL LOGD(.TRUE.)
                !Shift *_mon2 into *_mon1:
                   iyear_mon1 = iyear_mon2
                   imonth_mon1 = imonth_mon2
                   rain_mon1 = rain_mon2
                   Tmax_mon1 = Tmax_mon2
                   Tmin_mon1 = Tmin_mon2
                   jPARdy_mon1 = jPARdy_mon2
                   RHmax_mon1 = RHmax_mon2 
                   RHmin_mon1 = RHmin_mon2 
                   wind_mon1 = wind_mon2
                !and read in the next month's data into *mon2:
                   READ (51, *) &
                      iyear_mon2, &
                      imonth_mon2, &
                      rainz_mon2, &              !mm/day
                      Tmax_mon2, &
                      Tmin_mon2, &
                      ShortWaveRad_Wm_2_mon2, & !W/m2 400-1500 nm over 24 h.
                      RHmaxz_mon2, &              !percent
                      RHminz_mon2, &              !percent
                      wind_mon2                   !m/s.

                !Change units where needed:
                   rain_mon2 = roW * rainz_mon2 / c1000
                                                     !kg water m-2 day-1.
                                       !Note: here roW = 1000 kg water m-3.
                   jPARdy_mon2 = ShortWaveRad_Wm_2_mon2 * c86400 / rSWR_PAR
                                       !J PAR m-2 day-1. Monthly average.
                                 Constant rSWR_PAR = 2
                           !Ratio of short-wave radiation to PAR.
                           !Half of the short-wave radiation (400-1500 nm)
                           !is PAR (400-700 nm).
                   RHmax_mon2 = c0x01 * RHmaxz_mon2
                   RHmin_mon2 = c0x01 * RHminz_mon2 !RH is in range 0 to 1.
!CALL LOGD(.TRUE.)
            ENDIF !IF ( bool_mnn ) THEN block.

            IF ( iJulian .LT. 16 .AND. &
                                  imonth_mon1 .EQ. 555555333 ) &
            THEN
!CALL LOGD(.TRUE.)
                  !Place the monthly averages directly into _mnn because we
                  !are in the first half of January of the first year of data.
                  !We cannot interpolate. Assume constant values.
                     iyear_mnn = iyear_mon2
                     imonth_mnn = imonth_mon2
                     rain_mnn = rain_mon2
                     Tmax_mnn = Tmax_mon2
                     Tmin_mnn = Tmin_mon2
                     jPARdy_mnn = jPARdy_mon2
                     RHmax_mnn = RHmax_mon2 
                     RHmin_mnn = RHmin_mon2 
                     wind_mnn = wind_mon2
            ELSE IF ( imonth_mon2 .EQ. i0 ) THEN
                  !We have read in the last month of data in the file.
                  !Again we cannot interpolate.  Assume constant values.
                     iyear_mnn = iyear_mon1
                     imonth_mnn = imonth_mon1
                     rain_mnn = rain_mon1
                     Tmax_mnn = Tmax_mon1
                     Tmin_mnn = Tmin_mon1
                     jPARdy_mnn = jPARdy_mon1
                     RHmax_mnn = RHmax_mon1 
                     RHmin_mnn = RHmin_mon1 
                     wind_mnn = wind_mon1
            ELSE
                  !Interpolation function. Interpolate using:
                  IF ( imonth_mon1 .EQ. i12 ) THEN !We are in the last half
                                 !of December or the first half of January.
!CALL LOGD(.TRUE.)
                     IF ( imonth .EQ. i12 ) THEN !last half of December.
                           denm_interp = ( Jmpm ( imonth_mon2 ) + &
                                      i365 - Jmpm ( imonth_mon1 ) ) !Debug aid.
                        m_interp = ( iJulian - Jmpm ( imonth_mon1 ) ) / & 
                                   ( Jmpm ( imonth_mon2 ) + i365 - &
                                     Jmpm ( imonth_mon1 ) )
                     ELSE !imonth = 1. ie 1st half of January.
                            denm_interp = ( Jmpm ( imonth_mon2 ) + &
                                 i365 - Jmpm ( imonth_mon1 ) ) !Debug aid.
                        m_interp = ( iJulian + i365 - &
                                     Jmpm ( imonth_mon1 ) ) / & 
                                   ( Jmpm ( imonth_mon2 ) + i365 &
                                     - Jmpm ( imonth_mon1 ) )
                     ENDIF
                  ELSE !We are in some other part of the year.
                            denm_interp = ( Jmpm ( imonth_mon2 ) &
                                      - Jmpm ( imonth_mon1 ) ) !Debug aid.
                        m_interp = ( iJulian - Jmpm ( imonth_mon1 ) ) / & 
                        ( Jmpm ( imonth_mon2 ) - Jmpm ( imonth_mon1 ) )
                  ENDIF !Interpolation function.

               !Now interpolate:
                  IF ( yearbeg )   iyear_mnn = iyear_mon2
                  IF ( monthbeg ) imonth_mnn = imonth_mon2
                  rain_mnn = rain_mon1 + ( rain_mon2 - rain_mon1 ) &
                                              * m_interp
                  Tmax_mnn = Tmax_mon1 + ( Tmax_mon2 - Tmax_mon1 ) &
                                              * m_interp
                  Tmin_mnn = Tmin_mon1 + ( Tmin_mon2 - Tmin_mon1 ) &
                                              * m_interp
                  jPARdy_mnn = jPARdy_mon1 + ( jPARdy_mon2 - jPARdy_mon1 ) &
                                              * m_interp
                  RHmax_mnn = RHmax_mon1 + ( RHmax_mon2 - RHmax_mon1 ) &
                                              * m_interp
                  RHmin_mnn = RHmin_mon1 + ( RHmin_mon2 - RHmin_mon1 ) &
                                              * m_interp
                  wind_mnn = wind_mon1 + ( wind_mon2 - wind_mon1 ) &
                                              * m_interp
            ENDIF !IF ( iJulian .LT. 16 .AND. &
                  !               imonth_mon1 .EQ. 555555333 ) THEN block.

                  windmax_mnn = ( one + fwind_daily_vr ) * wind_mnn
                  windmin_mnn = ( one - fwind_daily_vr ) * wind_mnn
                                Constant fwind_daily_vr = 0.8
                 !Wind varies from 0.2 to 1.8 of its mean daily value.
         ENDIF !IF ( s_monthsnn_dat .EQ. one ) block.

!CALL LOGD(.TRUE.)
      !Astronomy
      !Solar declination.
         !is the angle between the line joining the
         !sun and the earth, and the equatorial plane of the earth.
         !The solar declination is (in degrees):
             solar_dec_deg = 23.45 * SIN( twopi * ( iJulian - 81 ) / c365 )
                soldec_deg = solar_dec_deg !Output only.
         !Solar declination in radians is:
             solar_dec = c2pi360 * solar_dec_deg  !c2pi360 = 2 * pi / 360
             sin_solar_dec = SIN( solar_dec )
             cos_solar_dec = COS( solar_dec )
             tan_solar_dec = TAN( solar_dec )
             sincos_solar_dec = sin_solar_dec * cos_solar_dec

      !Solar elevation at noon (eqn A7.1, Jones, p. 362, with
         ! h = 0):
             sin_latitudeXsin_solar_dec = sin_latitude * sin_solar_dec
             cos_latitudeXcos_solar_dec = cos_latitude * cos_solar_dec
             cos_latitudeXcos_solar_decsq = cos_latitudeXcos_solar_dec &
                                          * cos_latitudeXcos_solar_dec
             sin_solar_elevation_noon = &
                               sin_latitudeXsin_solar_dec &
                             + cos_latitudeXcos_solar_dec
             solar_elevation_noon = ASIN( sin_solar_elevation_noon ) !rad.
             solar_elevation_noon_deg = solar_elevation_noon / c2pi360
                soelnn_deg = solar_elevation_noon_deg !Output only.

      !Day length (day) (c24pi = 24 / pi = 2*24 / 2*pi ):
                  arg_daylength = - tan_latitude * tan_solar_dec
                  IF ( arg_daylength .GT. one ) THEN !Sun does not rise.
                     daylengthhrz = c1E_6     !There are some "/ daylength"
                                !in the program, so avoid failure / zero. 
                  ELSE IF ( arg_daylength .LT. -one ) THEN !Midnight sun.
                     daylengthhrz = c24       !24 hour daylight.
                  ELSE                        !0 < daylengthhr < 24.
                     acos_arg_daylength = ACOS( arg_daylength )
                     daylengthhrz = c24pi * acos_arg_daylength !Daylength
                  ENDIF                                        !(hrs).
         daylengthhr = s_seasonal * daylengthhrz &
                  + ( one - s_seasonal ) * c12  !Daylength (hrs).
            daylenhr = daylengthhr   !Output only.
         daylengthsc = c3600 * daylengthhr      !Daylength (secs).
         daylength_yday = daylength             !Save yesterdays daylength.
         daylength = daylengthhr / c24          !Daylength  (day).
         halfdaylength = half * daylength       !Half daylength (day).

      !Dawn and dusk
         !Assuming that solar noon is at 12.00 hours, then
         tdawn =  half * ( one - daylength ) !d; time of dawn (sunrise).
          ! 0 le tdawn lt 1
            tdawn_epsilon = tdawn - c1e_6  
               !Working variable - to make the lights come
               !on at the right time; see light_on = PULSE statement below.
         tdusk =  one - tdawn   !d.  Time of dusk (sunset).
          ! 0 le tdusk lt 1

         tdawnhr = c24 * tdawn  !hours. Time of dawn.
         tduskhr = c24 * tdusk  !hours. Time of dusk.
         !To extract dawn quantities, we use
            tdawn1 = tdawn - halfmaxt  !day. Time of day just before dawn.
            tdawn2 = tdawn + halfmaxt  !day. Time of day just after  dawn.

      !Solar azimuth at dawn, solar_azimuth_dawn (radians).
      !Solar azimuth at dusk, solar_azimuth_dusk (radians).
         tdawn_after_noon = tdawn - tnoon !d. Usually < 0
         tdusk_after_noon = tdusk - tnoon !d. Usually > 0
                 !Assume tnoon = 0.5 (constant), to that
               Constant hourangle_noon = 0 !Not used anywhere in the program.
         hourangle_dawn = twopi * tdawn_after_noon        !radians.
         hourangle_dawn_deg = hourangle_dawn / c2pi360   !degrees.
         hourangle_dusk = twopi * tdusk_after_noon        !radians.
         hourangle_dusk_deg = hourangle_dusk / c2pi360   !degrees. 
         cos_solar_azimuth_dawn1 = - sin_solar_dec / cos_latitude
            IF ( cos_solar_azimuth_dawn1 .GT. one ) THEN 
                 cos_solar_azimuth_dawn = one
            ELSE IF ( cos_solar_azimuth_dawn1 .LT. minus_one ) THEN 
                 cos_solar_azimuth_dawn = minus_one
            ELSE
                 cos_solar_azimuth_dawn = cos_solar_azimuth_dawn1
            ENDIF
         solar_azimuth_dawn1 = ACOS( cos_solar_azimuth_dawn )    !radians.
         solar_azimuth1_deg_dawn = solar_azimuth_dawn1 / c2pi360 !degrees.
                                                            !2 * pi / 360.
      !Sign of azimuth angle
         !Now make sure that the sign of the azimuth angle
         !equals the sign of the hour angle.
            solar_azimuth_dawn = SIGN ( solar_azimuth_dawn1, hourangle )
                                                                !radians.
            solar_azimuth_dawn_deg = solar_azimuth_dawn / c2pi360  !degrees.

      !Southern hemisphere
         !If latitude is negative (southern hemisphere), then we prefer to
         !define solar_azimuth as the angle between the sun and the
         !south-north direction (observer looking north).  Therefore
            IF ( latitude .LT. zero ) THEN
               solar_azimuth_dawnS_N1 = - solar_azimuth_dawn - pi
               solar_azimuth_dawnS_N1_deg = - solar_azimuth_dawn_deg - c180
               IF ( solar_azimuth_dawnS_N1 .LT. (- pi) ) THEN
                    solar_azimuth_dawnS_N = solar_azimuth_dawnS_N1 + twopi
                    solar_azimuth_dawnS_N_deg = solar_azimuth_dawnS_N1_deg &
                                                + c360
               ELSE IF ( solar_azimuth_dawnS_N1 .GT. pi ) THEN
                    solar_azimuth_dawnS_N = solar_azimuth_dawnS_N1 - twopi
                    solar_azimuth_dawn_degS_N = solar_azimuth_dawnS_N1_deg&
                                                - c360
               ELSE
                    solar_azimuth_dawnS_N = solar_azimuth_dawnS_N1
                    solar_azimuth_dawnS_N_deg = solar_azimuth_dawnS_N1_deg
               ENDIF
            ENDIF


      !Carbon dioxide concentration in air, CO2vpm (volumes per million
      !volumes):
      IF ( s_cd .EQ. zero ) THEN !Climate data file not used, eg climate.dat
         !Put these statements procedurally:
             CO2inc_cc = s_CO2cc * CO2inc_yr * ( year - yrsCO2offset )
             CO2vpm = CO2inc_cc + CO2vpmcz  !where CO2vpmcz is a constant.

           !If s_CO2cc = 0 (default), CO2vpm remains constant at CO2vpmcz,
                                    ! = CO2vpmc = 350.
           !If s_CO2cc = 1, then CO2vpm increases linearly over the years
               !by CO2inc_yr (3) vpm per year. yrsCO2offset = 0 years.
      ELSE !(s_cd .NE. zero). Climate change data file is used.
            CO2vpm_cd = CO2cd_int ( year_index ) 
                                               !obtained by interpolation.
            CO2vpm = CO2vpm_cd
      ENDIF

         !The actual CO2 concentration, CO2air (kg CO2 m-3), is calculated
         !below, since it varies diurnally with air temperature.

      !Atmospheric pressure. AtmP (Pa).  Daily value from interpolated
         !value, AtmP_int (Pa), from monthly CLINO data.
            AtmP = AtmP_int ( iJulian ) ! AtmP_int ( iJulianCLINO ) =

      !Radiation; bright sunshine hours
         !Radiation from interpolated bright sunshine hours
            !Calculate radiation from interpolated bright sunshine hours,
               !bshrs_int (iJulian), is the actual fraction of bright sunshine
               !hours interpolated from monthly data if the switch
               !s_months12_dat = 1 or s_CLINO_dat = 1.
            IF ( s_months12_dat .EQ. one .OR. s_CLINO_dat .EQ. one ) THEN 
               !Fraction of possible bright sunshine hours is then
                  fbshrs_monthly = bshrs_int ( iJulian ) / daylengthhr
                  !Angstrom eqn (eg Jones, H.G., 1992. Plant and Microclimate.
                  !Cambridge. Pp. 21-24, 363). Although we don't follow his
                  !recipe.
               !Quantity in [ ] in eqn 2.8, Jones, p. 21:
                  arg_Angstrom = a_Angstrom + b_Angstrom * fbshrs_monthly
                    !fbshrs_monthly is the fraction of bright sunshine hours
                    !interpolated from the monthly data (Fig. 7).
   
               !Instantaneous radiation at noon (last eqn on p. 363 of Jones)
                  !for a transparent atmosphere on a horizontal surface:
                  j_Angstrom_noon = solar_constant * sin_solar_elevation_noon
                                                                    !J m-2 s-1.
               !Daily light receipt via the Angstrom formula 
               !is (J PAR m-2 day-1):
                  jPARdy_Ang = arg_Angstrom * fAngstrom_PAR & 
                               * j_Angstrom_noon * daylengthsc 
                     !fAngstrom_PAR is a fudge factor (0.28) to convert the
                     !Angstrom-
                     !derived figure to PAR.  daylengthsc is the day length
                     !in seconds.  See above (search <fAngstrom_PAR>).
            ENDIF ! IF ( s_months12_dat .EQ. one .OR. s_CLINO_dat .EQ. one )


      
         !Daily light receipt, PAR, jPARdy (J m-2 day-1):
            jPARdy_yday = jPARdy 
                         !Remember yesterday s value of jPARdy (cf jPARscda).
            jPARdy = m_PAR * &
                (  one_s_months12_dat * one_s_daily_dat & 
                        * one_s_CLINO_dat * one_s_monthsnn_dat * ( &
                        jPARdymn + s_seasonal * jPARdyvar * &
                        SIN( c2pi365 * ( iJulian - tjPAR ))      ) &
                   + s_daily_dat * jPARdy_dy  &
                   + ( s_months12_dat + s_CLINO_dat ) * jPARdy_Ang & 
                   + s_monthsnn_dat * jPARdy_mnn &
                )
            Constant m_PAR = 1 !PAR multiplying factor to allow say for
               !putting the crop into chambers that give partial shading.
            jPARdye_6 = jPARdy * c1E_6                   !MJ PAR m-2 day-1.
      
         !Mean light flux density (PAR) during the light period is
            !(taking a step approximation to light flux density):
            jPARscmn = jPARdy / daylengthsc  !J (PAR) m-2 s-1.
            jPARscmn_Moles = jPARscmn * 4.6e-9  !kg moles (m2 ground)-1 s-1.
               !1 kg mol of PAR is equivalent to 0.22e9 J PAR.
               !1 kg mol is 1000 * 1 gram mol (SI mol is a gram mol).
               !1 SI mol of PAR is equivalent to 0.22e6 J PAR.  
               !1 J PAR is equivalent to 4.6e-6 SI mole of PAR.

         !Daily fraction of bright sunshine hours, fbshrs:
            fbshrs =  one_s_months12_dat * one_s_CLINO_dat * ( &
                               fbshrsmean + s_seasonal * fbshrsvar &
                               * SIN( c2pi365 * ( iJulian - tfbshrs ) ) ) &
                      + ( s_months12_dat + s_CLINO_dat ) * fbshrs_monthly 

      !Mean daily air and soil temperatures (deg C)
         !Climate change (cc) effects on temperature parameters:
            !If s_Tcc = 0 (default value), no gradual increase in temperature.
            !If s_Tcc = 1, then temperatures increase slowly due to climate
               !change (cc) by Tinc_yr oC year-1.
            !Actual climate change temperature increase (oC) is: 
               Tinc_cc = s_Tcc * Tinc_yr * ( year - yrsToffset ) 
            Tairmaxmnz1 = Tairmaxmnz  +  Tinc_cc
            Tairminmnz1 = Tairminmnz  +  Tinc_cc
            Tsoilmnz1 = Tsoilmnz  +  Tinc_cc
         !Maximum air temperature of day (15 h): 
               zsin1m = s_seasonal * &
                                SIN( c2pi365 * ( IJulian - tTair ) ) 
                        !working variable.
            Tairmax = one_s_months12_dat * one_s_daily_dat & 
                          * one_s_monthsnn_dat * one_s_CLINO_dat &
                          * ( Tairmaxmnz1 + Tairmaxvr * zsin1m ) &
                        + s_daily_dat * Tairmax_dy &
                        + ( s_months12_dat + s_CLINO_dat ) &
                                     * Tmax_int (iJulian ) &
                        + s_monthsnn_dat * Tmax_mnn
         !Minimum air temperature of day (dawn):
            Tairmin = one_s_months12_dat * one_s_daily_dat &
                          * one_s_monthsnn_dat * one_s_CLINO_dat &
                          * ( Tairminmnz1 + Tairminvr * zsin1m ) &
                        + s_daily_dat * Tairmin_dy &
                        + ( s_months12_dat + s_CLINO_dat ) &
                                     * Tmin_int (iJulian ) &
                        + s_monthsnn_dat * Tmin_mnn
         !Mean air temperature of the day (Tairdymn1):
            Tairdymn1 = half * ( Tairmax + Tairmin ) 
            Tairdymn = Tairdymn1 + Tair_inc
               Constant Tair_inc = 0.0 !deg C. This is to give an easy
                  !way of increasing the value of Tair, for instance if a
                  !treatment to raise Tair 3 deg C above ambient is applied,
                  !or if there is a chamber effect that raises air temp.
   
         !Daily variation from the mean (Tairdyvr):
            Tairdyvr = s_diurnal * half * (Tairmax - Tairmin)
   
         !Soil temperature (soil temperature does not vary diurnally):
               delTemp_cd = delTcd_int(year_index)  
                  !Climate data (interpolated) temperature increment.
                      sszTsoil = s_seasonal * Tsoilvr * &
                          SIN( c2pi365 * ( IJulian - tTsoil ) )
                     !We calculate this so that we can check that the
                     !default (sinusoidal) option is working ok.  ie output
                     !Tsoil, Tsoildyc, sszTsoil
            Tsoildyc = one_s_months12_dat * one_s_daily_dat * &
                       one_s_CLINO_dat * one_s_monthsnn_dat *    ( &
                          Tsoilmnz1 + s_seasonal * Tsoilvr * &
                          SIN( c2pi365 * ( IJulian - tTsoil ) )  ) &
                      + s_daily_dat * Tsoil_dy &
                      + ( s_months12_dat + s_CLINO_dat + s_monthsnn_dat ) &
                             * Tairdymn1 &
                      + s_cd * delTemp_cd + Tsoil_inc
                          !dyc = daily value, constant over a day.
                          !tTsoil = 116 (Eskdale).
   
               Constant Tsoil_inc = 0.0 !deg C. This is to increase
                  !the value of Tsoil, for instance if a treatment to
                  !raise Tsoil 3 deg C above ambient is applied, or
                  !if there is a chamber effect that raises soil temp.
               !When using interpolated monthly data,
                  !it is assumed that soil temperature = mean air temperature.

      !Rain
         !Rain in m day-1:
            rain_m_dy = m_rain * &
                ( one_s_months12_dat * one_s_CLINO_dat * one_s_daily_dat &
                      * one_s_monthsnn_dat * &
                     ( rainmn +  rainvr * s_seasonal * &
                          SIN( c2pi365 * ( IJulian - train ) ) ) &
                  + s_daily_dat * rain_dy &
                  + ( s_months12_dat + s_CLINO_dat ) * rain_int(iJulian) & 
                  + s_monthsnn_dat * rain_mnn / roW &
                )
                Constant m_rain = 1 !Rainfall multiplying factor.
            rainmm = rain_m_dy * c1000       !mm day-1. For output only.
            rainkg = roW * rain_m_dy         !kg water m-2 day-1

      !Relative humidity (RH)
         !Morning relative humidity, RHmax (dawn):
               zsinRH = s_seasonal * &
                        SIN( c2pi365 * ( IJulian - tRH ) ) !working variable.
            RHmax = one_s_months12_dat * one_s_daily_dat * &
                  one_s_monthsnn_dat * one_s_CLINO_dat * &
                         ( RHmaxmn + RHmaxvr * zsinRH ) &
                  + s_daily_dat * RHmax_dy &
                  + ( s_months12_dat + s_CLINO_dat ) * RHmax_int(iJulian) &
                  + s_monthsnn_dat * RHmax_mnn
         !Afternoon relative humidity, RHmin (15 h):
            RHmin = one_s_months12_dat * one_s_daily_dat * &
                  one_s_monthsnn_dat * one_s_CLINO_dat * &
                         ( RHminmn + RHminvr * zsinRH ) &
                  + s_daily_dat * RHmin_dy &
                  + ( s_months12_dat + s_CLINO_dat ) * RHmin_int(iJulian) &
                  + s_monthsnn_dat * RHmin_mnn
         !RH daily mean (RHdymn):
            RHdymn = half * ( RHmax + RHmin )  !Mean of dawn and 15 h values.
         !RH daily variation from RHdymn (RHdyvr):
            RHdyvr = s_diurnal * half * ( RHmax - RHmin )

     !Vapour pressure in Pa:
         VapP = VapP_int( iJulian ) 
 
      !Environmental N deposition
         !This is into soil ammonium and nitrate pools.
            INenv_Namm_cd = Ndepcd_int ( year_index ) 
                                     !kg N m-2 day-1. Interpolated value.
            INen_Na_cd = INenv_Namm_cd !Output only.
               !of N deposition from climate data file, if used (s_cd = 1).
         INenv_Namm = m_Ndep * &
                      ( one_s_cd * one_s_months12_dat &
                        * one_s_monthsnn_dat * one_s_CLINO_dat * ( &
                              one_s_daily_dat * INenv_Nammc &
                      + s_daily_dat * INenv_Namm_dy              ) &
                            + s_cd * INenv_Namm_cd &   !Climate data.
                 + one_s_cd * (   s_months12_dat * INenv_Namm_m12 & 
                                + s_monthsnn_dat * INenv_Namm_mnn &
                                + s_CLINO_dat * INenv_Namm_CLINO &
                              ) &                 !Monthly data files.
                      )                                    !kg N m-2 day-1.
                      Constant m_Ndep = 1 !Multiplier of N deposition input.
         INenv_Nnit = m_Ndep * ( &
                                    one_s_daily_dat * INenv_Nnitc + &
                                      s_daily_dat * INenv_Nnit_dy &
                                  )                        !kg N m-2 day-1.
         INenv_Namm_mg = c1E6 * INenv_Namm                 !mg N m-2 day-1.
         INenv_Nnit_mg = c1E6 * INenv_Nnit                 !mg N m-2 day-1.
         INenv_Nam_mg = INenv_Namm_mg !For output.
         INenv_Nni_mg = INenv_Nnit_mg !For output. 
         INenv_dep = INenv_Namm + INenv_Nnit 
         INenv_Namm_hayr = INenv_Namm * c3650000  !kg N ha-1 year-1.
            INenNa_hayr = INenv_Namm_hayr !Output only.
         INenv_Nnit_hayr = INenv_Nnit * c3650000  !kg N ha-1 year-1.
         INenv_dep_hayr = INenv_dep * c3650000    !kg N ha-1 year-1.
         INen_dp_hayr = INenv_dep_hayr !For output only.

      !Diurnal temperature wave times for air temperature
         tTairmn1 = half * (one + tdawn + c0x625) !days. This is the time
            !when the diurnal temperature wave is at its mean value
            !between 00.00 h  and dawn, assuming
            !that the minimum air temperature occurs at dawn, and the
            !maximum occurs 3 hours (0.125 day) after solar noon (0.5 day).
         tTairmn2 = half * ( tdawn + c0x625 ) !days.
            !Time when diurnal air temperature wave is at its mean value,
            !between dawn (minimum) and 15.00 h (maximum).
         tTairmn3 = tTairmn1 ! = half * ( c0x625 + one + tdawn )
            !Time when diurnal air temperature wave is at its mean value,
            !between 15.00 h (maximum) and dawn (minimum).
         tauTair1 = two * ( one - c0x625 + tdawn )  !days; the period of
            !the diurnal air temperature wave between midnight
            !and dawn.  Maximum occurs at (15 h) c0x625 day the previous day,
            !ie, (1.0 - 0.625) day before midnight. Minimum occurs at
            !tdawn, ie, tdawn after midnight.  Add these together and
            !multiply by 2. 
             dentauTair1 = tauTair1 !Used as a denominator.
         tauTair2 = two * ( c0x625 - tdawn )  !days; the period of
            !the diurnal air temperature wave between dawn (minimum)
            !and the maximum at 15.00 h, or t = n.625 d.
             dentauTair2 = tauTair2 !Used as a denominator.
         tauTair3 = tauTair1 ! = 2.0 * ( one - c0x625 + tdawn ) days;
            !period of air temperature wave between 15.00 h and 24.00 h.
         !The mean air temperature for the day is equal to
         !Tairdymn calculated above [0.5 * (max + min) + Tair_inc],
         !because of our
         !assumptions made in calculating the air temperature wave: that the
         !maximum on the preceding day and the minimum on the following day
         !are the same as they are on the present day.
          dentauTair3 = tauTair3 !Used as a denominator.

      !Wind speed
         !Interpolated mean daily wind speed from CLINO data is 
            !wind_int ( iJulian ).  We need to calculate the daily maximum
            !and daily minimum. For this use
               windmax_CLINO = ( one + fwind_daily_vr ) &
                               * wind_int ( iJulian )
               windmin_CLINO = ( one - fwind_daily_vr ) &
                               * wind_int ( iJulian )
                              !Constant fwind_daily_vr = 0.8
                 !Wind varies from 0.2 to 1.8 of its mean daily value.

         !Climate change effects on wind speed parameters:
            !If s_windcc = 0 (default), no gradual increase in wind speed.
            !If s_windcc = 1, then wind speeds increase slowly due to climate
               !change (cc) by windinc_yr m s-1 year-1.
            Constant s_windcc = 0 !Default value.
            !Actual climate change wind speed increase (m s-1) is: 
               windinc_cc = s_windcc * windinc_yr * ( year - yrswindoffset ) 
                              Constant windinc_yr = 0.1 !m s-1 year-1.
                              Constant yrswindoffset = 0.0 !year.
            windmaxmn1 = windmaxmn  +  windinc_cc
            windminmn1 = windminmn  +  windinc_cc

         !Maximum wind speed of day (assumed to be at 15 h), windmax: 
               zwsin1m = s_seasonal * &
                         SIN( c2pi365 * ( iJulian - twind ) ) 
                                                        !Working variable.
                       windmaxvrzwsin1m = windmaxvr * zwsin1m !Checking only.
            windmax = one_s_daily_dat &
                          * one_s_CLINO_dat * one_s_monthsnn_dat &
                          * ( windmaxmn1 + windmaxvr * zwsin1m ) &
                        + s_daily_dat * windmax_dy &
                        + s_CLINO_dat * windmax_CLINO &
                        + s_monthsnn_dat * windmax_mnn

         !Minimum wind speed of day (assumed to be at dawn):
            windmin = one_s_daily_dat &
                          * one_s_CLINO_dat * one_s_monthsnn_dat &
                          * ( windminmn1 + windminvr * zwsin1m ) &
                        + s_daily_dat * windmin_dy &
                        + s_CLINO_dat * windmin_CLINO &
                        + s_monthsnn_dat * windmin_mnn

         !Mean wind speed of day (winddymn):
            winddymn = half * ( windmax + windmin ) + wind_inc
                      Constant wind_inc = 0.0 !m s-1. This is to give an easy
                      !way of increasing wind speed, ie.if a
                      !treatment to raise wind speed by 2 m s-1 above
                      !normal is applied, or if there is a chamber effect
                      !that raises wind speed. Also see m_wind, a multiplier.
         !Daily variation from mean wind speed (winddyvr):
            winddyvr = s_diurnal * half * ( windmax - windmin )
   

      !Output of daily environmental data to file, dailyout.dat.
         IF ( s_dy_dat_out .EQ. one .OR. s_daily_dat .EQ. one .OR. &
              s_CLINO_dat .EQ. one ) THEN
            !If we ask for daily data out, or if we are reading daily data in
            !with s_daily_dat = 1
            WRITE ( 60, 601 ) &
                        idaymo, imonth, iJulian, iyear_dy, jPARdye_6, &
                        Tairmax, Tairmin, Tsoildyc, &
                        rainmm, winddymn, RHmax, RHmin, &
                        INenv_Namm_mg, INenv_Nnit_mg
         ENDIF
            601..FORMAT ( 3x, i2, 3x, i3, 6x, i4, 1x, i4, f5.1, 3x, &
                          f5.1, 3x, f5.1, 1x, f6.1, 3x, &
                          f6.2, 1x, f4.1, 4x, f5.2, 1x, f5.2, 2x, &
                          f5.1, 3x, f5.1 )


      !Temperature function for light saturated photosynthesis (Pmax), fT_Pmax
         !The following quantities are calculated here (rather than every 
         !maxt) as they only depend on CO2 which is constant or very slow
         !moving.
            CO2vpm_div_350 = CO2vpm / c350
                denc350_div_CO2vpm = CO2vpm_div_350  !Debug aid.
            c350_div_CO2vpm = one / CO2vpm_div_350 !for later use.
         TmaxPmax = TmaxPmax350 & 
                    + delTmaxPmax700v350 * ( CO2vpm_div_350 - one )
            !TmaxPmax is the temperature where Pmax (light-saturated value) 
            !is a maximum with respect to temperature.
            !This equation causes TmaxPmax to increase from TmaxPmax350 
            !by delTmaxPmax700v350 deg C when CO2 increases from 350 
            !to 700 vpm.
         !Working variables (not fixed up to include qfT2, ie, qfT2 = 1): 
            T0p_Pmax =  ( ( one + qfT1 ) * TmaxPmax - T0 ) / qfT1
            denzfT_Pmax = ( ( Tref - T0 ) ** qfT1 &
                                * ( T0p_Pmax - Tref ) )
            zfT_Pmax = one / denzfT_Pmax

 
      !Mineralization multiplier, tillage
         !It is assumed that tillage has an effect on the three
         !mineralization rate constants, from iSOM, i = u, p, s,
         !u = unprotected, p = protected, s = stabilized.
         !m_kmin is the multiplier by which mineralization is
         !increased at time year after tillage has occurred.
            Constant m_kmin0 = 1 !Default value. No tillage effect.
               !m_kmin0 is the mineralization multiplier immediately
               !after tillage.
               !year_kmin (year) is decay time of tillage effect.
            Constant year_kmin = 1.0E20  !year.  Large number. This makes
               !multiplier m_kmin not decay - it remains constant at m_kmin0.
               !If m_kmin0 = 2 and year_kmin = 1.44269504 !year = 1 / ln 2,
               !then,
               !year   0   1   2     3     ...
               !m_kmin 2  1.5 1.25  1.125  ...
                           denm_kmin = year_kmin !For debugging.
            m_kmin = one + ( m_kmin0 - one ) &
                                  * EXP ( - year / year_kmin )

      !Debug daily data to file
         !Output of debug daily data to file, debugdy.dat
         !Switch on by <set debug_dy = 1>
         !Constant debug_dy = 0.0, default value.
            IF ( debug_dy .EQ. one ) WRITE ( 62, 621 ) &
                        t, year, idaymo, imonth
            621..FORMAT ( 1x, f11.2, 1x, f11.2, 10x, i2, 10x, i2)

   ELSE
      !Once-a-day-routine has not been executed.
      daybeg = .FALSE.  !We are not at the beginning of a new day.
   ENDIF
!End of ONCE-A-DAY BLOCK.

!From here on (until the END of the DERIVATIVE section, statements are
!executed every maxt, the integration interval.


!DIURNALLY VARYING QUANTITIES
   !(Light (PAR), radiation, net radiation, air temperature (Tair), 
      !relative humidity.  CO2 concn in air also depends on Tair.

   !Diurnal data input
      !Quantities which may be input from a diurnal
      !environmental data file are: PAR, Tair, Tsoil, wind, RH.
      !Default file name is diurnal.dat.
      !Set s_diurnal_dat = 1, s_daily_dat = 0, s_months12_dat = 0,
      !s_monthsnn_dat = 0, s_CLINO_dat = 0.
      !Or use procedure diurnaldata in efm.cmd.
      !t_di1, t_di2, are times of environmental data measurements.

      IF ( s_diurnal_dat .EQ. one ) THEN
      IF ( t .GE. t_di2 ) THEN         !Move location 2 (_di2) to location
          t_di1 = t_di2                !1 (_di1), and refill location 2 
         !minute_di1 = minute_di2      !(_di2) by reading next line of data.
          hour_di1 = hour_di2 
          day_di1 = day_di2 
          month_di1 =  month_di2 
          JulianDy_di1 = JulianDy_di2 
          year_di1 = year_di2 
          t_di1 = ixtra_days_rw_di + &
                  ( year_di1 - year_di0 ) * c365 + JulianDy_di1 - one &
                  + hour_di1 / c24 !+ minute_di1 / c1440      !NOTA BENE.
          PAR_di1 = PAR_di2 
          Tair_di1 = Tair_di2
          Tsoil_di1 = Tsoil_di2
          rain_di1 = rain_di2
          wind_di1 = wind_di2
          RH_di1 = RH_di2

!         READ (50, *) minute_di2, hour_di2, day_di2, month_di2, &
          READ (50, *)             hour_di2, day_di2, month_di2, &
                       JulianDy_di2, year_di2, PAR_di2, Tair_di2, &
                       Tsoil_di2, rain_di2, wind_di2, RH_di2
             t_di2 = ixtra_days_rw_di + &
                     ( year_di2 - year_di0 ) * c365 + JulianDy_di2 - one &
                       + hour_di2 / c24 !+ minute_di2 / c1440  !NOTA BENE.
      ENDIF

!   PROCEDURAL
!      ilogd = i4
!      CALL LOGD( .true. ) !4
!      !then output occurs.
!   END

     !Linear interpolation
         !Interpolate linearly according to
         !If x1 is value of x at t = t1, and x2 = value of
         !x at t = t2, then for t1<= t < t2, the value of x at time t, xt,
         !is xt = xt1 + (xt2 - xt1) * (t - t1) / (t2 - t1).
            t_di2_di1 = t_di2 - t_di1 
         !If the same line of data appears twice in diurnal.dat,
                  !failure occurs due to t_di2 = t_di1. This is also
                  !used to signal the end of the diurnal data file.
            IF ( t_di2_di1 .GT. zero ) THEN
                 zdi_t1t2 = ( t - t_di1 ) / t_di2_di1
               PAR_di = PAR_di1 + (PAR_di2 - PAR_di1) * zdi_t1t2 
               Tair_di = Tair_di1 + (Tair_di2 - Tair_di1) * zdi_t1t2 
               Tsoil_di = Tsoil_di1 + (Tsoil_di2 - Tsoil_di1) * zdi_t1t2 
               rain_di_mm_hr = rain_di1 + (rain_di2 - rain_di1) * zdi_t1t2 
               wind_di = wind_di1 + (wind_di2 - wind_di1) * zdi_t1t2 
               RH_di = RH_di1 + (RH_di2 - RH_di1) * zdi_t1t2 
               !Put these quantities into the right units (where required):
                  rain_di = rain_di_mm_hr * c24  !c24 = 24 to
                                        !convert mm/hr to kg m-2 day-1.
            ELSE !t_di1 = t_di2. End of diurnal data file reached.
               PAR_di = PAR_di1 
               Tair_di = Tair_di1 
               Tsoil_di = Tsoil_di1 
               rain_di_mm_hr = rain_di1 
               wind_di = wind_di1 
               RH_di = RH_di1 
               !Put these quantities into the right units (where required):
                  rain_di = rain_di_mm_hr * c24  !c24 = 24 to
                                        !convert mm/hr to kg m-2 day-1.
            ENDIF 
      ENDIF

!   PROCEDURAL
!      ilogd = i5
!      IF ( calllogd ) CALL LOGD( .true. ) !9
!          ! If calllogd = .true. then output occurs.
!   END


   !Geometry of sun
      !Solar elevation (eqn A7.1, Jones, p. 362).
         sin_solar_elevation = sin_latitudeXsin_solar_dec &
                               + cos_latitudeXcos_solar_dec &
                                 * cos_hourangle
         solar_elevation = ASIN( sin_solar_elevation )    !radians.
         solar_elevation_deg = solar_elevation / c2pi360  !degrees.
         cos_solar_elevation = COS( solar_elevation )
         tan_solar_elevation = TAN( solar_elevation )
         cos_solar_elevation3 = cos_solar_elevation * cos_solar_elevation &
                                                 * cos_solar_elevation
      !Solar azimuth.
      !This is the angle between the sun and the north-south direction
      !(observer looking south), projected onto a horizontal plane.
         IF ( cos_solar_elevation .NE. zero ) THEN
            !Solar elevation is not 90 degrees, i.e. sun not overhead.
            !www formula (http://aurora.crest.org/basics/solar/angle/4.htm):
            cos_solar_azimuth1 = ( sin_solar_elevation * sin_latitude &
                                     - sin_solar_dec ) / &
                                   ( cos_solar_elevation * cos_latitude )
            IF ( cos_solar_azimuth1 .GT. one ) THEN 
                 cos_solar_azimuth = cos_solar_azimuth1 - c1E_10
            ELSE IF ( cos_solar_azimuth1 .LT. minus_one ) THEN 
                 cos_solar_azimuth = cos_solar_azimuth1 + c1E_10
            ELSE
                 cos_solar_azimuth = cos_solar_azimuth1
            ENDIF
   
            solar_azimuth1 = ACOS( cos_solar_azimuth )       !radians.
            solar_azimuth1_deg = solar_azimuth1 / c2pi360     !degrees.

         ELSE
            solar_azimuth1 = clarge !A large number. Sun is exactly overhead. 
                                   !Azimuth is not determinable.
            solar_azimuth1_deg = clarge 
         ENDIF

         !Now make sure that the sign of the azimuth angle
         !equals the sign of the hour angle.
            solar_azimuth = SIGN ( solar_azimuth1, hourangle )  !radians.
            solar_azimuth_deg = solar_azimuth / c2pi360          !degrees.

         !If latitude is negative (southern hemisphere), then we prefer to
            !define solar_azimuth as the angle between the sun and the
            !south-north direction (observer looking north).  Therefore
               IF ( latitude .LT. zero ) THEN
                  solar_azimuthS_N1 = - solar_azimuth - pi
                  solar_azimuthS_N1_deg = - solar_azimuth_deg - c180
                  IF ( solar_azimuthS_N1 .LT. (- pi) ) THEN
                     solar_azimuthS_N = solar_azimuthS_N1 + twopi
                     solar_azimuthS_N_deg = solar_azimuthS_N1_deg + c360
                  ELSE IF ( solar_azimuthS_N1 .GT. pi ) THEN
                     solar_azimuthS_N = solar_azimuthS_N1 - twopi
                     solar_azimuth_degS_N = solar_azimuthS_N1_deg - c360
                  ELSE
                     solar_azimuthS_N = solar_azimuthS_N1
                     solar_azimuthS_N_deg = solar_azimuthS_N1_deg
                  ENDIF
               ENDIF


   !Flag daytime or nighttime using light_on
      light_on =  one_s_diurnal &
                  + s_diurnal * PULSE ( tdawn1, one, daylength )
         !light_on is a step function, which repeats every day.
         !light_on = 0.0 during the night.
         !light_on = 1.0 during the day.
         !If s_diurnal = 0, no diurnal variation, light_on = 1 always.
         !tdawn1 = tdawn - 1.0d-6 to make things work ok.

   !Light, jPARsc (J PAR m-2 s-1)
      !jPARsc is the instantaneous light flux density (PAR), used
         !for calculating photosynthesis.
      IF ( s_diurnal_dat .EQ. zero ) THEN !No diurnal data input.
            jPARscstep = jPARscmn * light_on  !J (PAR) m-2 s-1. 
               !jPARscstep is a step function.
               !jPARscmn is the mean daily value
               !of PAR radiation receipt during daylight.
            IF ( s_diurnal .EQ. zero ) THEN !diurnally constant radiation, =
               jPARsc = jPARscmn       !mean value during the light period.
            ELSE IF ( s_PAR_sin .EQ. one ) THEN  
                    !Use sin function for daily radiation:
               PAR_sin_fn = one &
                            + COS( ( tdec - half ) * twopi / daylength )
                       jPARsc = jPARscstep * PAR_sin_fn
            ELSE !Use step function for daily radiation:
               jPARsc = jPARscstep
            ENDIF
      ELSE
            jPARsc = m_PAR * PAR_di !PAR_di is calculated above by
                           !extrapolation from the diurnal data values.
      ENDIF
         Constant s_PAR_sin = 1 
         !Default switches are s_diurnal = 1 and s_PAR_sin = 1, giving
         !the full sine wave function used for the diurnal
         !variation in radiation: France and Thornley, 1984, pp. 101-2.

      !Put jPARsc (J PAR m-2 s-1) into instantaneous per day units:
          jPARscday = c86400 * jPARsc   !J PAR m-2 day-1.

      !Light absorbed by the canopy
         !Instantaneous light flux density absorbed by the canopy:
            !Fraction absorbed by canopy is:
               kcanLAI = kcan * LAI
               kcanLAITblack = kcan * LAI / one_Tblack
               exp_kcanLAI = EXP ( - kcanLAI )
               exp_kcanLAITblack = EXP ( - kcanLAITblack )
               one_exp_kcanLAI = one - exp_kcanLAI
               one_exp_kcanLAITblack = one - exp_kcanLAITblack
               fPARabs_can = ( ( one - crleaf - chileaf ) &
                             / ( one - chileaf ) ) * one_exp_kcanLAI
               fPARabs_canTblack = one_Tblack * &
                             ( ( one - crleaf - chileaf ) &
                             / ( one - chileaf ) ) * one_exp_kcanLAITblack
                  Constant crleaf = 0.15   !Dimensionless.
                                           !Leaf reflectivity coefficient.
         jPARscabs = jPARsc * fPARabs_canTblack            !J (PAR) m-2 s-1. 
         jPARscabsday = c86400 * jPARscabs   !J PAR m-2 day-1.

      !Photosynthesis responds non-linearly to light.  Therefore
         !if s_diurnal = 0 (no diurnal variation),
         !we use the mean light during the light period
         !to calculate photosynthetic rate. Then the total photosynthesis
         !occurring over the whole of the light period is applied at a
         !constant reduced rate over the 24-hour day to give the same 24
         !hour amount of photosynthesis.  See the photosynthesis section.
         !A similar procedure is applied to transpiration.
   
   !Instantaneous net radiation, jNetRsc (J m-2 s-1)
      !jNetRsc is the instantaneous net radiation used for calculations of
         !evapotranspiration and leaf temperature.
         Constant rNetR_PAR = 1.4 !J net radiation (J PAR)-1. 
                                  !Ratio of daily net radiation to PAR.  
                                  !See Grassland Dynamics for references.
      jNetRsc = rNetR_PAR * jPARsc 

   !Irradiance fractions: direct solar, diffuse
      !Fractions of irradiance which are direct solar (fsun) and diffuse
      !(fdif).  These are assumed to depend on sine of solar elevation.
         nsun = nsun90 * half &
                    * ( sin_solar_elevation + ABS( sin_solar_elevation ) ) &
                                         / ABS( sin_solar_elevation_noon )
                   den_sin_solar_elevation_noon = sin_solar_elevation_noon 
         !If sun overhead, nsun = nsun90 = 1.
                         Constant nsun90 = 1
       !Define lambda_sun0 by
               lambda_sun0 = s_diurnal * nsun * fbshrs &
                       + one_s_diurnal * nsun90 * fbshrs
       !Clearly lambda_sun < 1 (given nsun90 = 1).
               lambda_sun = lambda_sun0 ** qsun; Constant qsun = 0.5

          !At each time point, assume 
              !Time fraction              Relative irradiance
     !Sun out    fbshrs                1 - lambda_sun * fbshrs + lambda_sun
     !Sun in    1 - fbshrs                 1 - lambda_sun * fbshr 
             !Multiply these columns and add to give 1.  OK.

           !Sun is out, radiation is
                  m_sun = one - lambda_sun * fbshrs + lambda_sun
                 !m_sun is the multiplier (> 1) of mean radiation, jPARsc 
                    !which gives total radiation (direct beam + diffuse) 
                    !when sun is out.
              jPARsc_sunouttot = m_sun * jPARsc 
                             
              jPARsc_sun = lambda_sun * jPARsc  !Direct beam radiation.
              jPARsc_dif = ( one - lambda_sun * fbshrs ) * jPARsc 
                          !Diffuse radiation, whether sun is in or out.
                          !All on a horizontal plane at top of canopy.
              fsun = lambda_sun / m_sun !Direct-beam radiation as fraction
                     !of total radiation when sun is out. 
                     !Care if/when m_sun = 0.
              !fsun = lambda_sun / ( one + lambda_sun * (one - fbshrs) )
              fdif = one - fsun !Fraction of total radiation which is diffuse
                     !when the sun is out.

              !Check that mean radiation is ok:
                   jPARsc_chk = fbshrs * jPARsc_sunouttot &
                                + ( one - fbshrs ) * jPARsc_dif
                      !This should be the same as jPARsc. OK, 11/09/2020.
              !See Jones HG. 1992. Plants and Microclimate.
              !fig 2.7b, p 23. Does not completely address the problem.


   !Air temperature
      IF ( s_diurnal_dat .EQ. zero ) THEN
            !The day is divided into 3 periods:
               !midnight to dawn, dawn to 15.00 h, 15.00 h to midnight.
            !tauTair is the time period (sinusoidal variation assumed)
               !for Tair at time tdec (0 <= tdec < 1). 
            !itauTair indexes the period of the day; itauTair = 1, 2, or 3.
               INTEGER itauTair
            !tTairmn is the time at the middle of the time period.
      
            IF ( zero .LE. tdec .AND. tdec .LE. tdawn ) THEN
               !midnight-to-dawn period:
               itauTair = i1  !the first period of the day.
               tTairmn = tTairmn1;  tauTair = tauTair1
                  tTairarg = ( tdec + one - tTairmn ) / tauTair
                  sintTair = SIN( twopi * tTairarg ) 
               Tairz = Tairdymn - Tairdyvr * sintTair  !Working variable.
               Tair = Tairz + s_cd * delTemp_cd
                      !delTemp_cd is the interpolated temperature change from
                      !climate data file, if used (with s_cd = 1).
            ELSE IF ( tdawn .LT. tdec .AND. tdec .LT. c0x625 ) THEN
               !dawn-to-15.00 period; Tair is max at 15 h:
               itauTair = i2  !the second period of the day.
               tTairmn = tTairmn2;  tauTair = tauTair2  
                  tTairarg = ( tdec - tTairmn ) / tauTair
                  sintTair = SIN( twopi * tTairarg ) 
               Tairz = Tairdymn + Tairdyvr * sintTair
               Tair = Tairz + s_cd * delTemp_cd
            ELSE IF ( c0x625 .LE. tdec .AND. tdec .LT. one ) THEN
               !15.00 h (Tair is max)-to-midnight period:
               itauTair = i3  !the third period of the day.
               tTairmn = tTairmn3;  tauTair = tauTair3  
                  tTairarg = ( tdec - tTairmn ) / tauTair
                  sintTair = SIN( twopi * tTairarg ) 
               Tairz = Tairdymn - Tairdyvr * sintTair
               Tair = Tairz + s_cd * delTemp_cd
            ENDIF !( zero .LE. tdec .AND. tdec .LE. tdawn ) THEN
      ELSE
            Tair = Tair_di + Tair_inc + s_cd * delTemp_cd
                   !Tair_di is calculated by extrapolation from
                   !the diurnal data values.
      ENDIF !( s_diurnal_dat .EQ. zero ) THEN
      !End of calculation of air temperature, Tair.
      TairK = Tair + 273.15  !Absolute air temperature.
      Tair0K = 273.15  !Absolute temperature when Tair = 0 C.
      Tair20K = 293.15  !Absolute temperature when Tair = 20 C.
      denTairK = TairK !Used as a denominator.

   !Soil temperature
         IF ( s_Tsoil_EQ_Tair .EQ. one ) THEN
            Constant s_Tsoil_EQ_Tair = 0.0 !Switch to make Tsoil (and also Trt)
               !equal to Tair and Tsh. Used in comparing temperature responses.
               !See F1x6.cmd.
               Tsoil = Tair !If we set s_Tsoil_EQ_Tair = 1, rather than its
               !default value of 0.0, in which case
         ELSE !Tsoil has its usual value. 
            IF ( s_diurnal_dat .EQ. zero ) THEN !No diurnal data input.
               Tsoil = Tsoildyc + Tsoil_inc_fire 
                      !Note that Tsoildyc already includes Tsoil_inc and
                      !s_cd * delTemp_cd
            ELSE
               Tsoil = Tsoil_di + s_cd * delTemp_cd + Tsoil_inc &
                                                    + Tsoil_inc_fire 
                      !Tsoil_di is calculated by extrapolation from
                      !the diurnal data values.
            ENDIF
         ENDIF

         TsoilK = Tsoil + 273.15  !o K. Absolute soil temperature.

         !Root temperature.  Assumed equal to soil temperature:
            Trt = Tsoil

   !Rain
      IF ( s_diurnal_dat .EQ. zero ) THEN !No diurnal data input.
         rain = rainkg                     !kg water m-2 day-1.
               !Note rainkg already has m_rain as a factor.
      ELSE
         rain = rain_di * m_rain        !kg water m-2 day-1.
      ENDIF
         rainmm_d = rain_m_dy * c1000      !mm water m-2 day-1.
         rainmm_hr = rainmm_d / c24        !mm water m-2 hour-1.


   !Relative humidity (RH)
      !Vapour pressure in Pa is VapP = VapP_int( iJulian ). See above.
 
      !Saturated water vapour pressure at temperature Tair is SatVapP
      !Relative humidity from vapour pressure is:
         RH_VapP1 = VapP / SatVapP !Dimensionless.
         RH_VapP = MIN( RH_VapP1, one ) !Make sure this is less than 1.

      IF ( s_diurnal_dat .EQ. zero .AND. s_CLINO_dat .EQ. zero ) THEN 
              !No diurnal data input and no CLINO monthly data input.
         !Parameters for calculating RH are assumed to be the same as 
         !when calculating air temperature, Tair.  See immediately above.
         IF ( 0.0 .LE. tdec .AND. tdec .LE. tdawn ) THEN
            !midnight-to-dawn period.
            RH = RHdymn + RHdyvr * sintTair
         ELSE IF ( tdawn .LT. tdec .AND. tdec .LT. c0x625 ) THEN
            !dawn-to-15.00 period; RH is max at 15 h.
            RH = RHdymn - RHdyvr * sintTair
         ELSE IF ( c0x625 .LE. tdec .AND. tdec .LT. one ) THEN
            !15.00 h (RH is max)-to-midnight period.
            RH = RHdymn + RHdyvr * sintTair
         ENDIF
      ELSE
         IF ( s_diurnal_dat .EQ. one ) THEN
            RH = RH_di
         ELSEIF ( s_CLINO_dat .EQ. one ) THEN
            RH = RH_VapP
         ENDIF
      ENDIF


   !Wind speed, wind (m s-1), at reference height href (50 m).
      Constant m_wind = 1.0 !Multiplier for wind.
      IF ( s_diurnal_dat .EQ. zero ) THEN !Diurnal data not supplied.
            !The day is divided into 3 periods:
               !midnight to dawn, dawn to 15.00 h, 15.00 h to midnight.
            !It is assumed that the diurnal variation of wind speed is
               !inverse to that of air temperature, Tair.
               !Wind is minimum at dawn, and maximum at 15 h.
            !tauTair is the time period (sinusoidal variation assumed)
               !for tauTair at time tdec (0 <= tdec < 1). 
            !itauTair indexes the period of the day; itauTair = 1, 2, or 3.
               !INTEGER i
            !tTairmn is the time at the middle of the time period.
      
            IF ( zero .LE. tdec .AND. tdec .LE. tdawn ) THEN
               !midnight-to-dawn period:
               itauTair = i1  !the first period of the day.
               tTairmn = tTairmn1;  tauTair = tauTair1  
                  tTairarg = ( tdec + one - tTairmn ) / tauTair
                  sintTair = SIN( twopi * tTairarg ) 
               windz = winddymn - winddyvr * sintTair  !Working variable.
               wind = m_wind * ( windz + s_cd * delwind_cd )
                      !delwind_cd is the interpolated wind change from
                      !climate data file, if used (with s_cd = 1).
                      Constant delwind_cd = 0.  !Not implemented.
            ELSE IF ( tdawn .LT. tdec .AND. tdec .LT. c0x625 ) THEN
               !dawn-to-15.00 period; wind is max at 15 h:
               itauTair = i2  !the second period of the day.
               tTairmn = tTairmn2;  tauTair = tauTair2  
                  tTairarg = ( tdec - tTairmn ) / tauTair
                  sintTair = SIN( twopi * tTairarg ) 
               windz = winddymn + winddyvr * sintTair
               wind = m_wind * ( windz + s_cd * delwind_cd )
            ELSE IF ( c0x625 .LE. tdec .AND. tdec .LT. one ) THEN
               !15.00 h (wind is max)-to-midnight period:
               itauTair = i3  !the third period of the day.
               tTairmn = tTairmn3;  tauTair = tauTair3  
                  tTairarg = ( tdec - tTairmn ) / tauTair
                  sintTair = SIN( twopi * tTairarg ) 
               windz = winddymn - winddyvr * sintTair
               wind = m_wind * ( windz + s_cd * delwind_cd )
            ENDIF
      ELSE
            wind = m_wind * ( wind_di + wind_inc + s_cd * delwind_cd )
                   !wind_di is calculated by extrapolation from
                   !the diurnal data values.

      ENDIF
      !End of calculation of wind speed, wind.


   !Ammonia N concentration in air, Namm_atm (kg NH3 N m-3)
      !Namm_atm_vpb is specified (See above).
      Namm_atmSTP = ( Namm_atm_vpb / 1.0E9 ) * ( rmmN / Vmol_STPlitre )
         !This is Namm_atm at 0 deg C, Tair0K and STP, Pair0
      !Namm_atmSTP = Namm_atm_Tair0K_Pair0 ! 
      Namm_atm = ( Namm_atm_vpb / 1.0E9 ) & 
                                     * ( Pair / Pair0 ) &
                                     * ( Tair0K / TairK ) &
                                     * ( rmmN / 22.4136 )
         !Pair is actual atmospheric pressure, Pa
         !Normal atmospheric pressure:
            Constant Pair0 = 101325.0 !Pa
         !Tair0K Absolute temperature when Tair = 0 C.
         !TairK = Tair + 273.15 = absolute temperature.
         !14.007 is the rmm of N:
            Constant rmmN = 14.007 !Relative molecular mass of nitrogen (N).
         !14.007 kg N occupy a volume of 22.4136 m3 at STP; 
         !this is for 1 kg mol of ammonia N. 
         Vmol_stp_chk = Rgas * Tair0K / Pair0      !m3 
         Vmol = Vmol_stp * ( TairK / Tair0K ) & 
                         * ( Pair / Pair0 )    !m3 (g mole)-1
         Vmol_litre = c1000 * Vmol !litre (g mole)-1

         !This is equivalent to:
         !                 273.15  14.007
         ! 1.685E-12 = E-9 ------  ------
         !                 101325  22.41

         !At 20 deg C, and normal atmospheric pressure, 10 vpb NH3 is
         !equivalent to 5.82 x 10-9 kg NH3 N m-3.

   
   !Carbon dioxide concentration in air, CO2air (kg CO2 m-3)
                cc_vpm_conc = Pair * 5293.43e-12 / TairK
      CO2air =  CO2vpm * cc_vpm_conc 
                cc_vpm_conc0 = Pair * 5293.43e-12 / Tair0K
      CO2air0 =  CO2vpm * cc_vpm_conc0 
                cc_vpm_conc20 = Pair * 5293.43e-12 / Tair20K
      CO2air20 =  CO2vpm * cc_vpm_conc20 

             !Carbon dioxide concentration in air, CO2air0 (kg CO2 m-3)
             !at Tair = 0 C when Tair0K = 273.15 K.
             !and at 20 C, CO2air20.
         !See Thornley and Johnson (1990), page 49, eqn (2.4b).
         !This expression is equivalent to:
         !CO2air = CO2vpm * 1.0e-6 * (273.15  / (Tair + 273.15)) &
                   ! * Pair * 9.86923e-6 * 1.9636
         !9.86923e-6 Pa-1 = 1 / (normal atmos. pressure = 101325.0 Pa)
         !CO2air = 1.936 kg m-3 is the density of pure CO2 at STP.
         !At 20 deg C, and normal atmospheric pressure, 350 vpm is equivalent
             !to 0.6404 x 10-3 kg CO2 m-3.
          !Constant Pair = 101325.0 !Pa. Default value of Pair is
                                      !normal atmospheric pressure.
   

!End of calculation of DIURNALLY VARYING QUANTITIES.
!End of calculation of environmental quantities.


!OUTPUT OF DIURNAL ENVIRONMENT DATA TO FILE, diurnout.dat
      !Switched on with set s_di_dat_out = 1.
      !Constant s_di_dat_out = 0.0, default value.
      IF ( s_di_dat_out .EQ. one &
                            .AND. ABS ( t - tdi_dump ) .GT. c1e_10 ) THEN
             !We need to do this because sometimes ACSL increments t by a
             !small number, I think to get maxt into sync with cint, 
             !when maxt cannot be stored exactly (as for maxt = 1 hour).
         !This next write statement and the format statement are for 
         !debugging output to file debugdi1.dat:
          Constant debug_di = 0 !Default value.
          IF ( debug_di .EQ. one ) &
          WRITE ( 63, 624 ) t, tdi_dump, ihour, idaymo, imonth, iJulian, &
                          year_calendar_di
            624..FORMAT ( 1x, f18.13, 1x, f18.13, 5x, i2, 3x, i2, 2x, i2, &
                          9x, i3, 3x, i4)
          tdi_dump = t
   !      WRITE ( 61, 611 ) &
   !         iminute, ihour, idaymo, imonth, iJulian, year_calendar_di, &
          WRITE ( 61, 611 ) &
                      ihour, idaymo, imonth, iJulian, year_calendar_di, &
                      jPARsc, &
                      Tair, Tsoil, &
                      rainmm_hr, wind, RH
   !  611..FORMAT ( 6x, i2, 3x, i2, 2x, i2, 4x, i2, 7x, i3, 1x, i4, 1x, &
      611..FORMAT ( 4x,         i2, 2x, i2, 4x, i2, 7x, i3, 1x, i4, 1x, &
                    f5.1, &
                    f5.1, 2x, f5.1, 1x, &
                    f5.2, f5.1, 1x, f5.2 )
      ENDIF
   
   
!TEMPERATURE
   !Plant parameters
      !Temperature function for shoot processes (assuming that Tsh = Tair):
         Tsh = Tair !Note - we use Tair when calculating fTsh.
         IF ( (Tair .LE. T0) .OR. ( Tair .GE. T0p ) ) THEN
               fTsh = c1E_10
         ELSE !edit this to put in qfT1p
               fTsh = m_fT * ( ( Tair - T0 ) ** qfT1 * &
                      ( T0p - Tair ) ** qfT2 ) * zfT
         ENDIF
                  !zfT = one / &
                  !   ( ( Tref - T0 ) ** qfT1 * ( T0p - Tref ) ** qfT2  &
                  !   )

         Tmaxft = ( qfT1 * T0p + qft2 * T0 ) / ( qft1 + qft2 ) !deg C.
            !Maximum temperature of the temperature function, ftsh.

   !Soil and root processes
         IF ( (Tsoil .LE. T0 ) .OR. ( Tsoil .GE. T0p ) ) THEN
            fTsoil = c1E_10
         ELSE
            fTsoil = m_fT * ( Tsoil - T0 ) ** qfT1 &
                         * ( T0p - Tsoil ) * zfT
         ENDIF
               !zfT = one / &
               !      ( ( Tref - T0 ) ** qfT1 * ( T0p - Tref ) ** qfT2  &
               !      )
         fTrt = fTsoil !They are assumed to be equal.
      
   !N uptake as distributed between Namm and Nnit pools
      !This is affected by soil temperature.  It is represented by
      !fTuNmin, is a temperature-dependent parameter, close to unity.
            fTuNmin0 = fTuN20 - (fTuN20 - fTuN10) &
                             * ( c20 - Tsoil ) / c10 !c10 = 20 - 10.
            Constant fTuN10 = 0.5, fTuN20 = 1.0  !Dimensionless.
               !Relative availability constants for NO3- uptake at 10, 20 C.
               !This is relative to Namm uptake.  At 20 C, NO3- is taken up 
               !at the same rate as Namm.  At 10 C, Nnit uptake rate is half
               !that of Namm.  Linear interpolation is used.
               !At 0 C, fTuNmin = 0, and there is no Nnit uptake.
               !We restrict fTuNmin to between 0 and 1 with:
            fTuNmin1 = MIN( one, fTuNmin0 )
            fTuNmin =  MAX( zero, fTuNmin1 )

   !Photosynthesis, temperature effects
      !alpha, initial slope of photosynthesis light response curve
         IF ( Tair .LE. c15 ) THEN
               fTalpha = one
         ELSE
            fTalpha = one - cTalpha * c350_div_CO2vpm * ( Tair - c15 )
         ENDIF
            Constant cTalpha = 0.015  !(deg C)-1.  
               !Linear fractional decrease in alpha (see above) at 350 vpm CO2 
               !per 1 deg C increase in air (leaf) temperature. 
               !+ 10 deg C gives 15 percent decrease in
               !alpha.  Ref: Loomis, RS and Connor, DJ: Crop Ecology.
               !CUP. 1992. p. 263.
               !If CO2 vpm is doubled to 700 vpm, then the temperature decline
               !is halved.
   
      !Pmax, light saturated photosynthesis, fT_Pmax
         !The three quantities TmaxPmax, Tser2_Pmax and zfT_Pmax are 
         !calculated above in the once-per-day block.
         !TmaxPmax = TmaxPmax350 + delTmaxPmax700v350 * ( CO2vpm / c350 - 1 )
            !TmaxPmax is the temperature where Pmax (light-saturated value)
            !is a maximum with respect to temperature.
            !This equation causes TmaxPmax to increase from TmaxPmax350 
            !by delTmaxPmax700v350 deg C when CO2 increases from 
            !350 to 700 vpm.
         !Working variables (see above):
            !T0p_Pmax =  ( ( 1.0 + qfT1 ) * TmaxPmax - T0 ) / qfT1
            !zfT_Pmax = 1.0 / &
                      !( ( Tref - T0 ) ** qfT1 * ( T0p_Pmax - Tref ) )
         IF ( ( Tair .LE. T0 ) .OR. ( Tair .GE. T0p_Pmax ) ) THEN
               fT_Pmax = c1E_10
         ELSE
               fT_Pmax = m_fT * ( Tair - T0 ) ** qfT1 &
                        * ( T0p_Pmax - Tair ) * zfT_Pmax
         ENDIF
            Constant TmaxPmax350 = 28 !oC. Temperature maximum of
               !light-saturated
               !photosynthesis, Pmax, at 350 vpm CO2.
            Constant delTmaxPmax700v350 = 9  !deg C.  When CO2 increases from
               !350 to 700 vpm, Tmaximum of light-saturated photo-
               !synthesis Pmax increases by delTmaxPmax700v350 deg C.
   
   !Ammonia volatilization in the foliage
         fT_Namm_le = c1fT_Namm_le * EXP ( - c2fT_Namm_le / TairK )
               Constant c1fT_Namm_le = 86648 !Dimensionless.  Value is adjusted
                                             !so that fT_Nammle = 1 at 20 C.
               Constant c2fT_Namm_le = 3333  !K. This is an "Arrhenius"
                                             !constant
                                             !for NH3 volatilization into the
                                             !sub-stomatal cavities in foliage.
              !Reference: Sutton MA, Pitcairn CER, Fowler D. 1993. The exchange
              !of ammonia between the atmosphere and plant communities.
              !Advances in Ecological Research 24: 301-393 (eds Begon M, 
              !Fitter AH) Academic Press, London.
              !See p. 339 and the Appendix.


!WATER FUNCTIONS
   !Water functions for tree, litter, soil biochemistry
      IF ( s_water .EQ. zero ) THEN !Effects of water switched off.
            fWphz = one; fWlez = one; fWfiz = one
            fWsurfz = one; fWsoilz = one
      ELSE 
            fWphz = aWle ** qWph    !aWle = activity of water in foliage (le).
            fWlez = aWle ** qWpl    
            fWfiz = aWfi ** qWpl
            fWsurfz = aWle ** qWsurf
            fWsoilz = aWsoil ** qWsoil
      ENDIF

         !q's below are all dimensionless. Effects of water status on
         Constant qWph = 2     !photosynthesis;
         Constant qWpl = 20    !tree biochemistry;
         !Constant qWsoil = 20 !soil biochemistry;
         !Constant qWsurf = 30 !surface litter biochemistry.
         !Water activities, aWxx are calculated in the Water Submodel section.

            !Sometimes functions fW.. become zero, causing failure. Therefore
                  Constant fWmin = 0.001 !Minimum value of water functions.
               IF ( fWphz .GE. fWmin ) THEN
                    fWph = fWphz
               ELSE
                    fWph = fWmin
               ENDIF

               IF ( fWlez .GE. fWmin ) THEN
                    fWle = fWlez
               ELSE
                    fWle = fWmin
               ENDIF

               IF ( fWfiz .GE. fWmin ) THEN
                    fWfi = fWfiz
               ELSE
                    fWfi = fWmin
               ENDIF

               IF ( fWsurfz .GE. fWmin ) THEN
                    fWsurf = fWsurfz
               ELSE
                    fWsurf = fWmin
               ENDIF

               IF ( fWsoilz .GE. fWmin ) THEN
                    fWsoil = fWsoilz
               ELSE
                    fWsoil = fWmin
               ENDIF
            fWst = SQRT( fWle * fWfi )  !Geometrical average.


!TREE SUBMODEL

   !Phenology
      !Dormancy2 ----> Competence ----> Budburst ----> Dormancy1 ---->
      !                                          <----
      !State variables:
      ! dorm2          comp             budb           dorm1
      !Initial values (0 h 1 Jan):
      !  0               100              0              0
      !
      !Total morph(ogen):
         morph = dorm2 + comp + budb + dorm1 !sum is always 100 mu.
         Dmorph = Ddorm2 + Dcomp + Dbudb + Ddorm1 ! zero if treevr = 1
      !                                     away from dormancy
      !Phenological events are:
      !dormancy                          budburst      dormancy
      !ends                                            begins
      !
      !Rate constants:
      !          kchill          kforce     kbudb_dorm1        kdorm1_2
      !                                     kdorm1_budb
   
   
      PROCEDURAL ( Idorm2, Odorm2, Ddorm2, Icomp, Ocomp, Dcomp, &
                   Ibudb, Obudb, Dbudb,    Idorm1, Odorm1, Ddorm1, &
                   s_leaf, budburst, budsopening, m_dorm1_kXle_li, &
                   dormant, leaf_fall &
                   = dorm2, comp, budb, dorm1, Tair, fTsh, daybeg )
      !Search for END !procedural
         !About 7 pages down.

      IF ( t .NE. tdumpphenol ) THEN
          tdumpphenol = t  !This ensures that this procedural is only
                           !executed once at each time.
    
      !Dormancy2, dorm2. State variable signifying end of dormancy
         !When dorm2 reaches 100, dormancy ends, and chilling can begin.
   
         !Input, Idorm2
            !This = output from dorm1, Odorm1_2.
            !Odorm1_2
               !Dormancy rate constant, kdorm1_2, for reaction dorm1 --->
                                                              !dorm2.
               !kdorm1_2 determines progress towards ending dormancy.
   
                        delTdorm1_2z = Tair - Tdorm1_2min  !deg C.
                        Constant Tdorm1_2min = 0 !deg C. Minimum air
                        !temperature for progress towards ending dormancy.
                                     !A linear temperature function for
                                     !for progress towards ending dormancy.
                                     !delTdorm1_2z can be + or -.  Therefore
                        delTdorm1_2 = half * ( delTdorm1_2z + &
                                         ABS ( delTdorm1_2z ) )
                                !deg C. This is only + if Tair > Tdorm1_2min. 
                        kdorm1_2z = delTdorm1_2 * kdorm1_220 !day-1.
                            Constant kdorm1_220 = 1.0    !MU (deg C day)-1.
   
               IF ( dormant .EQ. zero .OR. &
                    Idorm1 .GT. zero .OR. tint .LT. itdorm1plus ) THEN
                       !If: tree is not dormant, or there is still
                       !an input into the dorm1 pool, 
                       !or time tint = INT ( t + halfmaxt ) is less than
                       !that when progress towards breaking 
                       !dormancy is allowed (itdorm1plus), then
                  Odorm1_2z = 0
               ELSE
                  kdorm1_2 = kdorm1_2z
                  Odorm1_2z = kdorm1_2                   !day-1. Zero order.
               ENDIF
   
               !Make sure that dorm2 does not overshoot 100:
                  Odorm1_2zmaxt = Odorm1_2z * maxt
                  dorm2next = dorm2 + Odorm1_2zmaxt
                  IF ( dorm2next .GT. c100 ) THEN
                     IF ( maxt .NE. zero ) THEN
                        Odorm1_2 = ( c100 - dorm2 ) / maxt
                     ELSE
                        Odorm1_2 = zero
                     ENDIF
                  ELSE
                     Odorm1_2 = Odorm1_2z
                  ENDIF
            Idorm2 = Odorm1_2
   
         !Output, Odorm2:
            !1  No output if there is no dorm2 in the pool, or,
            !2. if the tree is dormant:
                     !Temperature range must be right:
                     IF ( Tchillmin .LT. Tair .AND. Tair .LT. Tchillmax ) THEN
                        fTchill = multfTchill &
                                     * ( Tair - Tchillmin ) ** qchillmin &
                                     * ( Tchillmax - Tair ) ** qchillmax
                                 !Tchillmin = -5, Tchillmax = 15 deg C;
                                 !qchillmin = 2, qchillmax = 1.  See above.
                        kchillz = fTchill * kchill20
                                  Constant kchill20 = 2
                                     !MU day-1.
                                     !Maximum value of chilling rate.
                                     !MU = morphological unit.
                     ELSE
                        kchillz = 0.0
                     ENDIF
   
                  
               IF ( ( dorm2 .LE. zero ) .OR. ( dormant .EQ. one ) ) THEN
                    !dorm2 pool <= 0, or, the tree is dormant.
                  Odorm2 = zero
               ELSE !dorm2 > 0, or, tree is not dormant (dormant .NE. 1).
                     kchill = kchillz
                     Odorm2z = kchill
   
                     !Also, dorm2 must remain  > or = 0:
                     Deldorm2 = Odorm2z * maxt
   
                        IF ( dorm2 .GE. Deldorm2 ) THEN
                             Odorm2 = Odorm2z      !dorm2 wont go negative.
                        ELSE IF ( maxt .NE. zero ) THEN !Avoid / 0.
                             Odorm2 = dorm2 / maxt
                                               !dorm2 would have gone negative.
                        ELSE
                             Odorm2 = 0.0
                        ENDIF
               ENDIF
   
         !Differential equation.
         !Rate of change of dorm2, Ddorm2
                    Ddorm2z = ( Idorm2 - Odorm2 )
            Ddorm2 = treevr * Ddorm2z ! = Idorm2 - Odorm2 
                    !dorm2 is a tree sv, 
   
      
      !Competence, comp pool. State variable allowing response to
         !forcing temperatures
   
         !Input, Icomp:
            Icomp = Odorm2 !Input is the output from dorm2(ancy). See above.
   
         !Output, Ocomp (the so-called forcing flux).
               !Two options are provided for calculating kforce, MU d-1, which 
               !is a rate constant.
               !1. The standard plant temperature function, fTsh, can be used:
                     INTEGER force_fn
                     Constant force_fn = 2       ! Default. 
                  IF ( force_fn .EQ. 1 ) THEN
                     kforce = kforce1 * fTsh
                                       !Standard plant temperature function.
                                       !Note: fTsh >= 1.0E-10.
                     Constant kforce1 = 4.0  
                  ELSE IF ( force_fn .EQ. 2 ) THEN
               !2. A linear forcing rate is assumed:
                     !Temperature range must be right for forcing:
                     IF ( Tair .GT. Tforcemin ) THEN
                        kforce = kforce2 * ( Tair - Tforcemin ) !day-1.
                     ELSE
                        kforce = c1E_10     !Tair < Tforcemin. A small number.
                     ENDIF
                        Constant Tforcemin = 0 !degree C.
                        !Minimum temperature for forcing.
                        Constant kforce2 = 0.13 !(degree C)-1 day-1.
                                                !Rate constant.
                  ENDIF
   
               !Interim value of Ocomp, Ocompz, is:
                  Ocompz = kforce
   
         !Rate of change of comp, Dcomp:
            !There is no output from comp if comp < or = 0:
            IF ( comp .LE. zero ) THEN
               Dcomp = Icomp
            ELSE
               !Calculate Dcomp so that comp remains > or = 0.
                  Dcompz = Icomp - Ocompz !Interim value of Dcomp.
                  Delcomp = Dcompz * maxt
                     IF ( comp .GE. ( - Delcomp ) ) THEN
                        Dcomp = Dcompz      !comp wont go negative.
                     ELSE IF ( maxt .NE. zero ) THEN !Avoid / 0.
                        Dcomp = - comp / maxt !comp would have gone negative.
                     ELSE
                        Dcomp = zero
                     ENDIF
            ENDIF
   
         !Calculate actual Ocomp:
             Ocomp = - Dcomp + Icomp
   
   
      !Budburst, budb pool. State variable denoting progress
         !towards budburst
   
         !Input, Ibudb
            Ibudb = Ocomp !Input is the output from comp(etence).
   
         !Output, Obudb:
            !Have we reached budburst?  This is triggered at the beginning
            !of the day (daybeg) after the day when budb reaches 100.
            !The leaves open over one day, the day following the day when
            !budb reaches the target of 100.
               IF ( daybeg .AND. budburst .EQ. zero & 
                               .AND. budb .GE. c99x9999 &
                               .AND. bb_notthisyr ) THEN
                 INTEGER jbudb, idaymobudb, imonthbudb, jbudbplus, jbudb_tau
                 !Budburst is now:
                     bb_notthisyr = .false. !Budburst (bb) has now occurred.
                     budburst = one    !Budburst is today. The over-wintering
                                       !buds are assumed to open in one day.
                     budsopening = one !Buds will now open from today until
                                       !dormancy is approached (see below).
                                       !Default values of these variables
                                       !is for Sitka, with budburst = 0 and
                                       !budsopening = 1.  See Initial.
                 !Save time and date of budburst:
                     tbudb = t              !days.
                     idaybudb = iday        !integer value of t + 1.
                     jbudb = iJulian        !Julian day.
                     idaymobudb = idaymo    !Day of month.
                     imonthbudb = imonth    !Month.
                     month_rbudb = month_r  !Running (decimal) month.
                 !Also we will need
                     jbudb_tau = jbudb + itau_budb; Constant itau_budb = 1 !d 
                     !Buds have 1 d to open before leaf processes switched on.
                     jbudbplus = jbudb + itau_dorm1    !d. A Julian date.
                     INTEGER itau_dorm1; Constant itau_dorm1 = 1 !d. Do not set
                     !to 0. This is the period after budburst during which no
                     !progress towards dormancy, dorm1, can occur.
               ELSE
                  IF ( iJulian .EQ. jbudb_tau .AND. &
                       t .GT. tbudb .AND. budburst .EQ. one ) THEN
                    !This is the day after (this year's) budburst.
                     budburst = zero  !Over-wintering buds are now open.
                        !Buds continue to open at the usual rate.
                     s_leaf = one !Leaf state variables have sensible
                         !values, so that leaf processes can be switched on.
                  ENDIF
               ENDIF
   
            !Dormancy rate constant, kbudb_dorm1.
               !kbudb_dorm1 determines progress towards initiating dormancy.
   
                  delTbudb_dorm1z = Tbudb_dorm1max - Tair  !deg C.
                                  !Linear temperature function. Can be + or -.
                     Constant Tbudb_dorm1max = 10 !deg C. Maximum air
                              !temperature for progress towards dormancy.
                              !Tair must be < Tbudb_dorm1max for progress
                              !towards dormancy (dorm1).
                  delTbudb_dorm1 = half * ( delTbudb_dorm1z + &
                                      ABS ( delTbudb_dorm1z ) )    !deg C. 
                                !This is only + if Tair < Tbudb_dorm1max. 
                  fTbudb_dorm1 = delTbudb_dorm1        !deg C.
                  kbudb_dorm1z = fTbudb_dorm1 * kbudb_dorm120       !day-1.
                          Constant kbudb_dorm120 = 1.0     !day-1 (deg C)-1.
   
               IF ( s_leaf .EQ. zero .OR. t. LT. tbudb &
                    .OR. iJulian .LT. jbudbplus &
                    .OR. Ocomp .GT. zero &
                    .OR. iJulian .LT. j21Jun ) THEN
                       !if budburst has not occurred, 
                       !or we are on a day just after budburst when
                       !   progress towards dormancy still not allowed, 
                       !or there is still some output from comp pool
                       !   (calculated above),
                       !or midsummer has not passed, 
                       !then
                  kbudb_dorm1 = 0
               ELSE
                  kbudb_dorm1 = kbudb_dorm1z
               ENDIF
            Obudb1 = kbudb_dorm1                          !day-1. Zero order.
   
         !Calculate Dbudb and Obudb so that budb remains > or = 0.
            Dbudb1 = Ibudb - Obudb1 !Provisional value of Dbudb, D = d/dt.
               Delbudb = Dbudb1 * maxt
   
                  IF ( budb .GE. ( - Delbudb ) ) THEN
                     Dbudb = treevr * Dbudb1      !budb wont go negative.
                  ELSE IF ( maxt .NE. zero ) THEN !Avoid / 0.
                     Dbudb = treevr * (- budb ) / maxt !budb would have gone 
                                                       !negative 
                  ELSE
                     Dbudb = zero
                  ENDIF
         
               Obudb = - Dbudb + Ibudb
   
   
      !Dormancy1, dorm1 pool. State variable signifying beginning of dormancy
         !Input, Idorm1:
            Idorm1 = Obudb
            !Have we reached the beginning of dormancy?
            !This is triggered at beginning (0 h) of the day when dorm1 = 100.
               !Mostly dorm1 attains 100 on previous day, and stayed at 100.
               INTEGER itau_dorm2, jdorm1, idaymodorm1, imonthdorm1 
                  Constant itau_dorm2 = 1 !d
                       !Days of dormancy during which progress towards 
                       !dormancy breaking is not allowed.
               INTEGER jdorm2, idaymodorm2, imonthdorm2 

            IF ( daybeg ) THEN  !we are at the beginning of a day.
                                 dormant_yday = dormant !Store yesterday's
                                                        !value of dormant.
               IF ( dorm1 .GE. c99x9999 .AND. leaf_fall .EQ. zero ) THEN
                  !Dormancy begins today:
                     dormant_yday = dormant       !Store yesterday's value of
                                                  !dormant.
                     dormant = one                !The tree is now dormant.
                                                  !This could give trouble if
                                                  !dormancy begins twice in the
                                                  !same calendar year.
                  !Save the time and date of beginning of dormancy:
                     tdorm1 = t             !d.
                     jdorm1 = iJulian       !Julian day. Usually tdorm1 + 1
                     idaymodorm1 = idaymo   !Day of month.
                     imonthdorm1 = imonth   !Month.
                     month_rdorm1 = month_r !Running (decimal) month.
                  !Also we will need
                     itdorm1plus = INT ( tdorm1 + halfmaxt ) + itau_dorm2
                  IF ( s_deciduous .EQ. one ) THEN
                     !Turn off leaf processes, including NO3 reduction in
                     !shoot:
                        s_leaf = zero
                  ENDIF
               ELSE IF ( dorm2 .GE. c99x9999 ) THEN
                  !Dormancy ends today:
                  !This is triggered at beginning of 1st day when dorm2 = 100.
                  !Save time and date of end of dormancy:
                     tdorm2 = t             !day.
                     jdorm2 = iJulian       !Julian day.
                     idaymodorm2 = idaymo   !Day of month.
                     imonthdorm2 = imonth   !Month.
                     month_rdorm2 = month_r !Running (decimal) month.
                  !End of dormancy has been reached:
                     dormant = zero
               ENDIF !IF ( dorm1 .GE. c99x9999 .AND. leaf_fall .EQ. zero )
                 !How many days of dormancy, remembering that dormancy might 
                 !finish in the winter of the new year.
                    IF ( dormant .EQ. zero .AND. dormant_yday .EQ. one ) THEN
                      !Dormancy has just finished.
                       days_dormant = days_dormancy
                       days_dormancy = zero
                    ELSE
                       days_dormancy = days_dormancy + dormant
                    ENDIF
            ENDIF !if ( daybeg...
                       
         !Outputs
            !Output dorm1 ---> dorm2, Odorm1_2, is calculated above.
            !Output which has the possibility of reversing the onset of
               !dormancy, Odorm1_budb, is calculated next:
            !This section has not been used and debugged.  NOTE.
               !Rate constant counteracting onset of dormancy, kdorm1_budb
               delTdorm1_budbz = Tair - Tdorm1_budbmin !deg C. Can be + or -.
                                  Constant Tdorm1_budbmin = 10 !deg C.
                                     !Minimum air temperature
                                     !for progress away from dormancy.
               delTdorm1_budb = half * ( delTdorm1_budbz + &
                                    ABS ( delTdorm1_budbz ) )        !deg C.
                                   !This is only + if Tair > Tdorm1_budbmin. 
                   fTdorm1_budb = delTdorm1_budb                     !deg C.
               kdorm1_budb = fTdorm1_budb * kdorm1_budb20 !day-1.
                                   Constant kdorm1_budb20 = 0.0 
                   !day-1 (deg C)-1. Rate constant away from dormancy.
               Odorm1_budb = kdorm1_budb
   
            !Total interim output:
               Odorm1z = Odorm1_2 + Odorm1_budb
   
         !Output, Odorm1
                  !dorm1 must remain  > or = 0:
                     Deldorm1 = Odorm1z * maxt
                        IF ( dorm1 .GE. Deldorm1 ) THEN
                           Odorm1 = Odorm1z      !dorm1 wont go negative.
                           ELSE IF ( maxt .NE. zero ) THEN !Avoid / 0.
                              Odorm1 = dorm1 / maxt
                                               !dorm1 would have gone negative.
                           ELSE
                           Odorm1 = zero
                        ENDIF
         !Rate of change of dorm1:
            Ddorm1 = treevr * ( Idorm1 - Odorm1 )
   
         !Budsopening must be turned off as dormancy approaches.
             INTEGER idaybudsstopopening , jbudsstopopening , &
                     idaymobudsstopopening , imonthbudsstopopening 
            !We do this as a step function:
             IF ( s_deciduous .EQ. one .AND. daybeg &
                 .AND. dormant .EQ. zero .AND. yearno .EQ. iyearbso &
                 .AND. dorm1 .GT. dorm1max_budsopening ) THEN
                     iyearbso = iyearbso + i1 !Increment iyearbso so that
                               !(buds stop opening) occurs only 1 / year.
                budsopening = zero
                Constant dorm1max_budsopening = 20.0  !Buds stop opening when
                   !dormancy (dorm1) is 20% complete.
                !Save time and date when buds stop opening (budsstopopening):
                     tbudsstopopening = t           !days.
                     idaybudsstopopening = iday     !integer value of t + 1.
                     jbudsstopopening = iJulian     !Julian day.
                     idaymobudsstopopening = idaymo !Day of month.
                     imonthbudsstopopening = imonth !Month.
                     month_rbso = month_r           !Running (decimal) month.
             ENDIF
   
 
         !Leaf senescence is increased as dormancy ( dorm1 = 100 )
            !approaches. This is achieved by using a multiplier, 
            !m_dorm1_kXle_li, which is a function of dorm1, and multiplies
            !rate constant kXle_li. qdorm1_kXle_li = 10
               IF ( s_deciduous .EQ. zero .OR. dorm1 .EQ. zero &
                                    .OR. dormant .EQ. one ) THEN
                  m_dorm1_kXle_li = one
               ELSE
                  dorm1q = dorm1 ** qdorm1_kXle_li
                  fdorm1q = dorm1q / ( dorm1q + Kdorm1q )
                  m_dorm1_kXle_li = one + m_dorm1_kXle_li_max_1 * fdorm1q
                  !See INITIAL section above for constants qdorm1_kXle_li,
                  !Kdorm1q and m_dorm1_kXle_li_max_1.
               ENDIF

         !Leaf fall
            !When dormancy begins (dorm1 = 100), any remaining leaves 
            !must be removed.
            !Set leaf_fall to 1 for the first day of dormancy.
            INTEGER jleaf_fall, idaymoleaf_fall, &
                    imonthleaf_fall, jleaf_fallplusone
               IF ( daybeg .AND. s_deciduous .EQ. one .AND. leaf_fall .EQ. &
                     zero .AND. dorm1 .GT. c99x9999 &
                    .AND. lf_notthisyr ) THEN !Leaf fall is occurring today.
                     lf_notthisyr = .false. !Leaf fall (lf) has now occurred.
                              !lf_notthisyr = leaffallhasnotoccurredthisyear.
                    leaf_fall = one; one_leaf_fall = zero
                    tleaf_fall = t              !days.
                    jleaf_fall = iJulian        !Julian day.
                    idaymoleaf_fall = idaymo    !Day of month.
                    imonthleaf_fall = imonth    !Month.
                    month_rleaf_fall = month_r  !Running (decimal) month.
                    jleaf_fallplusone = jleaf_fall + i1        !day. i1 = 1.
                             ! Julian day after leaf_fall.
                    !Now define the constant output fluxes which drive all the 
                    !leaf state variables to zero over 1 day (lf = leaf fall):
                       OAleaf1_lf = Aleaf1  - c1E_15
                       OAleaf2_lf = Aleaf2  - c1E_15
                       OAleaf3_lf = Aleaf3  - c1E_15
                       OAleaf4_lf = Aleaf4  - c1E_15
                       OXle1_lf =   MXle1   - c1E_15
                       OXle2_lf =   MXle2   - c1E_15
                       OXle3_lf =   MXle3   - c1E_15
                       OXle4_lf =   MXle4   - c1E_15
                       OCSle_lf =   MCSle   - c1E_15
                       ONSle_lf =   MNSle   - c1E_15
                       ONph_lf =    MNph    - c1E_15
                       OWle_lf =    Wle     - c1E_15 
               ELSE
                  IF ( iJulian .EQ. jleaf_fallplusone .AND. &
                       t .GT. tleaf_fall ) THEN
                    !This is the day after (this year's) leaf_fall.
                     leaf_fall = zero; one_leaf_fall = one
                         !Leaf fall is now complete.
                       OAleaf1_lf = zero;  OAleaf2_lf = zero
                       OAleaf3_lf = zero;  OAleaf4_lf = zero
                       OXle1_lf =  zero;   OXle2_lf =  zero
                       OXle3_lf =  zero;   OXle4_lf =  zero
                       OCSle_lf =  zero;   ONSle_lf =  zero
                       ONph_lf =   zero;   OWle_lf =   zero
                  ENDIF ! IF ( iJulian .EQ. Jleaf_fallplusone ...
               ENDIF !IF ( daybeg .AND. s_deciduous .EQ. one .AND. leaf_fall..
      ENDIF !of if ( t .NE. tdumpphenol ) then section.
      END !PROCEDURAL ( Idorm2, Odorm2, Ddorm2, ..., phenology procedural
!               PROCEDURAL ( Idorm2, Odorm2, Ddorm2, Icomp, Ocomp, Dcomp, &
!                   Ibudb, Obudb, Dbudb,    Idorm1, Odorm1, Ddorm1, &
!                   s_leaf, budburst, budsopening, m_dorm1_kXle_li, &
!                   dormant, leaf_fall &
!                   = dorm2, comp, budb, dorm1, Tair, fTsh, daybeg )


      !Integration:
            dorm2 = INTEG( Ddorm2, dorm20 ); Constant dorm20 = 0.0
             comp = INTEG( Dcomp, comp0 );   Constant comp0 = 100.0
             budb = INTEG( Dbudb, budb0 );   Constant budb0 = 0.0
            dorm1 = INTEG( Ddorm1, dorm10 ); constant dorm10 = 0.0
   
   !End of phenology section.


!FIRE (Derivative section)
   !Fire is switched on with s_fire = 1.
   !Default: s_fire = 0.  No fire events.

   !Pulse function for fire events
      pulse_fire = s_fire * ( &
         PULSE ( tfire ( 1 ),  c365E6, tau_fire ) + & !c365e6 = 365,000,000.0 
         PULSE ( tfire ( 2 ),  c365E6, tau_fire ) + & !tau_fire = 1.
         PULSE ( tfire ( 3 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 4 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 5 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 6 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 7 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 8 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 9 ),  c365E6, tau_fire ) + &
         PULSE ( tfire ( 10 ), c365E6, tau_fire ) )   !Dimensionless. 0 or 1.

      !Time of end of last fire event (fire lasts 1 day)
         IF ( daybeg .AND. pulse_fire .EQ. one ) THEN
               tlast_fire = t + tau_fire  !day. Time t when last/current
                                          !fire ended/ends.
               yrlast_fire = tlast_fire / c365 !year.
                                            !Express tlast_fire in years.
               yr_fireEfNd = yrlast_fire + tauyr_fire_soilT_inc 
                  !Year when fire Effect on soil temperature and
                  !mineralization rates eNds.

         ENDIF
            !In Initial, tlast_fire is set to 7.7777e7.

         Constant tauyr_fire_soilT_inc = 0 !years. Duration of effect
            !of fire giving soil temperature lift and mineralization boost.
            !If 0, then there
            !is no soil temperature lift after fire.  The fire effect
            !on soil temperature is often c. 20 years.
         !Comment.
            !Effect of fire on soil temperature, by altering radiation balance 
            !at soil surface, via albedo, radiation to the ground, loss of 
            !insulation of surface litter.  It is hard to find a simple and
            !satisfactory way of doing this, as any soil temperature lift 
            !probably depends on net radiation [jNetRsc (J m-2 s-1)], 
            !fraction reaching ground (LAI) (search <jNetRdyabso>),
            !and surface litter.  Ideally, we would have a soil moisture and
            !heat submodel.

         !Effect of fire on soil temperature and mineralization
            !ie mineralization constants for pSOM and sSOM.
            IF ( s_fire .EQ. one &
                 .AND. tauyr_fire_soilT_inc .GT. zero &
                 .AND. year .GE. yrlast_fire ) THEN
               zTsoil_fire1 = ( yr_fireEfNd - year ) / tauyr_fire_soilT_inc 
               zTsoil_fire = MAX( zTsoil_fire1 , zero )
               Tsoil_inc_fire = Tsoil_inc_fire_max * zTsoil_fire 
                   Tso_i_fire = Tsoil_inc_fire !For output only.
               m_kmin_fire = one + m_kmin_fire_max_1 * zTsoil_fire 
            ELSE
               Tsoil_inc_fire = zero
               Tso_i_fire = Tsoil_inc_fire !For output only.
               m_kmin_fire = one
            ENDIF
            Constant Tsoil_inc_fire_max = 4  !deg C. Soil temperature uplift
               !due to fire.
            Constant m_kmin_fire_max_1 = 1 !m_kmin_fire_max = 2.
         !End of section.

   !Effect of fire on the trees
      !Rate constant for stem killing during the fire events:    
         kst_firez = s_fire * ( &
            kst_fire( 1 )  * PULSE ( tfire ( 1 ),  c365E6, tau_fire ) + &
            kst_fire( 2 )  * PULSE ( tfire ( 2 ),  c365E6, tau_fire ) + &
            kst_fire( 3 )  * PULSE ( tfire ( 3 ),  c365E6, tau_fire ) + &
            kst_fire( 4 )  * PULSE ( tfire ( 4 ),  c365E6, tau_fire ) + &
            kst_fire( 5 )  * PULSE ( tfire ( 5 ),  c365E6, tau_fire ) + &
            kst_fire( 6 )  * PULSE ( tfire ( 6 ),  c365E6, tau_fire ) + &
            kst_fire( 7 )  * PULSE ( tfire ( 7 ),  c365E6, tau_fire ) + &
            kst_fire( 8 )  * PULSE ( tfire ( 8 ),  c365E6, tau_fire ) + &
            kst_fire( 9 )  * PULSE ( tfire ( 9 ),  c365E6, tau_fire ) + &
            kst_fire( 10 ) * PULSE ( tfire ( 10 ), c365E6, tau_fire ) )
                                                                     !day-1.
            !Constant c365E6 = 365 x 10**6 !days = 10**6 years (in days).
               !This number is set to a large value. Its actual value does
               !not matter, as long as it is larger than the runtime, tstop.
     
      !Calculation of tree fluxes from fire event
         !Tree variables and state variables are Y stem-1. 
         !It is assumed that when stems are destroyed by fire, they
         !are replaced by stems of seedling size (*_sdlg). There is no 
         !change in nstems, and no contribution to Dnstems.
         !There is an output of dead stems of kst_fire * nstems:
            Onstems_fire = kst_firez * nstems                !stems day-1.
         !Each of these stems carries away Y, giving an output of Y
               !Onstems_fire * Y                             !Y m-2 day-1.
         !There is an input of stems, young seedlings (sdlg), each bringing
            !with them an amount of Y = Y_sdlg (Y at time 0).
            !If Y is a state variable, then Y_sdlg = Y0z1 (see above),
            !which is the possibly scaled value of Y0z. 
            !Note that the Y0 is set = Y0z1 is calcics = .true. and so is
            !not reset by re-initialization (restore) command.
         !The total output of Y is
               !OY_fire_gnd = Onstems_fire * ( Y - Y_sdlg )     !Y m-2 day-1.
         !There is a contribution to DY of
               !OY_fire = - OY_fire_gnd / nstems         !Y stem-1 day-1.

            !Buds (state variable Mbud)
               OMbud_fire = kst_firez * ( Mbud - Mbud_sdlg )
                                                     !kg DM stem-1 day-1.
               OCbud_fire = Onstems_fire * ( MCbud - MCbud_sdlg )
                                                          !kg C m-2 day-1.
               ONbud_fire = Onstems_fire * ( MNbud - MNbud_sdlg )
                                                          !kg N m-2 day-1.
               OWbud_fire = Onstems_fire * ( MWbud - MWbud_sdlg )
                                                          !kg W m-2 day-1.
               !C output is all to the atmosphere (mostly CO2, traces of 
                  !CO or CH4 depending on fire severity):
                  OCbud_fire_atm = OCbud_fire             !kg C m-2 day-1.
               !N output is part to the soil Namm pool and the rest to
                  !the atmosphere (NOx):
                  ONbud_fire_Namm = ftreeN_fire_Namm * ONbud_fire
                  ONbud_fire_atm = ONbud_fire - ONbud_fire_Namm 
                                                           !kg N m-2 day-1.

                  Constant ftreeN_fire_Namm = 0.25 !Dimensionless. Fraction
                     !of N in the burnt portion of the tree which enters
                     !soil ammonium pool, Namm. Severe fire value is default.
                     !W(ater) is assumed output to the atmosphere:
                  OWbud_fire_atm = OWbud_fire             !kg W m-2 day-1.

            !Foliage (le):
               !State variables:
                  !MCSle (kg substrate C stem-1):
                     OCSle_fire = kst_firez * ( MCSle - MCSle_sdlg )
                                                         !kg CS stem-1 day-1.
                  !MNSle (kg foliage substrate N stem-1):
                     ONSle_fire = kst_firez * ( MNSle - MNSle_sdlg )
                                                         !kg NS stem-1 day-1.
                  !MNph (kg photosynthetic N stem-1):
                     ONph_fire = kst_firez * ( MNph - MNph_sdlg )
                                                        !kg Nph stem-1 day-1.
                  !Aleaf1-4 (m2 foliage stem-1):
                     OAleaf1_fire = kst_firez * ( Aleaf1 - Aleaf1_sdlg ) 
                     OAleaf2_fire = kst_firez * ( Aleaf2 - Aleaf2_sdlg ) 
                     OAleaf3_fire = kst_firez * ( Aleaf3 - Aleaf3_sdlg ) 
                     OAleaf4_fire = kst_firez * ( Aleaf4 - Aleaf4_sdlg ) 
                                                 !m2 (m2 ground)-1 day-1.
                  !MXle1-4 (kg foliage structural DM stem-1):
                     OXle1_fire = kst_firez * ( MXle1 - MXle1_sdlg ) 
                     OXle2_fire = kst_firez * ( MXle2 - MXle2_sdlg ) 
                     OXle3_fire = kst_firez * ( MXle3 - MXle3_sdlg ) 
                     OXle4_fire = kst_firez * ( MXle4 - MXle4_sdlg ) 
                     !Sum these to give:
                        OXle_fire = OXle1_fire + OXle2_fire + &
                                    OXle3_fire + OXle4_fire 
                  !Wle (kg foliage water stem-1):
                     OWle_fire = kst_firez * ( Wle - Wle_sdlg )
                                                         !kg W stem-1 day-1.

               !Per unit ground area output fluxes resulting from the above:
                  OCSle_fire_gnd = nstems * OCSle_fire   !kg CS m-2 day-1.
                  ONSle_fire_gnd = nstems * ONSle_fire   !kg NS m-2 day-1.
                  ONph_fire_gnd = nstems * ONph_fire     !kg N m-2 day-1.
                  OCXle_fire_gnd = nstems * fCleX * OXle_fire
                                                         !kg CX m-2 day-1.
                  ONXle_fire_gnd = nstems * fNleX * OXle_fire
                                                         !kg NX m-2 day-1.
                  OWle_fire_gnd = nstems * OWle_fire     !kg W m-2 day-1.

               !Where do we send these fluxes:
                  !C output is all input to atmosphere (mostly CO2, traces of 
                  !CO or CH4 depending on fire severity):
                     OCSle_fire_atm = OCSle_fire_gnd     !kg C m-2 day-1.
                     OCXle_fire_atm = OCXle_fire_gnd     !kg C m-2 day-1.
                         
                  !N output is part to the soil Namm pool and the rest to
                  !the atmosphere (NOx) (kg N m-2 day-1):
                    !soil Namm pool:
                     ONSle_fire_Namm = ftreeN_fire_Namm * ONSle_fire_gnd
                     ONph_fire_Namm = ftreeN_fire_Namm * ONph_fire_gnd
                     ONXle_fire_Namm = ftreeN_fire_Namm * ONXle_fire_gnd
                    !atmosphere:
                     ONSle_fire_atm = ONSle_fire_gnd - ONSle_fire_Namm 
                     ONph_fire_atm = ONph_fire_gnd - ONph_fire_Namm 
                     ONXle_fire_atm = ONXle_fire_gnd - ONXle_fire_Namm

                  !Water (W) output from foliage is to the atmosphere:  
                     !OWle_fire_gnd as above.
                     OWle_fire_atm = OWle_fire_gnd      !kg W m-2 day-1.

               !Total C, N, W outputs from foliage due to fire:
                  OCle_fire_gnd = OCSle_fire_gnd + OCXle_fire_gnd
                  ONle_fire_gnd = ONSle_fire_gnd + ONXle_fire_gnd &
                                + ONph_fire_gnd
                 !OWle_fire_gnd as above.                kg x m-2 day-1.

               !These enter the atmosphere and the soil ammonium pool:
                  OCle_fire_atm = OCSle_fire_atm + OCXle_fire_atm
                  ONle_fire_atm = ONSle_fire_atm + ONph_fire_atm &
                                + ONXle_fire_atm 
                  ONle_fire_Namm = ONSle_fire_Namm + ONph_fire_Namm &
                                 + ONXle_fire_Namm

                  OCle_fire_gnd_chk = Onstems_fire * ( MCle - MCle_sdlg )
                  ONle_fire_gnd_chk = Onstems_fire * ( MNle - MNle_sdlg )


            !Branches (br)
               !State variables
                  !MCSbr (kg branch substrate C stem-1):
                     OCSbr_fire = kst_firez * ( MCSbr - MCSbr_sdlg )
                                                         !kg CS stem-1 day-1.
                  !MNSbr (kg branch substrate N stem-1):
                     ONSbr_fire = kst_firez * ( MNSbr - MNSbr_sdlg )
                                                         !kg NS stem-1 day-1.
                  !MXbrm (kg branch meristem structural DM stem-1):
                     OXbrm_fire = kst_firez * ( MXbrm - MXbrm_sdlg )
                                                         !kg XDM stem-1 day-1.
                  !MXbr (kg branch structural DM stem-1):
                     OXbr_fire = kst_firez * ( MXbr - MXbr_sdlg )
                                                         !kg XDM stem-1 day-1.

               !Write structural DM fluxes in terms of structural C & N:
                  OCXbrm_fire = fCbrm * OXbrm_fire       !kg CXm stem-1 day-1.
                  ONXbrm_fire = fNbrm * OXbrm_fire       !kg NXm stem-1 day-1.
                  OCXbr_fire = fCbrX * OXbr_fire         !kg CX stem-1 day-1.
                  ONXbr_fire = fNbrX * OXbr_fire         !kg NX stem-1 day-1.

               !Per unit ground area output fluxes resulting from the above:
                  OCSbr_fire_gnd = nstems * OCSbr_fire   !kg CS m-2 day-1.
                  ONSbr_fire_gnd = nstems * ONSbr_fire   !kg NS m-2 day-1.
                  OCXbrm_fire_gnd = nstems * OCXbrm_fire !kg CXm m-2 day-1.
                  ONXbrm_fire_gnd = nstems * ONXbrm_fire !kg NXm m-2 day-1.
                  OCXbr_fire_gnd =  nstems * OCXbr_fire  !kg CX m-2 day-1.
                  ONXbr_fire_gnd =  nstems * ONXbr_fire  !kg NX m-2 day-1.

               !Where do we send these fluxes:
                  !C output from C substrate (CS) and meristem (CXm) is all
                  !input to atmosphere (mostly CO2, traces of CO or CH4
                  !depending on fire severity):
                     OCSbr_fire_atm = OCSbr_fire_gnd     !kg C m-2 day-1.
                     OCXbrm_fire_atm = OCXbrm_fire_gnd   !kg C m-2 day-1.
                  !C output from structural C (CX) is to atmosphere and 
                  !to charcoal (Char):
                     OCXbr_fire_atm = fbrstXC_fire_atm * OCXbr_fire_gnd
                     OCXbr_fire_Char = OCXbr_fire_gnd - OCXbr_fire_atm
                                                         !kg C m-2 day-1.
                     Constant fbrstXC_fire_atm = 1.0 !Fraction of
                        !branch, stem structural C to atmosphere.
                        !If this fraction is < 1, then the charcoal pool
                        !builds up relentlessly as there is no charcoal
                        !output.

                  !N outputs are part to the soil Namm pool and the rest to
                  !the atmosphere (NOx) (kg N m-2 day-1):
                     ONSbr_fire_Namm = ftreeN_fire_Namm * ONSbr_fire_gnd
                     ONXbrm_fire_Namm = ftreeN_fire_Namm * ONXbrm_fire_gnd
                     ONXbr_fire_Namm = ftreeN_fire_Namm * ONXbr_fire_gnd
                     ONSbr_fire_atm = ONSbr_fire_gnd - ONSbr_fire_Namm 
                     ONXbrm_fire_atm = ONXbrm_fire_gnd - ONXbrm_fire_Namm
                     ONXbr_fire_atm = ONXbr_fire_gnd - ONXbr_fire_Namm
                                                           !kg N m-2 day-1.

               !Total C, N outputs from branches to fire (kg x m-2 day-1):
                  OCbr_fire_gnd = OCSbr_fire_gnd + OCXbrm_fire_gnd &
                                + OCXbr_fire_gnd
                  ONbr_fire_gnd = ONSbr_fire_gnd + ONXbrm_fire_gnd &
                                + ONXbr_fire_gnd
                 !Checks on these two quantities are:
                  OCbr_fire_gnd_chk = Onstems_fire * ( MCbr - MCbr_sdlg )
                  ONbr_fire_gnd_chk = Onstems_fire * ( MNbr - MNbr_sdlg )

               !C is divided between atmosphere and charcoal:
                  OCbr_fire_atm = OCSbr_fire_atm + OCXbrm_fire_atm &
                                + OCXbr_fire_atm
                  OCbr_fire_Char = OCXbr_fire_Char

               !N is divided between atmosphere and ammonium:
                  ONbr_fire_atm = ONSbr_fire_atm + ONXbrm_fire_atm &
                                + ONXbr_fire_atm
                  ONbr_fire_Namm = ONSbr_fire_Namm + ONXbrm_fire_Namm &
                                 + ONXbr_fire_Namm


            !Stem (st)
               !State variables
                  !MCSst (kg stem substrate C stem-1):
                     OCSst_fire = kst_firez * ( MCSst - MCSst_sdlg )
                                                         !kg CS stem-1 day-1.
                  !MCstorest (kg stem storage C stem-1):
                     OCstorest_fire = kst_firez * &
                                      ( MCstorest - MCstorest_sdlg )
                                                       !kg C store m-2 day-1.
                  !MNSst (kg stem substrate N stem-1):
                     ONSst_fire = kst_firez * ( MNSst - MNSst_sdlg )
                                                         !kg NS stem-1 day-1.
                  !MXstm (kg stem meristem structural DM stem-1):
                     OXstm_fire = kst_firez * ( MXstm - MXstm_sdlg )
                                                         !kg XDM stem-1 day-1.
                  !MXst (kg stem structural DM stem-1):
                     OXst_fire = kst_firez * ( MXst - MXst_sdlg )
                                                         !kg XDM stem-1 day-1.

               !Write structural DM fluxes in terms of structural C & N:
                  OCXstm_fire = fCstm * OXstm_fire       !kg CXm stem-1 day-1.
                  ONXstm_fire = fNstm * OXstm_fire       !kg NXm stem-1 day-1.
                  OCXst_fire = fCstX * OXst_fire         !kg CX stem-1 day-1.
                  ONXst_fire = fNstX * OXst_fire         !kg NX stem-1 day-1.

               !Per unit ground area output fluxes resulting from the above:
                  OCSst_fire_gnd = nstems * OCSst_fire   !kg CS m-2 day-1.
                  OCstorest_fire_gnd = nstems * OCstorest_fire   
                                                       !kg C store m-2 day-1.
                  ONSst_fire_gnd = nstems * ONSst_fire   !kg NS m-2 day-1.
                  OCXstm_fire_gnd = nstems * OCXstm_fire !kg CXm m-2 day-1.
                  ONXstm_fire_gnd = nstems * ONXstm_fire !kg NXm m-2 day-1.
                  OCXst_fire_gnd =  nstems * OCXst_fire  !kg CX m-2 day-1.
                  ONXst_fire_gnd =  nstems * ONXst_fire  !kg NX m-2 day-1.

               !Where do we send these fluxes:
                  !C output from C substrate (CS), Cstore (Cstorest) and
                  !meristem (CXm) is input to atmosphere (kg C m-2 day-1):
                     OCSst_fire_atm = OCSst_fire_gnd     
                     OCstorest_fire_atm = OCstorest_fire_gnd 
                     OCXstm_fire_atm = OCXstm_fire_gnd 
                  !C output from structural C (CX) is to atmosphere and 
                  !to charcoal (Char) (kg C m-2 day-1):
                     OCXst_fire_atm = fbrstXC_fire_atm * OCXst_fire_gnd
                     OCXst_fire_Char = OCXst_fire_gnd - OCXst_fire_atm
                     !Constant fbrstXC_fire_atm = 1.0 See above.


                  !N outputs are part to the soil Namm pool and the rest to
                  !the atmosphere (NOx) (kg N m-2 day-1):
                     ONSst_fire_Namm = ftreeN_fire_Namm * ONSst_fire_gnd
                     ONXstm_fire_Namm = ftreeN_fire_Namm * ONXstm_fire_gnd
                     ONXst_fire_Namm = ftreeN_fire_Namm * ONXst_fire_gnd
                     ONSst_fire_atm = ONSst_fire_gnd - ONSst_fire_Namm 
                     ONXstm_fire_atm = ONXstm_fire_gnd - ONXstm_fire_Namm
                     ONXst_fire_atm = ONXst_fire_gnd - ONXst_fire_Namm

               !Total C, N outputs from stems to fire (kg x m-2 day-1):
                  OCst_fire_gnd = OCSst_fire_gnd + OCstorest_fire_gnd &
                                + OCXstm_fire_gnd &
                                + OCXst_fire_gnd
                  OCst_fire_atm = OCSst_fire_atm + OCstorest_fire_atm &
                                + OCXstm_fire_atm &
                                + OCXst_fire_atm
                  OCst_fire_Char = OCXst_fire_Char

                  ONst_fire_gnd = ONSst_fire_gnd + ONXstm_fire_gnd &
                                + ONXst_fire_gnd
                  ONst_fire_atm = ONSst_fire_atm + ONXstm_fire_atm &
                                + ONXst_fire_atm
                  ONst_fire_Namm = ONSst_fire_Namm + ONXstm_fire_Namm &
                                 + ONXst_fire_Namm
                 !Checks on these two quantities are:
                  OCst_fire_gnd_chk = Onstems_fire * ( MCst - MCst_sdlg )
                  ONst_fire_gnd_chk = Onstems_fire * ( MNst - MNst_sdlg )


            !Coarse roots (co)
               !State variables:
                  !MCSco (kg coarse roots substrate C stem-1):
                     OCSco_fire = kst_firez * ( MCSco - MCSco_sdlg )
                                                      !kg CS stem-1 day-1.
                  !MNSco (kg coarse roots substrate N stem-1):
                     ONSco_fire = kst_firez * ( MNSco - MNSco_sdlg )
                                                      !kg NS stem-1 day-1.
                  !MXcom (kg coarse roots meristem XDM stem-1):
                     OXcom_fire = kst_firez * ( MXcom - MXcom_sdlg )
                                                      !kg XDM stem-1 day-1.
                  !MXco (kg coarse roots structural DM stem-1):
                     OXco_fire = kst_firez * ( MXco - MXco_sdlg )
                                                      !kg XDM stem-1 day-1.

               !Write structural DM fluxes in terms of structural C & N:
                  OCXcom_fire = fCcom * OXcom_fire       !kg CXm stem-1 day-1.
                  ONXcom_fire = fNcom * OXcom_fire       !kg NXm stem-1 day-1.
                  OCXco_fire = fCcoX * OXco_fire         !kg CX stem-1 day-1.
                  ONXco_fire = fNcoX * OXco_fire         !kg NX stem-1 day-1.

               !Per unit ground area output fluxes resulting from the above:
                  OCSco_fire_gnd = nstems * OCSco_fire   !kg CS m-2 day-1.
                  ONSco_fire_gnd = nstems * ONSco_fire   !kg NS m-2 day-1.
                  OCXcom_fire_gnd = nstems * OCXcom_fire !kg CXm m-2 day-1.
                  ONXcom_fire_gnd = nstems * ONXcom_fire !kg NXm m-2 day-1.
                  OCXco_fire_gnd =  nstems * OCXco_fire  !kg CX m-2 day-1.
                  ONXco_fire_gnd =  nstems * ONXco_fire  !kg NX m-2 day-1.


               !Total C, N outputs from coarse roots due to fire
                                                        !(kg x m-2 day-1):
                  OCco_fire_gnd = OCSco_fire_gnd + OCXcom_fire_gnd &
                                + OCXco_fire_gnd
                  ONco_fire_gnd = ONSco_fire_gnd + ONXcom_fire_gnd &
                                + ONXco_fire_gnd
                 !Checks on these 2 quantities are: 
                  OCco_fire_gnd_chk = Onstems_fire * ( MCco - MCco_sdlg )
                  ONco_fire_gnd_chk = Onstems_fire * ( MNco - MNco_sdlg )

               !C, N outputs are input to the 3 soil litter pools:
                  OCco_fire_soil_li = OCco_fire_gnd !kg total C m-2 day-1.
                  ONco_fire_soil_li = ONco_fire_gnd !kg total N m-2 day-1.
                  ICSco_fire_soil_li = OCSco_fire_gnd !kg CS m-2 day-1.
                  INSco_fire_soil_li = ONSco_fire_gnd !kg NS m-2 day-1.
                  ICXco_fire_soil_li = OCXco_fire_gnd + OCXcom_fire_gnd 
                                                      !kg CX m-2 day-1.
                  INXco_fire_soil_li = ONXco_fire_gnd + ONXcom_fire_gnd
                                                      !kg NX m-2 day-1.


            !Fine roots (fi)
               !State variables
                  !MCSfi (kg fine roots substrate C stem-1):
                     OCSfi_fire = kst_firez * ( MCSfi - MCSfi_sdlg )
                                                      !kg CS stem-1 day-1.
                  !MNSfi (kg fine roots & mycorrhiza substrate N stem-1):
                     ONSfi_fire = kst_firez * ( MNSfi - MNSfi_sdlg )
                                                      !kg NS stem-1 day-1.
                  !MXfim (kg fine roots & mycorrhiza meristem XDM stem-1):
                     OXfim_fire = kst_firez * ( MXfim - MXfim_sdlg )
                                                      !kg XDM stem-1 day-1.
                  !MXfi1-4 (kg fine roots structural DM stem-1):
                     OXfi1_fire = kst_firez * ( MXfi1 - MXfi1_sdlg )
                     OXfi2_fire = kst_firez * ( MXfi2 - MXfi2_sdlg )
                     OXfi3_fire = kst_firez * ( MXfi3 - MXfi3_sdlg )
                     OXfi4_fire = kst_firez * ( MXfi4 - MXfi4_sdlg )
                     !Sum these to give
                        OXfi_fire = OXfi1_fire + OXfi2_fire &
                                  + OXfi3_fire + OXfi4_fire 
                  !Wfi (kg fine roots water stem-1):
                     OWfi_fire = kst_firez * ( Wfi - Wfi_sdlg )
                                                           !kg W m-2 day-1.

               !Write structural DM fluxes in terms of structural C & N:
                  OCXfim_fire = fCfim * OXfim_fire       !kg CXm stem-1 day-1.
                  ONXfim_fire = fNfim * OXfim_fire       !kg NXm stem-1 day-1.
                  OCXfi_fire = fCfiX * OXfi_fire         !kg CX stem-1 day-1.
                  ONXfi_fire = fNfiX * OXfi_fire         !kg NX stem-1 day-1.

               !Per unit ground area output fluxes resulting from the above:
                  OCSfi_fire_gnd = nstems * OCSfi_fire   !kg CS m-2 day-1.
                  ONSfi_fire_gnd = nstems * ONSfi_fire   !kg NS m-2 day-1.
                  OCXfim_fire_gnd = nstems * OCXfim_fire !kg CXm m-2 day-1.
                  ONXfim_fire_gnd = nstems * ONXfim_fire !kg NXm m-2 day-1.
                  OCXfi_fire_gnd =  nstems * OCXfi_fire  !kg CX m-2 day-1.
                  ONXfi_fire_gnd =  nstems * ONXfi_fire  !kg NX m-2 day-1.
                  OWfi_fire_gnd = nstems * OWfi_fire     !kg W m-2 day-1.

               !Total C, N outputs from fine roots to fire (kg C, N m-2 day-1):
                  OCfi_fire_gnd = OCSfi_fire_gnd + OCXfim_fire_gnd &
                                + OCXfi_fire_gnd
                  ONfi_fire_gnd = ONSfi_fire_gnd + ONXfim_fire_gnd &
                                + ONXfi_fire_gnd
                 !These can be checked with:
                  OCfi_fire_gnd_chk = Onstems_fire * ( MCfi - MCfi_sdlg )
                  ONfi_fire_gnd_chk = Onstems_fire * ( MNfi - MNfi_sdlg )

               !C, N outputs are input to soil litter:
                  OCfi_fire_soil_li = OCfi_fire_gnd !kg total C m-2 day-1.
                  ONfi_fire_soil_li = ONfi_fire_gnd !kg total N m-2 day-1.
                  ICSfi_fire_soil_li = OCSfi_fire_gnd !kg CS m-2 day-1.
                  INSfi_fire_soil_li = ONSfi_fire_gnd !kg NS m-2 day-1.
                  ICXfi_fire_soil_li = OCXfi_fire_gnd + OCXfim_fire_gnd 
                                                      !kg CX m-2 day-1.
                  INXfi_fire_soil_li = ONXfi_fire_gnd + ONXfim_fire_gnd
                                                      !kg NX m-2 day-1.

               !W(ater) from fine roots is input to soil water pool:
                     IWfi_fire_Wsoil = OWfi_fire_gnd      !kg W m-2 day-1.


         !Trees.  Aggregated C, N, W fluxes from trees due to fire.
            !Atmosphere (_atm) (kg C, N, W m-2 day-1):
               OCtree_fire_atm = OCbud_fire_atm + OCle_fire_atm &
                               + OCbr_fire_atm + OCst_fire_atm 
               ONtree_fire_atm = ONbud_fire_atm + ONle_fire_atm &
                               + ONbr_fire_atm + ONst_fire_atm  
               OWtree_fire_atm = OWbud_fire_atm + OWle_fire_atm 
            !Charcoal (_Char) (kg C m-2 day-1):
               OCtree_fire_Char = OCbr_fire_Char + OCst_fire_Char 
            !Ammonium (_Namm) (kg N m-2 day-1):
               ONtree_fire_Namm = ONbud_fire_Namm + ONle_fire_Namm &
                                + ONbr_fire_Namm + ONst_fire_Namm 
            !Soil litter (_soil_li) (kg C, N m-2 day-1):
               OCtree_fire_soil_li = OCco_fire_soil_li + OCfi_fire_soil_li
               ONtree_fire_soil_li = ONco_fire_soil_li + ONfi_fire_soil_li
            !Whole-tree N output (kg N m-2 day-1):
               ONtree_fire = ONtree_fire_atm + ONtree_fire_Namm + &
                             ONtree_fire_soil_li            
   
               ICtree_fire_Char = OCtree_fire_Char          !kg C m-2 day-1.
               INtree_fire_Namm = ONbud_fire_Namm + ONle_fire_Namm &
                                + ONbr_fire_Namm + ONst_fire_Namm 
                                                            !kg N m-2 day-1.
                                                            !kg W m-2 day-1.
           
      !End Effects of fire on the trees.


   !Effects of fire on surface litter
      !Rate constant for burning surface litter during the fire events:    
      ksurf_li_firez = s_fire * ( &
         ksurf_li_fire( 1 )  * PULSE ( tfire ( 1 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 2 )  * PULSE ( tfire ( 2 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 3 )  * PULSE ( tfire ( 3 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 4 )  * PULSE ( tfire ( 4 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 5 )  * PULSE ( tfire ( 5 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 6 )  * PULSE ( tfire ( 6 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 7 )  * PULSE ( tfire ( 7 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 8 )  * PULSE ( tfire ( 8 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 9 )  * PULSE ( tfire ( 9 ),  c365E6, tau_fire ) + &
         ksurf_li_fire( 10 ) * PULSE ( tfire ( 10 ), c365E6, tau_fire ) )
                                                                     !day-1.
         !Constant c365E6 = 365 x 10**6 !days = 10**6 years (in days).
            !This number is set to a large value. Its actual value does
            !not matter, as long as it is larger than the runtime, tstop.

      !The fraction of each surface litter pool which is burnt is mostly
      !converted to atmospheric C (mostly CO2, maybe some CO and CH4), the
      !rest to charcoal.  N is converted partly to Namm (input to the soil
      !N ammonium pool), and the rest to the atmosphere (NOx).
         !The 4 surface litter pools are: Csurf_li_met, Nsurf_li_met, 
      !Csurf_li_cel (rCNcel), Csurf_li_lig (rCNlig).
      !Outputs from the four pools:
          OCsurf_li_met_fire = ksurf_li_firez * Csurf_li_met !kg C m-2 day-1.
          ONsurf_li_met_fire = ksurf_li_firez * Nsurf_li_met !kg N m-2 day-1.
          OCsurf_li_cel_fire = ksurf_li_firez * Csurf_li_cel !kg C m-2 day-1.
          OCsurf_li_lig_fire = ksurf_li_firez * Csurf_li_lig !kg C m-2 day-1.
      !Total C and N outputs:
          OCsurf_li_fire = OCsurf_li_met_fire + OCsurf_li_cel_fire &
                                              + OCsurf_li_lig_fire
          ONsurf_li_fire = ONsurf_li_met_fire + OCsurf_li_cel_fire / rCNcel &
                                              + OCsurf_li_lig_fire / rCNlig
      !C is output in part to the atmosphere:
          OCsurf_li_fire_atm = fsurf_liC_fire_atm * OCsurf_li_fire
             Constant fsurf_liC_fire_atm = 1.0
      !and the rest to charcoal:
          OCsurf_li_fire_Char = OCsurf_li_fire - OCsurf_li_fire_atm
                                                             !kg C m-2 day-1.
          ICsurf_li_fire_Char = OCsurf_li_fire_Char !Input to Char pool.
      
      !N is output partly to Namm (soil N ammonium pool):
          ONsurf_li_fire_Namm = fsurf_liN_fire_Namm * ONsurf_li_fire
             Constant fsurf_liN_fire_Namm = 0.25 !Dimensionless. Fraction
                !of N in the burnt portion of surface litter which enters
                !soil ammonium pool, Namm.
                !Severe fire value is default.
          INsurf_li_fire_Namm = ONsurf_li_fire_Namm !Without loss.
      !and the rest to the atmosphere (NOx):
          ONsurf_li_fire_atm = ONsurf_li_fire - ONsurf_li_fire_Namm

   !End Effects of fire on surface litter.

!END of FIRE (Derivative section. Effects of fire on trees and surface litter).


!NUMBER OF STEMS, nstems (m-2)
   !Thinning and thinning fluxes (th)
      !Thinning in plantation mode is switched on with s_thin = 1.
      !Default: s_thin = 0.  No thinning.

   !Pulsed rate function for thinning in plantation mode, kpulse_thin, is:
      kpulse_thin = s_thin * ( &
  kthin ( 1 )  * PULSE ( tthin ( 1 ),  clarge, tau_thin ) + &
  kthin ( 2 )  * PULSE ( tthin ( 2 ),  clarge, tau_thin ) + &
  kthin ( 3 )  * PULSE ( tthin ( 3 ),  clarge, tau_thin ) + &
  kthin ( 4 )  * PULSE ( tthin ( 4 ),  clarge, tau_thin ) + &
  kthin ( 5 )  * PULSE ( tthin ( 5 ),  clarge, tau_thin ) + &
  kthin ( 6 )  * PULSE ( tthin ( 6 ),  clarge, tau_thin ) + &
  kthin ( 7 )  * PULSE ( tthin ( 7 ),  clarge, tau_thin ) + &
  kthin ( 8 )  * PULSE ( tthin ( 8 ),  clarge, tau_thin ) + &
  kthin ( 9 )  * PULSE ( tthin ( 9 ),  clarge, tau_thin ) + &
  kthin ( 10 ) * PULSE ( tthin ( 10 ), clarge, tau_thin ) + &
  kthin ( 11 ) * PULSE ( tthin ( 11 ), clarge, tau_thin ) + &
  kthin ( 12 ) * PULSE ( tthin ( 12 ), clarge, tau_thin ) + &
  kthin ( 13 ) * PULSE ( tthin ( 13 ), clarge, tau_thin ) + &
  kthin ( 14 ) * PULSE ( tthin ( 14 ), clarge, tau_thin ) + &
  kthin ( 15 ) * PULSE ( tthin ( 15 ), clarge, tau_thin ) )
                                                                     !day-1.
         !Constant clarge = 7.7777E17 !days. This constant
            !is set to a large value. Its actual value does
            !not matter, as long as it is larger than the runtime, tstop.
            !Thinning takes place over 1 d (default value) beginning at
            !the times in the array tthin(i).
  
   !Calculation of thinning fluxes.
         !Stems:
            Onstems_th = kpulse_thin * nstems   !stems m-2 day-1.

         !Buds (bud):
            OCbud_th = Onstems_th * MCbud       !kg C m-2 day-1.
            ONbud_th = Onstems_th * MNbud       !kg N m-2 day-1.

         !Foliage (le):
            OCSle_th =  Onstems_th * MCSle      !kg substrate C m-2 day-1.
            ONSle_th =  Onstems_th * MNSle      !kg substrate N m-2 day-1.
            ONph_th =   Onstems_th * MNph  !kg photosynthetic N m-2 day-1.
            OCXle_th =  Onstems_th * MCXle     !kg structural C m-2 day-1.
            ONXle_th =  Onstems_th * MNXle     !kg structural N m-2 day-1.
            OCle_th =   OCSle_th + OCXle_th               !kg C m-2 day-1.
            ONle_th =   ONSle_th + ONph_th + ONXle_th     !kg N m-2 day-1.

         !Branches (br):
            OCSbr_th = Onstems_th * MCSbr       !kg substrate C m-2 day-1.
            ONSbr_th = Onstems_th * MNSbr       !kg substrate N m-2 day-1.
            OCXbr_th = Onstems_th * MCXbrtot    !kg structural C m-2 day-1.
            ONXbr_th = Onstems_th * MNXbrtot    !kg structural N m-2 day-1. 
            OCbr_th =  OCSbr_th + OCXbr_th      !kg C m-2 day-1.
            ONbr_th =  ONSbr_th + ONXbr_th      !kg N m-2 day-1.

         !Stem (st):
            OCSst_th = Onstems_th * MCSst       !kg substrate C m-2 day-1.
            OCstorest_th = Onstems_th * MCstorest
                                                !kg storage C m-2 day-1.
            ONSst_th = Onstems_th * MNSst       !kg substrate N m-2 day-1.
            OCXst_th = Onstems_th * MCXsttot    !kg structural C m-2 day-1.
            ONXst_th = Onstems_th * MNXsttot    !kg structural N m-2 day-1.
            OCst_th =  OCSst_th + OCstorest_th + OCXst_th 
                                                !kg total C m-2 day-1.
            ONst_th =  ONSst_th + ONXst_th      !kg total N m-2 day-1.

         !Coarse roots (co):
            OCSco_th = Onstems_th * MCSco       !kg substrate C m-2 day-1.
            ONSco_th = Onstems_th * MNSco       !kg substrate N m-2 day-1.
            OCXco_th = Onstems_th * MCXcotot    !kg structural C m-2 day-1.
            ONXco_th = Onstems_th * MNXcotot    !kg structural N m-2 day-1.
            OCco_th =  OCSco_th + OCXco_th      !kg C m-2 day-1.
            ONco_th =  ONSco_th + ONXco_th      !kg N m-2 day-1.

         !Fine roots and mycorrhiza (fi):
            OCSfi_th = Onstems_th * MCSfi       !kg substrate C m-2 day-1.
            ONSfi_th = Onstems_th * MNSfi       !kg substrate N m-2 day-1.
            OCXfi_th = Onstems_th * MCXfitot    !kg structural C m-2 day-1.
            ONXfi_th = Onstems_th * MNXfitot    !kg structural N m-2 day-1.
            OCfi_th =  OCSfi_th + OCXfi_th      !kg C m-2 day-1.
            ONfi_th =  ONSfi_th + ONXfi_th      !kg N m-2 day-1.
 
         !Total C, N fluxes from thinnings:
            OCtree_th = OCbud_th &
                           + OCSle_th + OCXle_th &
                           + OCSbr_th + OCXbr_th &
                           + OCSst_th + OCstorest_th + OCXst_th &
                           + OCSco_th + OCXco_th &
                           + OCSfi_th + OCXfi_th    !kg C m-2 day-1.
            ONtree_th =   ONbud_th &
                           + ONSle_th + ONXle_th + ONph_th &
                           + ONSbr_th + ONXbr_th &
                           + ONSst_th + ONXst_th &
                           + ONSco_th + ONXco_th &
                           + ONSfi_th + ONXfi_th    !kg N m-2 day-1. 
   
      !The thinned trees go into the litter pools except for fractions of the
         !branches, fbr_rem_th_prod, and of the
         !stems, fst_rem_th_prod, 
         !which go into the thinning product pools.
          Constant fbr_rem_th_prod = 0.1 !a low value for Sitka.
          Constant fst_rem_th_prod = 0.8
   
      !This gives fluxes of
         !C, N, water (W), into the gross (non-decaying) product pools,
         !Cpt, Npt, Wpt, and into the 
         !decaying product pools, Cptd, Nptd, Wptd.


         !Fluxes of C, N into products (pr) (kg C, N m-2 day-1):
            ICSbrth_pr = OCSbr_th * fbr_rem_th_prod
            ICXbrth_pr = OCXbr_th * fbr_rem_th_prod
            INSbrth_pr = ONSbr_th * fbr_rem_th_prod
            INXbrth_pr = ONXbr_th * fbr_rem_th_prod
            ICSstth_pr = OCSst_th * fst_rem_th_prod
            ICstorestth_pr = OCstorest_th * fst_rem_th_prod 
            ICXstth_pr = OCXst_th * fst_rem_th_prod
            INSstth_pr = ONSst_th * fst_rem_th_prod
            INXstth_pr = ONXst_th * fst_rem_th_prod
              
            ICbrth_pr = ICSbrth_pr + ICXbrth_pr
            INbrth_pr = INSbrth_pr + INXbrth_pr
            ICstth_pr = ICSstth_pr + ICstorestth_pr + ICXstth_pr
            ONst_pr = INSstth_pr + INXstth_pr

            ICth_pr = ICbrth_pr + ICstth_pr
            INth_pr = INbrth_pr + ONst_pr

         !Surface litter:
            !Fluxes of C substrates + Cstore in st, N substrates + 
               !photosynthetic N:
               ICSth_surf_li = OCSle_th &
                               + OCSbr_th + OCSst_th + OCstorest_th &
                               - ICSbrth_pr - ICSstth_pr - ICstorestth_pr
               INSphth_surf_li = ONSle_th + ONph_th + ONSbr_th + ONSst_th &
                                 - INSbrth_pr - INSstth_pr
                             !kg C, N substrate, photosynthetic N m-2 day-1.
            !Fluxes of C, N structure:
               ICXth_surf_li = OCbud_th + OCXle_th + OCXbr_th + OCXst_th &
                                                   - ICXbrth_pr - ICXstth_pr
               INXth_surf_li = ONbud_th + ONXle_th + ONXbr_th + ONXst_th &
                                                   - INXbrth_pr - INXstth_pr
                                               !kg C, N structure m-2 day-1.
            !Total C, N fluxes:
               ICth_surf_li = ICSth_surf_li + ICXth_surf_li 
               INth_surf_li = INSphth_surf_li + INXth_surf_li
                                                   !kg total C, N m-2 day-1.

         !Soil litter:
            !Fluxes of C, N substrate (S), C, N structure (X):
               ICSth_soil_li = OCSco_th + OCSfi_th 
               ICXth_soil_li = OCXco_th + OCXfi_th 
               INSth_soil_li = ONSco_th + ONSfi_th 
               INXth_soil_li = ONXco_th + ONXfi_th 
                             !kg C, N substrate, C, N structure m-2 day-1.
            !Total C, N fluxes:
               ICth_soil_li = ICSth_soil_li + ICXth_soil_li
               INth_soil_li = INSth_soil_li + INXth_soil_li
                             !kg total C, N m-2 day-1.

            !Total C, N fluxes into surface and soil litter:
               ICth_litter = ICth_surf_li + ICth_soil_li
               INth_litter = INth_surf_li + INth_soil_li
                             !kg total C, N m-2 day-1.

            !Water fluxes to litter and soil (kg water m-2 day-1):
               OWbud_th = Onstems_th * MWbud
               OWle_th = Onstems_th * Wle
               OWfi_th = Onstems_th * Wfi
               OWtree_th = OWbud_th + OWle_th + OWfi_th

         !Water fluxes
            !Flux of water into the soil water pool (kg water m-2 day-1):
               IWth_Wsoil = OWtree_th
            !Flux of water into the products water pool (kg water m-2 day-1):
               !is zero without branches and stem water pools:
               OWth_pr = zero 
!   PROCEDURAL
!      ilogd = i6
!      IF ( calllogd ) CALL LOGD( .true. ) 
!   END

   !Self-thinning (sn) 
      !Natural forest is simulated by a birth (generation) process, and 
      !a death (self-thinning) process.  In equilibrium, these are equal.
         Constant s_selfthin = 0.0  !Self-thinning is switched off by default.
      !Self-thinning processes are turned off if the tree (deciduous)
      !has no leaves (s_leaf = 0), which lasts from the beginning of
      !dormancy until the end of budburst.
      !The first day of dormancy is when the remaining leaves fall off.
   
      !Birth/generation of new stems
         !Fractional rate of stem birth/generation in natural forest
         !FBRnstems (day-1 = new stems stem-1 day-1).
            !Two alternatives are provided.

            !1. Stem generation depends directly on tree (tr) variables.
                Constant kFBRnstems20 = 0.5  !Rate constant. 
                             !(kg XDM stem-1)-1 ([CN] in tree)-1 d-1.
                                    fTWsoil = fTsoil * fWsoil
                   kFBRnstems = kFBRnstems20 * fTWsoil
                   !FBRnstemstrz = kFBRnstems * MXtree * CNtree * fgerm_light 
                   !day-1. Below.
                !Effect of light on seed germination.  Assume light promotes
                   !seed germination.
                   fgerm_light = ( one - fgerm_light_min ) * exp_kcanLAI &
                                      + fgerm_light_min 
                      !Fraction by which germination rate is decreased due to 
                      !light level on ground.
                      Constant fgerm_light_min = 0.1 !Dimensionless. 
                                            !Minimum value of fgerm_light.
                      !exp_kcanLAI = exp (- kcan * LAI). Relative light on
                      !ground. 
                      !LAI = 0, exp_kcanLAI = 1, fgerm_light = 1.
                      !LAI = 7, fgerm_light = c 0.12.
                      !LAI = large, exp_kcanLAI ~ 0, 
                          !fgerm_light = fgerm_light_min.

                !Assume seed production per stem is ~ tree structural mass
                   !per stem (MXtree) * tree nutritional state, CNtree, 
                   !where CNtree is given below.

               FBRnstemstrz = kFBRnstems &
                                 * MXtree * CNtree * fgerm_light    !day-1.
                  !For MXtree = 10 kg XDM stem-1, CNtree = 1.0e-4 [C][N],
                     !fgerm_light = 1, 
                     !then FBRnstemstr = 0.1 * 10 * 0.0001 = 0.0002 day-1 
                     != (* 365 day year-1) = 0.036 year-1 = 4% per year.
                     !Should you make this differently dependent on x = CNtree?
                     !eg fbr ~ x**2 / ( 1 + x/b + x**2/c )?

               FBRnstemstr = s_selfthin * one_leaf_fall &
                                * FBRnstemstrz              !day-1.
                  !FBRnstemstr = 0 during leaf fall when 
                     !leaf_fall = 1 and one - leaf_fall = 0.
               !We make FBRnstems and FDRnstems (below) zero during
               !leaf fall because otherwise the C, N, W(ater) accounting
               !becomes difficult.  This is because at the end of leaf fall
               !(lasts one day), the leaf variables are approx zero.  This is
               !achieved by setting an output flux to leaf fall 
               !see "OAleaf1_lf = " above) constant during the day when
               !leaf fall takes place and all other fluxes equal to zero.
               !Note that Dnstems comes into the conservation equations.

            !2. Stem generation depends seed production and germination.
               !For FBRnstemssd, see SEEDS section below. 

               !Finally, self-thinning (sn) fractional stem birth rate, 
                  !FBRnstems (day-1) is either dependent directly on the tree
                  !variables (FBRnstemstr, above) or
                  !is obtained by seed germination (FBRnstemssd).

                  FBRnstems = ( one_s_seeds ) * FBRnstemstr &
                               + s_seeds   * FBRnstemssd         !day-1.
                  FBRnstems_sn = FBRnstems !Not used.
          !Default self-thinning via tree variables is switched on with
          !"selfthin" in efm.cmd:
             !s_seeds = 0, one_s_seeds = 1. Seed germination is off.
          !Thus: FBRnstemstr (tree variables) is used and not FBRnstemssd
             !(via seed germination in a soil seed bank.

      !Input to nstems from stem generation when self-thinning is switched on:
         Instems_sn = nstems * FBRnstems         !number of stems m-2 day-1.
   
      !Stem death from self-thinning.  Only one option provided.
         !Fractional death rate (FDR) from self-thinning of stems, 
         !FDRnstems (day-1).
         !Make LAI term initially square so it is small at low LAI, 
             !and then linear
         !and stop 1/CNtree diverging at low values of CNtree.
!   PROCEDURAL
!      ilogd = i7
!      IF ( calllogd ) CALL LOGD( .true. ) 
!   END
                 z1_FDRnstems = LAIsq / ( KLAIstdeath + LAI ) 
                 z2_FDRnstems = one / ( CNtree + KCNtreestdeath ) 
               FDRnstemsz = kFDRnstems20 * fTsh &
                             * z1_FDRnstems * z2_FDRnstems    !d-1.
                     Constant kFDRnstems20 = 1.0E-7  !Self-thinning constant
                                                    !day-1 [CN] [LAI]-1.
                     Constant KLAIstdeath = 5        ![LAI]
                     !Constant KCNtreestdeath = 1.0E-6![CN]. This value gave
                        !much chaotic behaviour.  Changed 29 Nov 2017 to
                     Constant KCNtreestdeath  = 1.0E-4![CN]
                    !Maybe make this 1.0e-3 to make the change in z2_fdr..
                    !less extreme.
                    !fTsh = 1, LAI = 5, LAIsq = 25, CNtree = 0.5E-4, 
                    !FDR = E-7 x (25/10) x 10000 = 2.5E-3 day-1.
               FDRnstems = s_selfthin * one_leaf_fall & 
                                        * FDRnstemsz               !day-1.  
               FDRnstems_sn = FDRnstems !Not used.
            Onstems_sn = nstems * FDRnstems !number of stems m-2 day-1.
                        !Output from nstems pool to self-thinning.
   
      
      !Birth and death combined
         !Self-thinning
            !Absolute growth rate of nstems from self-thinning:
                Dnstems_sn = Instems_sn - Onstems_sn          !stems m-2 day-1.
            !Fractional growth rate in nstems from self-thinning:
                FGRnstems_sn = FBRnstems - FDRnstems      !day-1.
                !Note that this can be positive or negative.
            !Self-thinning death only removes material from branch,
               !stem, coarse root structural dry matter pools (MXbr, MXst,
               !and MXco), giving an additional flux into the corresponding
               !litter pools of e.g. FDRnstems * MXbr.  Look at eqns for
               !OXle4_li =, OXbr_li =, OXst_li =, OXco_li =, OXfi4_li =.
            !Changing stem number density (nstems) from self-thinning death
               !and birth/generation readjusts all the tree
               !pools Q (which are on a per stem basis) so that the matter per 
               !unit ground area etc is conserved, according to
               !dQ/dt = IQ - OQ - FGRnstems_sn * Q.
               !This is derived from d/dt (n * Q) = n * IQ - n * OQ
               !That is, there is a self-thinning output from the Q pool of
               !OQ_sn = FGRnstems_sn * Q   !Amount of Q stem-1 day-1.
               !eg, look at eqn for <OCSle_sn = >.
   
      !Differential equation:
                   Instems = Instems_sn 
                   Onstems = Onstems_sn + Onstems_th
                      !Note: no output from nstems due to pruning.
                      !It is assumed that stem pruning does not change
                      !stem density, nstems. Changes in stem density are
                      !achieved by thinning. However, there are changes in
                      !per stem stem variables due to pruning.  See below.
                      !Search " kst_prune".
                      !Onstems_sn = output to selfthinning. See above.
         Dnstems = Instems - Onstems
                   Dnstemsmaxt = Dnstems * maxt  !For debugging.

      !Integration statement:
         nstems = INTEG( Dnstems, nstems0 )
         IF ( nstems .GT. zero ) THEN
              log10nstems = LOG10( nstems )
              Acanmax_nstems = one / nstems !m2. Area of canopy, maximum
                                            !value determined by nstems.
              dcanmax_nstems = SQRT( Acanmax_nstems ) !m. Maximum diameter
                                           !of canopy determined by nstems.
         ELSE
              log10nstems = csmall
              Acanmax_nstems = clarge
              dcanmax_nstems = clarge
         ENDIF
   
      !Fractional growth rate of change of nstems:
         FGRnstems = Dnstems / nstems                             !day-1.
   
      !Self-thinning exponents (indicated here by sn, so that we do not
         !confuse st denoting stem): 
         IF ( FGRnstems .NE. zero ) THEN
              sn_exp =     - sgrMtree / FGRnstems
              sn_expMXst = - sgrMXst / FGRnstems
              sn_expMXtree = - sgrMXtree / FGRnstems
         ELSE
              sn_exp =     csmall
              sn_expMXst = csmall
              sn_expMXtree = csmall
         ENDIF

      !End of nstems section.


!SEEDS (seeds).  This is an experimental section. 
   !A single seed pool is assumed, in the soil. 
   !STATE VARIABLE, nseeds ( # seeds m-2 ).

   !This section operates if s_seeds = 0 or 1.
   Constant s_seeds = 0 !is the default. 
   !But the effect on tree generation via the soil seed bank is only applied
   !if s_seeds = 1.  See "FBRnstems =" statement above.

   !Seed production
          MXtree_seeds = MXtree                     !kg tree XDM stem-1.
             !This is similar to (but simpler than) the quadratic asymptotic
             !eqn:
                !MXtree_seeds = MXtree * MXtree / ( KMXtree_seed + MXtree )
                !with KMXtree_seed = 0.
                !Constant KMXtree_seed = 20 !kg XDM stem-1.
                !Initially quadratic, then asymptotically linear: = MXtree.
                !This was tried, so that small trees did not give seeds.
            !When MXtree = 99, MXtree_seeds  = 82 (9801/119) kg XDM stem-1
            !When MXtree = 40, MXtree_seeds  = 27 (1600/60)  kg XDM stem-1
            !When MXtree = 20, MXtree_seeds  = 10 (400/40)   kg XDM stem-1
            !              10                     3 (100/30)
            !               5                     1  (25/25)
            !               2                     0.2 (4/22)
            !               1                     0.05 (1/21)
         !Constant KMXtree_seed = 0 gives MXtree_seed = MXtree.
         !Note: with MXtree_seed = MXtree there is no developmental delay 
         !in seed production, to correspond to a young seedling reaching
         !a certain size (mature enough to produce seeds).

      Otree_nseeds = nstems * ktree_seeds20 * fTsh * MXtree_seeds &
                            * CNbr                      !# seeds m-2 day-1.
         Constant ktree_seeds20 = 2  !seeds (kg tree XDM)-1 [CN]-1 day-1.
                                     !Seed production constant at 20 oC.
         !For nstems = 0.5, fTsh = 1, MXtree = 40, CNbr = 0.0002,
         !Otree_nseeds = 0.5 * 2 * 1 * 30 * 0.0002 = 0.006 seed m-2 day-1.
         !This will have the seasonality of fTsh and CNbr.  
         !We are not going to impose additional seasonality constraints 
         !on top of this.
      Itree_nseeds = Otree_nseeds 
      Inseeds = Itree_nseeds !# seeds m-2 day-1. Input to soil seed pool.


   !Seed outputs
      !1. Seed losses
          Onseeds_death = fTWsoil * nseeds * kseed_death20
                                                   !Seeds dying m-2 day-1.
                    Constant kseed_death20 = 0.01  !day-1.
          Onseeds_deat = Onseeds_death !Output only.

      !2. Germination
          Onseeds_germ = fTsoil * ( fWsoil ** qWgerm ) * nseeds &
                                * kseed_germ20 * fgerm_light 
                                             !Seeds germinating m-2 day-1.
                                Constant qWgerm = 3 !Dimensionless.
             !fWsoil = aWsoil ** ( s_water * qWsoil ) !Soil W fn, qWsoil = 20
             !Is this rubbish? Should we define an fWgerm by
             !eg, fWgerm = aWsoil ** ( s_water * qWgerm ) and then write     
!          Onseeds_germ = fTsoil * fWgerm  * nseeds &
!                                * kseed_germ20 * fgerm_light 
          !so that a drying soil does not altogether inhibit seed germination?
      
                                Constant kseed_germ20 = 0.003   !day-1.
                               !See above for fgerm_light, fraction 
                               !germinating as affected by ground-level
                               !light. High LAI --> low light on ground
                               !--> low germination.
          IF ( nstems .NE. zero ) THEN
               FBRnstemssdz = Onseeds_germ / nstems !day-1. 
          ELSE      !Fractional birth rate of nstems from seed germination.
               FBRnstemssdz = clarge !Large no: 7.7777e17.
          ENDIF
               FBRnstemssd = s_selfthin * one_leaf_fall &
                                           * FBRnstemssdz        !day-1. 

                               
      !Total seed output
          Onseeds = Onseeds_death + Onseeds_germ  !Seeds m-2 day-1.

      !Fractional growth rate of nseeds
         IF ( nseeds .GT. zero ) THEN
              FGRnseeds = Dnseeds / nseeds                         !day-1.
         ELSE
              FGRnseeds = clarge
         ENDIF
       
   !Differential equation
      Dnseeds = treevr * ( Inseeds - Onseeds ) !kg bud DM stem-1 day-1.
                        !kg bud DM stem-1 d-1. nseeds is assumed to be a tree
                        !state variable.
       nseeds = INTEG( Dnseeds, nseeds0 )    !kg bud DM stem-1.
                       Constant nseeds0 = 0  !# seeds m-2.


!BUDS (bud), bud mass, Mbud (kg structural dry mass stem-1)
   !Buds are described by a single state variable, Mbud, with a constant
   !C:N ratio, fCbud/fNbud, and a constant ratio of water to structural
   !mass, rWXbud.

   !Input, IMbud. kg structural dry matter stem-1 day-1.
      !There is a single input to Mbud.  This growth term is calculated as
      !an output from branches substrate C and N, and foliage substrate
      !C and N, when leaves are present. 
         IMbud = Gbud               

      !Growth of buds, Gbud (kg structural dry matter stem-1 day-1).
         !Buds grow at the expense of branches substrate C and N,
         !and foliage substrate C and N if leaves are present.

         !Define a function of foliage water stress, because bud growth is
            !much decreased by water stress.
                fGbud_thetaleq = fthetale_gs ** qGbud_thetale 
             fGbud_thetale = one - s_leaf + s_leaf * fGbud_thetaleq
                                     Constant qGbud_thetale = 5 !Guessed.
                !When no leaves are present (s_leaf = 0), fGbud_thetale = 1.
                !When leaves are present (s_leaf = 1), fGbud_thetale = 
                !a function which which decreases as increasing water
                !stress (decreasing thetale) closes the stomates.
                !This dimensionless function slows down the rates of 
                !bud synthesis and bud opening when water
                !stress (thetale) closes the stomates (fthetale_gs 
                !decreases - see p 117).
         !Bud growth rate constants.
             kGlebud = kGlebud20 * fTWst * fGbud_thetale
             kGbrbud = kGbrbud20 * fTWst * fGbud_thetale
                Constant kGlebud20 = 200, kGbrbud20 = 200
                       !([CS] [NS] day)-1. Growth rate constant.
                       !fTWst = fTst * fWst is a combined temperature and
                       !water function for the stem. There is no fTWbr.
               !Intrinsic specific growth rate of buds, ISGRbud (day-1):
                   IF ( s_leaf .EQ. one ) THEN !leaves are present.
                        ISGRbud = kGlebud * CNle + kGbrbud * CNbr   !day-1. 
                   ELSE !Deciduous option, no leaves present.
                        ISGRbud = kGbrbud * CNbr                    !day-1. 
                   ENDIF

         !Bud growth activity of branch meristem:
                  PXDMbud = ISGRbud * MXbrm          !kg XDM stem-1 day-1.
                  PXDMbud_gnd = nstems * PXDMbud     !kg XDM m-2 day-1.
                  Gbud = s_leaf * PXDMbud            !Bud growth.
                         !We turn it off
                         !with s_leaf = 0 when no leaves are present.
                         !But do we want buds to be able to grow when there
                         !are no leaves, but not to open?
            !C, N and water inputs to bud pool:
                  ICbud = fCbud *  Gbud            !kg C stem-1 day-1.
                       Constant fCbud = 0.4 !kg C (kg dry mass)-1.
                         !Bud C content (same as fCbrm for branch meristem).

                     IC_lebud = fleS_bud * ICbud   !from le C, N substrates.
                     IC_brbud = fbrS_bud * ICbud   !from br C, N substrates.
                                           !kg C, N substrates stem-1 day-1.
                     IC_lebud_gnd = nstems * IC_lebud 
                     IC_brbud_gnd = nstems * IC_brbud 
                                              !kg C, N substrates m-2 day-1.
                  INbud = fNbud *  Gbud            !kg N stem-1 day-1.
                       Constant fNbud = 0.025 !kg N (kg dry mass)-1.
                         !Bud N content (same as fNbrm for branch meristem).

                  IWbud = rWXbud * Gbud            !kg water stem-1 day-1.
                          Constant rWXbud = 12 !kg water (kg bud XDM)-1.
                                  !Ratio of water to bud structural DM.
   
         !Fluxes of substrate C utilized for bud growth (kg sC stem-1 day-1):
            OCSlebr_bud = ICbud / YGbud
               denbudG = CNle + CNbr
               fleS_bud = CNle / denbudG
               fbrS_bud = CNbr / denbudG
            OCSle_bud = OCSlebr_bud * fleS_bud  !from le substrate pool.
            OCSbr_bud = OCSlebr_bud * fbrS_bud  !from br substrate pool.
            Constant YGbud = 0.8 !kg C in XDM (kg substrate C utilized)-1.
      
         !Growth respiration, RGbud (kg C stem-1 day-1):
            RGbud = OCSlebr_bud * ( one - YGbud )  !total.
            RGle_bud = fleS_bud * RGbud            !associated with leaves.
            RGbr_bud = fbrS_bud * RGbud            !associated with branches.

         !Fluxes of substrate N utilized for bud growth (kg sN stem-1 day-1):
            ONSle_bud = INbud * fleS_bud
            ONSbr_bud = INbud * fbrS_bud
   
         !Flux of water utilized for bud growth (kg water stem-1 day-1):
            OWfi_bud = IWbud              !We can only take W from leaves
            OWfi_bud_gnd = nstems * IWbud !or fi (fine roots) water pools.
                                          !These are the only tree water pools.
                                          !Because we
                                          !want to have the option of
                                          !growing buds when no leaves are
                                          !present, we take water from fi.

   !Outputs
      !1. to leaves by budopening (kg bud dry matter stem-1 day-1).
                         fTWle = fTsh * fWle  !Dimensionless.
                                !Combined Temperature, Water functions.
         kObud = kObud20 * fTWle * fGbud_thetale   !day-1.
             Constant kObud20 = 0.1 !day-1.  Half-life is c. 7 days.
         OMbud_leaf1y = kObud * Mbud      !kg bud dry matter stem-1 day-1.
         OMbud_leaf1z = ( one - s_deciduous ) * OMbud_leaf1y &
                              + s_deciduous * budsopening * OMbud_leaf1y 
         OMbud_leaf1 = budburst * ( one - s_leaf ) * Mbud_0h &
                       + s_leaf * OMbud_leaf1z 
                                            !kg bud dry matter stem-1 day-1.
!CALL LOGD(.TRUE.)
            !See phenology section above for budburst (0 or 1) and 
            !s_leaf (0 or 1), s_leaf = 1 when leaves are present but is 0
            !during budburst (when budburst = 1).
            !The first term on the right side should ensure that the buds
            !open completely on the day when budburst = 1 (and s_leaf = 0).
            !10 Jul 01.  There seems to be a bug here, using the model in
            !conifer mode.  A blip is caused at budburst when the buds
            !present suddenly open.  Therefore we inserted the factor of
            !( one - s_leaf ) to stop this happening.

      !2. to/from self-thinning/generation (natural forest mode).
         !It is assumed that trees dying from self-thinning have
         !no buds.  New trees, generated at a net 
         !fractional growth rate of FGRnstems_sn (this can be > or < 0)
         !have the effect of decreasing (or increasing) the average per stem 
         !(if FGRnstems_sn > 0), so that the buds per unit 
         !ground area is unaffected by natural death and rebirth.
            OMbud_sn = FGRnstems_sn * Mbud

      !3. to pruning.
         !Pruning is switched on with the switch:
            Constant s_prune = 0  !Default, pruning is switched off.
            !Set s_prune = 1 to activate pruning.

         !Branch pruning is applied at a rate of kbr_prune (day-1):
            kbr_prune = s_prune * kbr_prunez        !day-1.
         !Branch structure alone is removed by pruning (see below).
         !Assume that buds are removed at the same rate:
            OMbud_prune = kbr_prune * Mbud          !kg bud DM stem-1 day-1.
            OCbud_prune = fCbud *  OMbud_prune      !kg C stem-1 day-1.
            ONbud_prune = fNbud *  OMbud_prune      !kg N stem-1 day-1.
            OWbud_prune = rWXbud * OMbud_prune      !kg W stem-1 day-1.
            OCbud_prune_gnd = nstems * OCbud_prune  !kg C m-2 day-1.
            ONbud_prune_gnd = nstems * ONbud_prune  !kg N m-2 day-1.
            OWbud_prune_gnd = nstems * OWbud_prune  !kg W m-2 day-1.
            IWbud_prune_Wsoil = OWbud_prune_gnd

      OMbud = OMbud_leaf1 + OMbud_sn + OMbud_prune + OMbud_fire

   !Differential equation
      DMbud = IMbud - OMbud         !kg bud DM stem-1 day-1.
       Mbud = INTEG( DMbud, Mbud0 ) !kg bud DM stem-1.
       Mbud_gnd = nstems * Mbud     !kg bud DM m-2.

   !C, N, and water contents of buds
      MCbud = fCbud * Mbud                                   !kg C stem-1.
      MNbud = fNbud * Mbud                                   !kg N stem-1.
      MWbud = rWXbud * Mbud                                  !kg W stem-1.
       Wbud = MWbud !Used in "Wtree_stem = ..." statement.
                    !Also, to agree with Wle, Wfi notation.
      Cbud_gnd = nstems * MCbud      !not used.              !kg C m-2.
      Nbud_gnd = nstems * MNbud      !not used.              !kg N m-2.
      Wbud_gnd = nstems * MWbud                              !kg W m-2.

   !Buds opening
      !Output OMbud_leaf1 must be assigned as inputs
      !amongst the leaf compartments.  We divide up the bud C (as the
      !limiting resource, take the N required from bud N, and put the 
      !remainder of bud N into the foliage N substrate pool.
         OCbud_leaf1 = OMbud_leaf1 * fCbud   !kg C stem-1 day-1.
         ONbud_leaf1 = OMbud_leaf1 * fNbud   !kg N stem-1 day-1.
         OWbud_leaf1 = OMbud_leaf1 * rWXbud  !kg W stem-1 day-1.
         IWbud_Wle = OWbud_leaf1             !kg W stem-1 day-1.
            !Constant fCbud = 0.4 !kg C (kg dry mass)-1. Bud C content.
                                 !same as fCbrm for branch meristem.
            !Constant fNbud = 0.025 !kg N (kg dry mass)-1. Bud N content.
                                 !same as fNbrm for branch meristem.
           !rWXbud = ratio of water to bud structural DM = constant.
         !Inputs of C and N to the foliage (le):
         OCbud_le_gnd = nstems * OCbud_leaf1            !kg C m-2 day-1.
         ONbud_le_gnd = nstems * ONbud_leaf1            !kg N m-2 day-1.
         !Total outputs of C, N, W (per m2 ground):
         OCbud_gnd = nstems * OCbud_leaf1 + OCbud_prune_gnd + OCbud_fire
                                                            !kg C m-2 day-1.
         ONbud_gnd = nstems * ONbud_leaf1 + ONbud_prune_gnd + ONbud_fire
                                                            !kg N m-2 day-1.
         OWbud_gnd = nstems * OWbud_leaf1 + OWbud_prune_gnd + OWbud_fire
                                                            !kg W m-2 day-1.

      !Carbon. Place bud C in fractions 0.96, 0.04 into Xle1, and CSle
         !pools, giving a C substrate concentration of 0.04%.
         ICbud_Xle1 = fCbud_Xle1 * OCbud_leaf1  !kg C input into leaf XDM.
         ICbud_CSle = fCbud_CSle * OCbud_leaf1  !kg C input into leaf 
                              !substrate C (kg C stem-1 day-1).
            Constant fCbud_Xle1 = 0.96, fCbud_CSle = 0.04
                                                   !Dimensionless fractions.
         ICbud_Xle1_gnd = nstems * ICbud_Xle1  !kg C into XC m-2 d-1.

      !Leaf structural dry mass and leaf area inputs:
         Ibud_Xle1 = ICbud_Xle1 / fCleX   !kg XDM stem-1 day-1.
                     Constant fCleX = 0.4  !kg C (kg XDM)-1.
                                           !C content of leaf structure.
         Ibud_Aleaf1 = Ibud_Xle1 * SLAXnew   !m2 stem-1 day-1.
                  !For the variable, SLAXnew, specific leaf area of
                  !new leaves, see below.

      !Nitrogen.
      !N required by the le1 structural component is:
         INbud_Xle = Ibud_Xle1 * fNleX           !kg N stem-1 day-1.
                     Constant fNleX = 0.005 !kg N (kg XDM)-1.
                                         !N content of leaf structure.
      !This leaves an excess N flux of
         INbud_NSph = ONbud_leaf1 - INbud_Xle !which is divided between the N
                                   !substrate and photosynthetic pools:
         INbud_NSle = fNbud_NSle * INbud_NSph
         INbud_Nph =  fNbud_Nph * INbud_NSph
         Constant fNbud_NSle = 0.5, fNbud_Nph = 0.5

      !Checks on bud C, N and water balances
         DMCbud = fCbud * DMbud;       DMNbud = fNbud * DMbud
         DWbud = rWXbud * DMbud                   !kg C, N, W stem-2 day-1.
         DCbud_gnd = Dnstems * MCbud + nstems * DMCbud      !kg C m-2 day-1.
         DNbud_gnd = Dnstems * MNbud + nstems * DMNbud      !kg N m-2 day-1. 
         DWbud_gnd = Dnstems * MWbud + nstems * DWbud       !kg N m-2 day-1. 
            ICbud_gnd = nstems * ICbud                      !kg C m-2 day-1.
            INbud_gnd = nstems * INbud                      !kg N m-2 day-1.
            IWbud_gnd = nstems * IWbud                      !kg W m-2 day-1.
        !OCbud_gnd, ONbud_gnd, OWbud_gnd, are calculated above.
        !There is no output, per unit ground area, from self-thinning.
         DCbud_gnd_chk = ICbud_gnd - OCbud_gnd
         DNbud_gnd_chk = INbud_gnd - ONbud_gnd
         DWbud_gnd_chk = IWbud_gnd - OWbud_gnd
        !DCbud_gnd should = DCbud_gnd_chk, and also for N and W.
             !All ok when self-thinning occurring.

!FOLIAGE (le = leaf)
   !Variables
      !Total structural dry matter:
         MXlez = MXle1 + MXle2 + MXle3 + MXle4             !kg XDM stem-1.
         MXle = ABS ( MXlez )  !To ensure that it is always > = 0.
      !Total substrate dry matter:
                MSCle = MCSle * rmmCS12    !kg substrate DM (with C) stem-1.
                MSNle = MNSle * rmmNS14 + MNph * rmmNph14
                                           !kg substrate DM (with N) stem-1.
         MSle = MSCle + MSNle                       !kg substrate DM stem-1.
         Constant rmmCS12 = 2.375 !Relative molecular mass of C substrate
            !(CH2O in sucrose), 28.5 / 12, for C.
         Constant rmmNS14 = 4.429 !Relative molecular mass of N substrate
            !(NO3-), 62 / 14, for N.
         Constant rmmNph14 = 7.14 ! = ( rmmNph = 100 ) / 14.0.
            !Relative molecular mass of amino acids in protein is assumed 
            ! = 100, for photosynthetic N (rubisco).
      !Total foliage dry matter:   
         Mle = MXle + MSle                         !kg DM stem-1.
      !Total foliage structural C (XC):  
         MCXle = fCleX * MXle                           !kg XC stem-1.
      !Total foliage C (substrate C + structural C):
         MCle = MCSle + MCXle                            !kg C stem-1.
      !Nitrogen:
         MNXle =  fNleX * MXle       !Structural N in foliage, kg XN stem-1.
         MNle = MNSle + MNph + MNXle        !kg N stem-1. Total foliage N.

             denMXle = MXle  !Fix this up so no failure when MXle = 0.
      IF ( MXle .GT. c1E_14 ) THEN
         !C and N substrate concentrations [kg C, N substrate (kg XDM)-1]:
            Cle = MCSle / MXle; Nle = MNSle / MXle !not executed at t = 0 xxx
               !Why not? RHS terms are all ok, cle = nle = 5.5555D+33
               !It is assumed that C and N substrates are distributed
               !over structural DM.  There is no foliage meristem.
            CNle = Cle * Nle

         !Foliage photosynthetic N concentration: upper leaves( Nph ),
               !average over canopy (Nph_can):
            Nph = MNph / MXle;   Nph_can = MNph_can / MXle
                              ![kg photosynthetic N (kg structural DM)-1].
         !Foliage structural NX concentration:
            NXle = MNXle / MXle                !kg NX (kg XDM)-1.
         !Foliage total N concentration on a structural DM basis:
            Nletot_X = MNle / MXle                 !kg total N (kg XDM)-1.
         !Ratio of foliage water to foliage structural DM:
            rWXle = Wle / MXle             !kg water (kg structural DM)-1.
         !Ratio of foliage C to N substrates:
            rCNle = Cle / Nle       !kg C (kg N)-1. Not used in model.
         !Total N concentration in the foliage:
             Nletot = MNle / Mle                  ![kg N (kg total DM)-1].
         !Total foliage N (upper canopy) per unit area:
             IF ( SLA .NE. zero ) Nletot_A = Nletot / SLA        !kg N m-2.
         !As MNle = MNSle + MNph + MNXle:
             NSletot = MNSle / Mle  !kg N substrate (kg total DM)-1.
             Nphtot =  MNph / Mle   !kg photosynthetic N (kg total DM)-1.
             NXletot = MNXle/ Mle   !kg structural N (kg total DM)-1.
         !For C:
             Cletot = MCle / Mle    !kg total C (kg total DM)-1.
             CSletot = MCSle / Mle  !kg C substrate (kg total DM)-1.
             CXletot = MCXle / Mle  !kg C structure (kg total DM)-1.

         !C and N concentrations in the phloem (these are needed for the
            !aphid submodel).
            IF ( cc4aphid ) THEN !Default false.
               !Constant(c) conditions(c) for (4) aphid growth.
               LOGICAL cc4aphid; Constant cc4aphid = .FALSE.
               Cphloem = ccCphloem            !kg C m-3.
               Nphloem = ccNphloem            !kg N m-3.
               rCNphloem = Cphloem / Nphloem  !kg C (kg N)-1.
               Constant ccCphloem = 20, ccNphloem = 10
            ELSE IF ( s_leaf .EQ. zero ) THEN !No leaves. No leaf phloem.
               Cphloem = clarge; Nphloem = clarge !7.7777e17.
               rCNphloem = Cphloem / Nphloem
            ELSE !Now Cphloem and Nphloem vary normally with C and N foliage
               !substrate levels ( cc4aphid = .F., s_leaf .EQ. one )
               Cphloem = m_CSle_phloem * Cle !kg C substrate/m3 phloem sap.
               Nphloem = m_NSle_phloem * Nle !kg N substrate/m3 phloem sap.
                  Constant m_CSle_phloem = 5000.0 !kg structural DM/m3.
                     !(active process).
                           m_CSle_phlo = m_CSle_phloem !For print output only.
                  Constant m_NSle_phloem = 1000.0 !kg structural DM/m3.
                     !(?passive process).
                           mNSsh_phlo = m_NSle_phloem !For print output only.
                  !These 2 constants are set empirically, to give reasonable
                  !numbers for the sap sucrose and glutamate concentrations.
                  !Cle = 0.02 kg C substrate (kg XDM)-1 converts to 
                     !Cphloem = 100 kg C m-3
                     ! = 100 g C/litre = 100/144 = 0.7 molar sucrose.
                  !Nle = 0.01 kg N substrate (kg XDM)-1 converts to 
                     !Nphloem = 10 kg N m-3 = 10/14 molar glutamate.
                    !Assuming 1 g N Equiv. to 6.25 g protein, 
                    !At t = 0, Nle = 0.01 kg substrate N (kg XDM)-1, 
                    !gives Nphloem = 10 kg N m-3.  Assume all this N is
                    !protein, this gives 62.5 kg protein m-3.
                    !1 m3 = 1000000 millilitres.
                    !62.5 kg N per 1000 litres = 62.5 g N per litre
                    !62.5 milligram per millilitre.
                    !See Douglas, A.E. 2006. Phloem-sap feeding by animals:
                    !problems and solutions. J Exp Bot. 57 (4), 747-754.
                    !page 748, left column, 2 para from bottom.

                  !Phloem C/N ratio:
               rCNphloem = Cphloem / Nphloem        !kg C (kg N)-1.
            ENDIF !End of IF ( cc4aphid ) THEN statement. But see below.
               !Constant(c) conditions(c) for(4) aphid growth.
               !LOGICAL cc4aphid; !Constant cc4aphid = .FALSE. Default value.

      ELSE
         Cle = csmall;   Nle = csmall;   CNle = csmall; 
         Nph = csmall; Nph_can = csmall
         NXle = csmall; Nletot_X = csmall; Nle_tot = csmall
         rWXle = rWXlec !constant = 12 kg water (kg XDM)-1. Defined above.
                 !rWXle is involved only in the calculation of psiPle.
                 !(the pressure component of foliage water potential)
                 !THis assumption keeps these calculations on the rails,
                 !although foliage water fluxes are in any case zero 
                 !when s_leaf = 0 (no leaves).
         rCNle = csmall
         Nletot = csmall
         Nletot_A = csmall
         Cphloem = csmall;  Nphloem = csmall;  rCNphloem = csmall
      ENDIF !End of IF ( MXle .GT. c1E_14 ) THEN block.

   !Foliage senescence rate constants
      !These are made dependent on the light falling on leaves in that layer.
      !At high LAI, the lower leaves with less light senescence more quickly.
      !There are 4 LAI boxes, LAI1 to LAI4.
      !The instantaneous light flux density above the canopy is jPARsc
      !(J PAR m-2 s-1).
      !We do not want the rate constants to respond immediately to low
      !light conditions (e.g. night time), and therefore we take a running
      !average (_rav) of jPARsc, with
                     kjPAR_rav = kjPAR_rav20 * fTsh
         DjPAR_rav = kjPAR_rav * ( jPARsc - jPAR_rav )
                        Constant kjPAR_rav20 = 0.035 !day-1.
                       !This gives a 20 C halflife of 0.69/0.035 = 20 days;
                       !           a 10 C halflife = 20/0.35 = c. 70 days.
               !It might be necessary to limit the maximum value of jPAR_rav,
               !e.g. reached in high light, by replacing the jPARsc in the
               !DjPAR_rav = ... eqn by jPARsc / ( 1 + jPARsc/jPAR_rav_max ).
               !High continuous light causes jPAR_rav ---> jPAR_rav_max.
         jPAR_rav = INTEG( DjPAR_rav, jPAR_rav0 )
                        Constant jPAR_rav0 = 10 !W PAR m-2.
      !It is assumed that changes in LAI are slow compared with this light 
      !averaging process, which is only performed for the light above the
      !canopy.
      !The averaged light flux density falling on the leaf boxes is assumed
         jPAR_rav_LAI1 = kcan * jPAR_rav
                         exp_kcan_LAI1 = EXP ( - kcan * LAI1 )
         jPAR_rav_LAI2 = jPAR_rav_LAI1 * exp_kcan_LAI1
                         exp_kcan_LAI12 = EXP ( - kcan * ( LAI1 + LAI2 ))
         jPAR_rav_LAI3 = jPAR_rav_LAI1 * exp_kcan_LAI12
                         exp_kcan_LAI123 = EXP ( - kcan * ( LAI1 + LAI2 &
                                                                 + LAI3 ))
         jPAR_rav_LAI4 = jPAR_rav_LAI1 * exp_kcan_LAI123
   
      !We calculate multipliers for the foliage senescence (litter) constants
      !kXle_li, using
      !                         ( m_max * Kj + (m_max - 2) * j )
      !               m_ =      --------------------------------
      !                            ( Kj + (m_max - 2) * j )
      !If j = 0, m_ = m_max,  if j = Kj, m_ = 2, if j is large, m_ ---> 1.
         Constant m_kXle_li_max = 10  !dimensionless multiplier.  Maximum
               !multiplier for foliage litter rate constant, achieved
               !when the foliage is in the dark.  A guestimate
         Constant KjPAR_kXle_li = 5 !J PAR m-2 s-1. This is "low light".
               !When the foliage is exposed to a constant 5 J PAR m-2 s-1,
               !the foliage senescences twice as fast as when exposed to high
               !light.  A guestimate.  The mean light level (above canopy)
               !in winter at Eskdalemuir is about 6 J PAR m-2 s-1.
            m_maxKj =  m_kXle_li_max * KjPAR_kXle_li  !working variables.
            m_max_2 = m_kXle_li_max - two             !working variables.
         m_kXle1_liz = ( m_maxKj + m_max_2 * jPAR_rav_LAI1 ) &
                      / ( KjPAR_kXle_li + m_max_2 * jPAR_rav_LAI1 )
         m_kXle2_liz = ( m_maxKj + m_max_2 * jPAR_rav_LAI2 ) &
                      / ( KjPAR_kXle_li + m_max_2 * jPAR_rav_LAI2 )
         m_kXle3_liz = ( m_maxKj + m_max_2 * jPAR_rav_LAI3 ) &
                      / ( KjPAR_kXle_li + m_max_2 * jPAR_rav_LAI3 )
         m_kXle4_liz = ( m_maxKj + m_max_2 * jPAR_rav_LAI4 ) &
                      / ( KjPAR_kXle_li + m_max_2 * jPAR_rav_LAI4 )
   
         m_kXle1_li = s_light_KXle_li * m_kXle1_liz + one &
                              - s_light_KXle_li
         m_kXle2_li = s_light_KXle_li * m_kXle2_liz + one &
                              - s_light_KXle_li 
         m_kXle3_li = s_light_KXle_li * m_kXle3_liz + one &
                              - s_light_KXle_li 
         m_kXle4_li = s_light_KXle_li * m_kXle4_liz + one &
                              - s_light_KXle_li 
            Constant s_light_KXle_li = 1.0  !In default, this is operative.
                 !If s_light_KXle_li = 0.0, then the multipliers = 1.0.
   
         !Also take the mean of these 4 multipliers:
            m_kXle_li = quarter * ( m_kXle1_li + m_kXle2_li &
                                  + m_kXle3_li + m_kXle4_li )

    
   !Leaf area and leaf area index
      !Total leaf area
         Aleaf = Aleaf1 + Aleaf2 + Aleaf3 + Aleaf4               !m2 stem-1.
         Aleafs_leaf = Aleaf * s_leaf  !m2 stem-1. Non-zero only when 
                      !leaves are present for deciduous trees.
      !Leaf (needle) area index, LAI:
         LAI = nstems * Aleaf                             !m2 (m2 ground)-1. 
               !Single-sided leaf.  LAI = 1 means 1 m2 of actual leaf per m2
               !ground.  The leaf has two sides, so there are actually 2 m2 
               !of leaf surface per m2 ground.
         LAIX500 = LAI * 500.00  !For output purposes only.
         LAIsq = LAI * LAI       !LAI squared.
         LAI_tree = Aleaf / Acanmax_hstem !LAI within the tree canopy.
         
            LAI1 = nstems * Aleaf1;  LAI2 = nstems * Aleaf2
            LAI3 = nstems * Aleaf3;  LAI4 = nstems * Aleaf4
         LAIs_leaf = LAI * s_leaf !LAI during the period when the leaves
                                  !are present. Deciduous option.
                                  !When no leaves, s_leaf = 0.
         DLAI = nstems * DAleaf + Dnstems * Aleaf  !m2 (m2 ground)-1 day-1. 
  
      
   !Stomatal conductance for water vapour transport, gstom [m s-1 (m2 leaf)-1]
      !Effect of ambient CO2 on the minimum and maximum stomatal
      !conductances, gstommin, gstommax, when the stomates are fully closed
      !and fully open.
         !This is programmed in as an instantaneous response, although in
         !reality, it is an acclimation whose speed depends, I think, on
         !leaf turnover, and the production of new leaves.
      !First define a dimensionless factor, fCO2_gstom, by
                   !with CO2vpm_div_350 = CO2vpm / 350 (see above).
         fCO2_gstom = one - cCO2_gs * ( CO2vpm_div_350 - one )
            Constant cCO2_gs = 0.15 !Dimensionless. Conifer (also default)
            !value.
            !Marcel van Oijen suggested this value, and gave me the 
            !following information.
            !In beech and other deciduous species, cCO2_gs = 0.3, giving
            !an acclimation decrease of 30% on CO2 doubling from 350 to 700
            !vpm. 
            !If CO2vpm = 350, then fCO2_gstom = 1.
            !In conifers, doubling of ambient CO2 from 350 to 700 decreases 
            !stomatal conductance (gstom) by 15% (cCO2_gs = 0.15).
            !Medlyn et al (2001) Stomatal conductance of forest species after
            !long-term exposure to elevated CO2 concentration: a synthesis. 
            !New Phytologist 149, 247-264.
         Constant gstommin350 = 0.0001, gstommax350 = 0.005
                                                      !m s-1 (m2 leaf)-1.
            !These are the minimum and maximum stomatal conductance 
            !constants for ambient CO2 of 350 vpm.
         gstommin = fCO2_gstom * gstommin350
         gstommax = fCO2_gstom * gstommax350
   
      !Constants used in the gstom calculation below are:
         Constant thetale_gstommin = 0.65, thetale_gstommax = 0.85
                                                         !Dimensionless.
         !Values of foliage (le) relative water content, thetale,
         !when the stomates are fully closed and fully open.

      !Calculation of gstom has 3 options:
         Constant s_gstom = 2.0 !Default value of switch.
         !s_gstom = 1, stomates are always open.
         !s_gstom = 2, gstom depends on foliage relative water content,
                      !thetale. Default.
         !s_gstom = 3, gstom depends on vapour pressure deficit (VPD).

         !No allowance is made for the dependence of stomatal conductance on
         !temperature (T).  Diffusion constant D for CO2 in air:
         !D = c T**1.97  . Jost 1960 p 425
         !water in air, D = c T**1.75.  Jones 1992, p 356.
         !stomatal conductivity ~ D.
         !Direct T effect on gstom is small, + or - 10%.
         !T may affect stomatal opening.

      !Leaf stomatal conductance, gstom (m s-1), for water vapour in air.
         IF ( s_gstom .EQ. one ) THEN
              gstom = gstommax   !Stomates are always open (0.005). 
         ELSE IF ( s_gstom .EQ. two ) THEN  !Default.
           !gstom depends on foliage relative water content, thetale.
            IF ( light_on .EQ. zero ) THEN
                      gstom_thetale = gstommin
                 ELSE IF ( thetale .LE. thetale_gstommin ) THEN
                      gstom_thetale = gstommin
                 ELSE IF ( thetale_gstommin .LT. thetale &
                          .AND. thetale .LT. thetale_gstommax ) THEN
                      gstom_thetale = gstommin + &
                        ( thetale - thetale_gstommin ) &
                        * ( gstommax - gstommin ) &
                        / ( thetale_gstommax - thetale_gstommin )
                 ELSE IF ( thetale .GE. thetale_gstommax ) THEN
                      gstom_thetale = gstommax
            ENDIF
            gstom = gstom_thetale                       !m s-1 (m2 leaf)-1.
         ELSE IF ( s_gstom .EQ. three ) THEN
           !gstom depends on vapour pressure deficit (VPD).
            IF ( light_on .EQ. zero ) THEN
               gstom_VPD = gstommin  !It is dark. Stomates are closed.
            ELSE !It is light (also applies to no diurnality, s_diurnal = 0).
               IF ( CO2vpm_div_350 .GT. two ) THEN   !This restricts CO2
                    CO2vpm_div_350z = two            !effect on VPD
               ELSE                                  !closure of stomates
                    CO2vpm_div_350z = CO2vpm_div_350 !to max CO2 of
               ENDIF                                 !of 700 vpm.

               fVPD_gstom = KVPD_gstom / &
                     ( KVPD_gstom + VPD * ( two - CO2vpm_div_350z ) )
                     !fVPD_gstom is a fraction, between 1 (VPD = 0)
                     !and 0 (VPD = large).
                     !used to multiply stomatal conductance (next line).
                  Constant KVPD_gstom = 2500 !Pa. 
                                       !A Michaelis-Menten-type constant.
               gstom_VPD = gstommin &
                             + ( gstommax - gstommin ) * fVPD_gstom
                 !At 350 vpm CO2, CO2vpm_div_350 = 350 / 350 = 1.
                 !At 700 vpm CO2, CO2vpm_div_350 = 700 / 350 = 2.
                 !If VPD = 0, fVPD_gstom = 1, stomates are open.
                 !If VPD = 5000 Pa at 350 vpm CO2, 
                    !fVPD_gstom = 2500 / 7500,
                    !and stomatal conductance drops to 1/3.
                 !If VPD = 5000 Pa at 700 vpm CO2, VPD has no effect.
            ENDIF ! if ( light_on .EQ. zero ) block.

            gstom = gstom_VPD                       !m s-1 (m2 leaf)-1.
         ENDIF ! if ( s_gstom .eq. one ) block.

         !Stomatal resistance, rstom (m-1 s).
            IF ( gstom .GT. zero ) THEN
               rstom = one / gstom !m-1 s. Stomatal resistance.
            ELSE
               rstom = clarge
            ENDIF

         !Calculate fthetale_gs
            !fthetale_gs gives the fractional foliage relative water content
            !between the stomates fully open and stomates closed positions.
            !If s_gstom = 2, fthetale_gs is the fractional stomatal opening.
               fthetale_gsz1 = ( thetale - thetale_gstommin ) / &
                            ( thetale_gstommax - thetale_gstommin )
               fthetale_gs =  MAX( MIN( fthetale_gsz1, one ), c1E_6 ) 
            !This causes fthetale_gs to be > = 1 x e-6 and < = 1.

           !To convert gstom in units of m s-1 to g mol m-2 s-1, 
              !see HG Jones: Plants and microclimate. p 357.
              !gmol(mol m-2 s-1) = (P/RT) g(m s-1)
              !Rgas_gmol = (22.4136/1000) * Patm(= 101325) / T0(= 273.15)
                != 8.314 J/(K gmol).
              !gmol(mol m-2 s-1) = (P/Patm)(T0/T) (1000/22.4136) g(m s-1).
              !See also p 71, 3.1, and p 370, 3.1.
              !At 20 C and atmospheric pressure,
              !g = 1 m s-1 = 41.57 mol m-2 s-1.
              !As CO2air = 0.6404 x 10-3 kg CO2 m-3 = 350 10-6 mol mol-1 at
              !20 C.  Therefore
              !Flux = g CO2air = 0.6404 10-3 kg CO2 m-2 s-1
              !     = 350 10-6 41.57 = 0.01455 mol m-2 s-1.
              ! 44.01 x 0.01455 = 0.6403 g CO2 m-2 s-1.  All OK.
            gstom_mol = gstom * Pair / ( Rgas * TairK )
                       !g mol m-2 s-1.

            !To convert rstom (water vapour in air) to rstom_CO2 (CO2 in air),
               !multiply rstom(water vapour) by 1.65 = D(water vapour)/D(CO2),
               !D = diffusion coefficient. D(water vapour) = 24.2, 
               !D(CO2) = 14.7 x 10-6 m2 s-1 at 20 C.
             rstom_CO2 = rDwatvapDCO2 * rstom                    !m-1 s.
                Constant rDwatvapDCO2 = 1.65 !Dimensionless ratio of
                                             !diffusion constants for
                                             !water vapour and CO2.

   !Canopy conductances, gcan and gcanmax:
      IF ( LAI .GT. zero ) THEN
           gcan = LAI * gstom       !m s-1 (m2 ground)-1.
           gcanmax = LAI * gstommax !m s-1 (m2 ground)-1. Stomates fully open.
           rcanmin = one / gcanmax  !m-1 s (m2 ground)-1. Stomates fully open.
      ELSE
           gcan = zero; gcanmax = zero; rcanmin = clarge
      ENDIF
  
   
   !Canopy height:
      !We assume that canopy height = stem height:
          hcan = hstem   !m. 


   !Light interception and photosynthesis
      !Pmax (kg CO2 m-2 s-1), asymptote of leaf photosynthetic response
         !to saturating light.  Pmax is a variable.

         !Pmax_chl is the asymptote of leaf photosynthetic response
         !to saturating light at the chloroplast level.  
         !Pmax (above) < Pmax_chl because stomatal resistance decreases the
         !maximum flux which can occur.

         !Pmax20 is the unmodified 20 deg C value of Pmax_chl.
            !Pmax20 can acclimate.  It is determined
            !by photosynthetic N concentration per unit leaf area, Nph_A.
            IF ( s_Pmax .EQ. zero .OR. Aleaf .LT. c1E_10 ) THEN
                  !If photosynthetic acclimation is switched off, .or.
                  !there are no leaves.
               Nph_A = zero      
               Pmax20 = Pmax20c  !Set Pmax20 to a constant value.
            ELSE  !Acclimation takes place.  Leaves are present.
               denAleaf = Aleaf !To help with debugging. den = denominator.
               Nph_A = MNph / Aleaf  !kg photosynthetic N (m2 leaf area)-1.
               Pmax20 = cPmax_Nph * Nph_A                  !kg CO2 m-2 s-1.
            ENDIF
               Constant s_Pmax = 1.0 !Default value.
                  !To keep Pmax20 constant, set s_Pmax = 0.0.
                  !This keeps Pmax20 constant at 
               Constant Pmax20c = 2.0e-6 !kg CO2 m-2 s-1.
               Constant cPmax_Nph = 0.0008
                                   !kg CO2 s-1 (kg photosynthetic N)-1.
                  !cPmax_Nph relates upper-leaf photosynthetic N
                  !(rubisco) to Pmax20 value at top of canopy.
                  !If Nph_A = 2e-3 kg N m-2, 
                  !Pmax20 = 1.6e-6 kg CO2 m-2 s-1.

                  !For output purposes:
                     Nph_Ae3 = c1000 * Nph_A    !g photosynthetic N m-2.
                     Pmax20e6 = c1e6 * Pmax20   !mg CO2 m-2 s-1.y
                     Pmax20s_leaf = Pmax20 * s_leaf !For averaging purposes.
                                  !This is zero when leaves are not present.

            !Now allow for the effect of CO2 on Pmax20.
               fCO2_Pmax = one / ( one + c700 / CO2vpm ) 
                  !Pmax20 depends on the atmospheric CO2 level. 
                  !Constant c700 = 700. !vpm CO2.  This is the CO2
                  !concn when Pmax20 has its half-maximal value. 
                  !If CO2vpm = 350 vpm, then fCO2_Pmax = 1/3.
                  !NB We use ambient CO2 to modify Pmax20, rather than
                  !CO2 at chloroplast. 

                    Pmax20fCO2 = Pmax20 * fCO2_Pmax
         Pmax_chl = Pmax20fCO2 * fT_Pmax * fWph !This is the chloroplast 
                      !Pmax for saturating light and zero stomatal
                      !resistance modulated for temperature and water.

                      !fT_Pmax is a temperature function (see above). 
                      !fWph is direct effect of foliage water potential on
                      !photosynthesis (not an effect via stomatal resistance).
                      !fWph = aWle ** (s_water * qWph)   !See above. 
                      !   Constant qWph = 2   !Dimensionless.
          !Carboxylation resistance.
           IF ( Pmax_chl .GT. zero ) THEN
              rchl = CO2air / Pmax_chl !m-1 s. Carboxylation resistance
                                       !for CO2.  Flux = [CO2]/rchl.
                                       ![CO2] = kg CO2 m-3.
           ELSE
              rchl = clarge
           ENDIF

           !Total resistance to CO2 uptake, diffusion + carboxylation.
              rCO2 = rstom_CO2 + rchl  !m-1 s. 
                     !rstom_CO2 = rDwatvapDCO2 (1.65) * rstom  

      Pmax = Pmax_chl * fgstom_Pmax !kg CO2 m-2 s-1. 
        !Pmax20 is modified with:
          !fgstom_Pmax is factor (LE 1) for effect of stomatal closure
                                 !on Pmax of photosynthetic response.
              !Various options are available.
                 Constant s_gstom_Pmax = 1 !Default value of switch.
              IF ( s_gstom_Pmax .EQ. zero .OR. s_water .EQ. zero ) THEN
                 fgstom_Pmax = one !No effect of stomatal closure
                                   !on Pmax.
              ELSE IF ( s_gstom_Pmax .EQ. one ) THEN
                 fgstom_Pmax = gstom / gstommax !Default setting.
                    !Stomatal closure decreases Pmax proportionately.
              ELSE  !e.g. s_gstom_Pmax = 2.
                 IF ( rCO2 .GT. zero ) THEN
                    fgstom_Pmax = rchl / rCO2
                 ELSE  !rCO2 = rstom_CO2 + rchl  !m-1 s. 
                    fgstom_Pmax = zero
                 ENDIF
              ENDIF

      
      !alpha, initial slope (dP/dI) of leaf light response equation
         alpha = alphamax15 * fCO2_alpha &
                           * fTalpha * fWph   !kg CO2 (J PAR)-1.
             Constant alphamax15 = 2.0e-8   !kg CO2 J-1.
                              !Leaf photosynthetic efficiency at 15 oC 
                              !and saturating CO2. Equivalent to a quantum
                              !efficiency of 0.099 mol CO2 per photon PAR.
         !alphamax_15 is modified with:
            !CO2:
                fCO2_alpha = one - cCO2_alpha / CO2vpm 
                Constant cCO2_alpha = 100 !vpm. Effect of CO2 on 
                                       !photosynthetic quantum efficiency.
            !Temperature. fTalpha. See above.
            !Water. fWph. See above.
   
      
      !Canopy photosynthesis
      !Canopy instantaneous gross photosynthetic rate can be calculated 
         !in 5 ways, select by the integer switch s_Pcan:
         INTEGER s_Pcan, s_Pcantl
            !1. s_Pcan = 1. Numerical integration down the canopy. Using
                           !non-rectangular hyperbola (NRH) for leaf response.
                           !No sun/shade leaf calculations. No acclimation.
            !2. s_Pcan = 2. Analytically, NRH, without acclimation.
                           !No sun/shade leaf calculations.
            !3. s_Pcan = 3. Analytically. NRH. Acclimation: Pmax declines
               !with depth in the
               !canopy, according to exp( - kcan * LAI ),   This was
               !suggested by Charles_Edwards, 1981, p. 70). 
               !No sun/shade leaf calculations.
            !4. s_Pcan = 4. NRH. Leaf acclimation a la Charles-Edwards.
                           !Sun/shade leaf effects (Thornley, 2002). 
            !5. s_Pcan = 5. NRH. Leaf acclimation a la Charles-Edwards.
                           !Sun/shade leaf effects (Thornley 2002).
                           !Discontinuous canopy, a la Jackson & Palmer
                           !(1979), and Thornley & France (2007, sections
                           !9.2.3, 9.3.6).

            Constant s_Pcan = 5  !default.

      IF ( jPARsc .GT. zero .AND. s_leaf .EQ. one ) THEN
              !There is light, and leaves are present.

         IF ( s_Pcan .EQ. i1 ) THEN 
               !Numerical calculation of the instantaneous canopy gross
               !photosynthetic rate, PCO2sc_num (kg CO2 m-2 s-1):
               LAIz = zero;  PCO2sc_num = zero   !Initialization.   
               REPEAT_np..CONTINUE
                  Constant deltaLAI = 0.2  !leaf area index increment used.
                  jleaf = kcan_mod * jPARsc &
                     * EXP( - kcan * LAIz )   !J m-2 s-1. Leaf irradiance.
                     alphajleaf = alpha * jleaf 
                     znp1 = alphajleaf + Pmax 
                     znp1sq = znp1 * znp1
                  pleaf = ( znp1 - SQRT( znp1sq &
                          - four_ksi_ph * alphajleaf * Pmax ) ) &
                          / two_ksi_ph       !Solution of hyperbola.
                  PCO2sc_num = PCO2sc_num + pleaf * deltaLAI  !Accumulate.
                  LAIz = LAIz + deltaLAI   !Increment LAI.
                  IF ( LAIz . LT . LAI ) GO TO &
               REPEAT_np  !Continue stepping down through canopy.
               PCO2sc_num = PCO2sc_num - Pleaf * ( LAIz - LAI )   !Correct
                  !result for last step which was too far.
               PCO2scz = PCO2sc_num 
               PCO2sc1 = PCO2sc_num 
               !This procedure can be very expensive computationally,
               !especially for high LAI canopies.
      
         ELSE IF ( s_Pcan .EQ. i2 ) THEN 
               !NRH. No acclimation. No sun/shade
               !Analytical calculation of the instantaneous canopy gross
               !photosynthetic rate using non-rectangular hyperbola
               !without acclimation, PCO2sc_an (kg CO2 m-2 s-1):
               zx0 = alpha * kcan_mod * jPARsc 
               zx1 = zx0 * exp_kcanLAI 
               Pmaxsq = Pmax * Pmax;  zw = one - two_ksi_ph 
               zw2 = zx0 * zw;         zw0 = Pmax * zw2
               ax0 = SQRT( zx0 * zx0 + zw0 + zw0 + Pmaxsq )
               zw3 = zx1 * zw;         zw1 = Pmax * zw3
               ax1 = SQRT( zx1 * zx1 + zw1 + zw1 + Pmaxsq )
               Pmaxzw = Pmax * zw
               bx0 = ax0 + zx0 + Pmaxzw;   bx1 = ax1 + zx1 + Pmaxzw
               cx0 = ax0 + zw2 + Pmax;    cx1 = ax1 + zw3 + Pmax
                  denlnarg1 = Pmax * cx0
               lnarg1 = bx0 / denlnarg1
                  denlnarg2 = Pmax * cx1
               lnarg2 = bx1 / denlnarg2
               pf1x0 = Pmax * LOG ( lnarg1 )
               pf1x1 = Pmax * LOG ( lnarg2 )
               ksi_phPmax = ksi_ph * Pmax
               two_ksi_phPmax = ksi_phPmax + ksi_phPmax
               lnarg3 = bx0 + bx0;  lnarg4 = bx1 + bx1
               pf2x0 = two_ksi_phPmax * LOG ( lnarg3 )
               pf2x1 = two_ksi_phPmax * LOG ( lnarg4 )
               pfx0 = ax0 + pf1x0 - pf2x0
               pfx1 = ax1 + pf1x1 - pf2x1
               PCO2sc_an = ( zx0 - zx1 - pfx0 + pfx1 ) / &
                        ( two_ksi_ph * kcan ) !End of analytical calculation.
               PCO2scz = PCO2sc_an
               PCO2sc2 = PCO2sc_an
      
         ELSE IF ( s_Pcan .EQ. i3 ) THEN            
               !NRH. Acclimation. No sun/shade.
               !Assume Pmax varies down the canopy according to
                  !exp(-kcan*LAI), suggested by Charles-Edwards (CE). 
                  !Pmax is the value at the top of the canopy.
                  z1CE = alpha * kcan_mod * jPARsc 
                  z2CE = z1CE + Pmax
               PCO2sc_CE = ( one_exp_kcanLAI / ( kcan * two_ksi_ph ) ) * &
                       ( z2CE &
                         - SQRT( z2CE * z2CE - four_ksi_ph * z1CE * Pmax ) &
                       ) 
               PCO2scz = PCO2sc_CE 
               PCO2sc3 = PCO2sc_CE 
   
         ELSE IF ( s_Pcan .EQ. i4 ) THEN
               !NRH. Acclimation. Sun/shade. Use *4 to refer to s_Pcan = 4
               !Non-rectangular hyperbola with acclimation, treating sun and
               !shade leaves separately.
                  !jPARsc (J PAR m-2 s-1) is solar radiation at top of canopy.
                  !If diurnal data is input, then for each value ideally we
                     !require fsun, the fraction of radiation incident on a
                     !horizontal plane which is direct beam.
                  !If radiation data is internally generated (sinusoids),
                     !or is obtained from monthly data by interpolation, or
                     !is input as daily totals, then on a daily basis,
                     !we are given (or can calculate)
                     !Direct beam radiation + diffuse radiation.
         
               !kcan_mod = kcan / ( one - chileaf )  
         
               !Calculate:  
                  !1. photosynthetic rate when sun is out: PCO2sc_sunout.
                     !Leaves experience direct sunshine and diffuse radiation.
                  !2. photosynthetic rate when no direct sun: PCO2sc_nosun, 
                     !just diffuse radiation.
                  !Add these together, weighted with fbshrs, (1 - fbshrs).
   
               psun = alpha * kcan_mod * jPARsc_sun   !kg CO2 m-2 s-1. 4
               pdif = alpha * kcan_mod * jPARsc_dif   !kg CO2 m-2 s-1. 4
                  !jPARsc_sun is direct-beam radiation when sun is out.
                  !jPARsc_dif is diffuse radiation when sun is in or out,
                  !assumed the same. Both J PAR m-2 s-1.
               psunandpdif = psun + pdif    !kg CO2 m-2 s-1. 4
               pdifandPmax = pdif + Pmax    !kg CO2 m-2 s-1. 4
               pdifxPmax = pdif * Pmax      !s_pcan = 4
         
               !kcanLAI = kcan * LAI
               !exp_kcanLAI = EXP ( - kcanLAI )
               !one_exp_kcanLAI = one - exp_kcanLAI. All calculated above.
         
                exp_kcanLAIsq = exp_kcanLAI * exp_kcanLAI  !s_pcan = 4
                one_exp_kcanLAI = one - exp_kcanLAI        !s_pcan = 4
                one_exp_kcanLAIsq = one - exp_kcanLAIsq    !s_pcan = 4
           
                a = psun * psun         !s_pcan = 4
                b = two * psun &
                    * ( pdifandPmax - two * ksi_ph * Pmax )  !s_pcan = 4
                c = pdifandPmax * pdifandPmax - four * ksi_ph * pdif * Pmax
                   !Check that c > 0, as I think it must be. OK. Done.
               
                R1 = a + b + c !R = a + b*u + c*u*u. R1 = R(u=1).s_pcan = 4
                Rgnd = a + b * exp_kcanLAI + c * exp_kcanLAIsq !s_pcan = 4
                                          !Rgnd = R(u = exp(-kcan * LAI)).
                Del = four * a * c - b * b  !s_pcan = 4
   
                PCO2sc_sunleaves = ( one / ( two * kcan * ksi_ph ) ) * &
                ( psun * one_exp_kcanLAI &
                            + half * pdifandPmax * one_exp_kcanLAIsq &
               - (          ( one / ( four * c ) ) * &
                        (   ( two * c  + b ) * SQRT( R1 ) &
                          - ( two * c * exp_kcanLAI + b ) * SQRT( Rgnd ) &
                        ) &
                         + Del / ( eight * c * SQRT( c ) ) * &
                LOG( ( two * SQRT( c * R1 ) + two * c + b ) / &
                     ( two * SQRT( c * Rgnd ) + two * c * exp_kcanLAI + b ) &
                   ) &
                 ) &
                )
   !s_pcan = 4
               PCO2sc_shadeleaves = ( one / ( two * kcan * ksi_ph ) ) * &
                      ( one_exp_kcanLAI - half * one_exp_kcanLAIsq ) * &
                      ( pdifandPmax - &
                        SQRT( pdifandPmax * pdifandPmax &
                              - four * ksi_ph * pdif * Pmax ) ) !s_pcan = 4
   
               PCO2sc_sunout = PCO2sc_sunleaves + PCO2sc_shadeleaves 
                                           !kg CO2 m-2 s-1. !s_pcan = 4
                  !The sun is out.  Some of the leaves are in (direct sunshine
                  ! + diffuse radation).  Some leaves are in the shade.
   
                  !2. Sun is not out, radiation (all diffuse) is jPARsc_dif.
                      !Now calculate canopy photosynthesis, using the
                      !Charles-Edwards expressions from above 
                      !(see s_Pcan = 3 block).  We are now in s_Pcan = 4
                         z1CE_nosun = alpha * kcan_mod * jPARsc_dif
                         z2CE_nosun = z1CE_nosun + Pmax   !s_Pcan = 4
               PCO2sc_nosun = ( one_exp_kcanLAI / ( kcan * two_ksi_ph ) ) &
                         * ( z2CE_nosun - SQRT( z2CE_nosun * z2CE_nosun &
                                    - four_ksi_ph * z1CE_nosun * Pmax ) ) 
                                                                !s_Pcan = 4
               PCO2scss = fbshrs * PCO2sc_sunout &
                           + ( one - fbshrs ) * PCO2sc_nosun !ss = sun + shade 
               PCO2scz = PCO2scss                           !leaves.
               PCO2sc4 = PCO2scss                           !leaves.
               !END of s_Pcan = 4 block.
        ELSE IF ( s_Pcan .EQ. i5 ) THEN !Default.
               !The "5" appended to some variables in this block refers 
               !to s_Pcan = 5.
               !Non-rectangular hyperbola with acclimation, treating sun and
               !shade leaves separately. Discontinuous canopy, a la Jackson
                       !& Palmer (1979), and Thornley & France (2007, CABI,
                       !sections 9.3.4.4, p. 299).
                  !jPARsc (J PAR m-2 s-1) is solar radiation at top of canopy.
                  !If diurnal data is input, then for each value ideally we
                     !require fsun, the fraction of radiation incident on a
                     !horizontal plane which is direct beam.
                  !If radiation data is internally generated (sinusoids),
                     !or is obtained from monthly data by interpolation, or
                     !is input as daily totals, then on a daily basis,
                     !we are given (or can calculate)
                     !direct beam radiation + diffuse radiation.
                  !Quantities required for this block are:
                     !Parameters and derived parameters: 
                        !kcan_mod = kcan / ( one - chileaf )  
                     !Variables
                        !alpha, jPARsc_sun, jPARsc_dif, Pmax, LAI, 
                        !etc (unfinished)
               !Calculate:
                  !1. photosynthetic rate when sun is out: PCO2sc_sunout,
                  !2. photosynthetic rate when no sun: PCO2sc_nosun,
                  !and add these together, weighted with fbshrs, (1 - fbshrs).
   
               psun5 = alpha * kcan_mod * jPARsc_sun        !kg CO2 m-2 s-1.
               pdif5 = alpha * kcan_mod * jPARsc_dif        !kg CO2 m-2 s-1.
                  !jPARsc_sun is direct-beam radiation when sun is out.
                  !jPARsc_dif is diffuse radiation when sun is in or out,
                     !assumed the same. Both J PAR m-2 s-1.
               pdifandPmax5 = pdif5 + Pmax                  !kg CO2 m-2 s-1.
              !LAI5.  The "5" refers to s_Pcan = 5.
                  IF ( ABS( LAI ) .GT. csmall .AND. Tblack .NE. one ) THEN
                       LAI5 = LAI / one_Tblack
                  ELSE
                       LAI5 = zero
                  ENDIF
               kcanLAI5 = kcan * LAI5
               exp_kcanLAI5 = EXP ( - kcanLAI5 )
               one_exp_kcanLAI5 = one - exp_kcanLAI5 
               exp_kcanLAIsq5 = exp_kcanLAI5 * exp_kcanLAI5
               one_exp_kcanLAIsq5 = one - exp_kcanLAIsq5
           
               a = psun5 * psun5 !a5, etc
               b = two * psun5 * ( pdifandPmax5 - two * ksi_ph * Pmax )
               c = pdifandPmax5 * pdifandPmax5 - four * ksi_ph * pdif5 * Pmax
                   !Check that c > 0, as I think it must be. OK. Done.
               
               R1 = a + b + c            !R = a + b*u + c*u*u.  R1 = R(u=1).
               Rgnd5 = a + b * exp_kcanLAI5 + c * exp_kcanLAIsq5
                                         !Rgnd = R(u = exp(-kcan * LAI)).
               Del = four * a * c - b * b
  
               IF ( light_on .EQ. zero ) THEN
                  PCO2sc_sunleaves5 = zero 
               ELSE
                  PCO2sc_sunleaves5 = one_Tblack &
                     * ( one / ( two * kcan * ksi_ph ) ) * &
                       ( psun5 * one_exp_kcanLAI5 &
                            + half * pdifandPmax5 * one_exp_kcanLAIsq5 &
                     - (          ( one / ( four * c ) ) * &
                           (   ( two * c  + b ) * SQRT( R1 ) &
                          - ( two * c * exp_kcanLAI5 + b ) * SQRT( Rgnd5 ) &
                           ) &
                         + Del / ( eight * c * SQRT( c ) ) * &
                      LOG( ( two * SQRT( c * R1 ) + two * c + b ) / &
                         ( two * SQRT( c * Rgnd5 ) &
                               + two * c * exp_kcanLAI5 + b &
                         ) &
                       ) & 
                    ) &
                  )
                ENDIF !IF ( light_on .EQ. zero ) THEN statement.

                IF ( light_on .EQ. zero ) THEN
                   PCO2sc_shadeleaves5 = zero
                ELSE
                   PCO2sc_shadeleaves5 = one_Tblack &
                                   * ( one / ( two * kcan * ksi_ph ) ) * &
                      ( one_exp_kcanLAI5 - half * one_exp_kcanLAIsq5 ) * &
                      ( pdifandPmax5 - &
                          SQRT( pdifandPmax5 * pdifandPmax5 &
                              - four * ksi_ph * pdif5 * Pmax ) )
                ENDIF ! of IF ( light_on .EQ. zero ) THEN statement.

               PCO2sc_sunout5 = PCO2sc_sunleaves5 + PCO2sc_shadeleaves5

                  !2. Sun is not out, radiation (all diffuse) is jPARsc_dif.
                      !Now calculate canopy photosynthesis, using the
                      !Charles-Edwards expressions from above (s_Pcan = 3).
                         z1CE_nosun = alpha * kcan_mod * jPARsc_dif
                         z2CE_nosun = z1CE_nosun + Pmax
                     
                     IF ( light_on .EQ. zero ) THEN
                        PCO2sc_nosun5 = zero
                     ELSE
                        PCO2sc_nosun5 = one_Tblack &
                           * ( one_exp_kcanLAI5 / ( kcan * two_ksi_ph ) ) &
                           * ( z2CE_nosun - SQRT( z2CE_nosun * z2CE_nosun &
                                    - four_ksi_ph * z1CE_nosun * Pmax ) ) 
                     ENDIF
   
               PCO2sc_ss5 = fbshrs * PCO2sc_sunout5 &
                           + ( one - fbshrs ) * PCO2sc_nosun5
                                                !ss = sun + shade leaves.
               PCO2scz = PCO2sc_ss5
               PCO2sc5 = PCO2sc_ss5
            !End of "ELSE IF ( s_Pcan .EQ. i5 ) THEN" block.
         ENDIF !IF ( s_Pcan .EQ. i1 ) THEN block.

         ELSE
            PCO2scz = zero !jPARsc is 0 (I dont think it is ever < 0).
      ENDIF !IF ( jPARsc .GT. zero .AND. s_leaf .EQ. one ) THEN block.
            !There is light, and leaves are present.

         PCO2sc = s_leaf * PCO2scz    !kg CO2 m-2 ground s-1
               !If there are no leaves then s_leaf = 0.
            !For output/checking purposes, calculate CO2 concn at the
            !inside the stomate:
               IF ( LAI .NE. zero ) THEN
                  CO2int = CO2air - PCO2sc * rstom_CO2 / LAI !kg CO2 m-3.
               ELSE
                  CO2int = clarge
               ENDIF
               CO2intvpm = CO2int / cc_vpm_conc      !volumes per 
                                                     !million volumes.
        
         !Instantaneous photosynthetic rate (kg CO2 m-2 ground day-1):
            PCO2d1 =  c86400 * PCO2sc 
         !If you wish to apply this at constant rate during the 24-hour day,
            !ie, removing diurnality (s_diurnal = 0), then correct the rate
            !by multiplying by daylength, eg 0.5 or whatever:
            PCO2dy = PCO2d1 * ( s_diurnal + one_s_diurnal * daylength )
      
      !Canopy photosynthesis ( kg C m-2 ground day-1 )
         Pcan = 0.2727273 * PCO2dy   !Gross photosynthesis.
                                     !0.2727... = 12 / 44.


         !Isoprene emission by foliage
            !Isoprene. C5H8 or CH2:C(CH3).CH:CH2, B Pt 33 deg C.
            !H-W Heldt. 1997. Plant Biochemistry & Molecular Biology. OUP.
            !pp 365-6: up to 15% of gross photosynthesis may be emitted by
            !the foliage at T > ~ 30 deg C. Oak, spruce, poplar. Gives blue
            !haze over forests. Isoprene synthesis occurs in the chloroplasts.
            !Martin MJ, Stirling CM, Humphries SW, Long SP. 2000.
            !A process-based model to predict the effects of climatic change
            !on leaf isoprene emission rates.
            !Ecological Modelling 131: 161-174.
               Tair_positive = MAX( csmall, Tair )  !Positive values of Tair.
                                                    !csmall = 7.7777D-17.
               rTair_positiveTIP = Tair_positive / Tisoprene !Ratio.
               Constant Tisoprene = 30.0 !deg C. Switch-on temperature for
                                         !isoprene emission.
               rTair_positiveTIPq = rTair_positiveTIP ** qisoprene
               Constant qisoprene = 5.0 !Not very steep switch-on function.
               fisoprenez = rTair_positiveTIPq / ( one + rTair_positiveTIPq )
               fisoprene = fisoprene_max * fisoprenez
               Constant fisoprene_max = 0.15 !Dimensionless. Maximum fraction
                  !canopy photosynthesis emitted as isoprene.
               OCle_IP_atm_gnd = fisoprene * Pcan 
                                         !kg C as isoprene m-2 ground day-1.
                                         !Pcan: ( kg C m-2 ground day-1 ) 
               IP = OCle_IP_atm_gnd !For simpler notation, not used in
                                    !calculations.    
 

      !Gross photosynthesis less isoprene emission:
         Pcan_IP = Pcan - OCle_IP_atm_gnd  !kg C m-2 ground day-1.

      !Gross photosynthesis (kg C stem-1 day-1): 
         IF ( nstems .GT. zero ) THEN
            ICph_CSle = Pcan_IP / nstems 
         ELSE
            ICph_CSle = zero 
         ENDIF
      
      !Net photosynthesis:
         Pnet_stem = ICph_CSle - Rtree_stem   !kg C stem-1 day-1.   
         Pnet = nstems * Pnet_stem            !kg C m-2 day-1.


      !Foliage N output to atmosphere
         !ONSle_atm_stem, output of foliage (le) N substrate to atmospheric
         !ammonia (kg ammonia N stem-1 day-1).
         !This flux can be positive or negative.

         !Convert Nle [foliage substrate N concentration, kg N substrate 
         !(kg XDM)-1] into foliage ammonia concentration in the sub-
         !stomatal cavities, kg ammonia N m-3:
            Namm_le = fT_Namm_le * cNamm_le_NSle20 * Nle !kg ammonia N m-3.
                          Constant cNamm_le_NSle20 = 0.5E-6 
                            !kg ammonia N m-3 / [kg N substrate (kg XDM)-1].
               !This converts Nle to Namm_le. 20 deg C value.
               !Temperature function fT_Namm_le = 1 at 20 C. Dimensionless.
               !Calculated above.
               !For Nle = 0.01, Namm_le = 5E-9 kg amm N m-3
               != 5/14 x E-6 moles amm m-3. 1 m3 of air contains
               !44.62 moles at STP. The mole fraction is 5/14 x E-6
               !/ 44.62 = 8 nanomol ammonia per mol of air.
               !See p.78.

               !Normal atmospheric pressure, Pair0 = 101325.0 Pa.
               !Tair0 = 273.15 = absolute temperature at 0 deg C.
               !14.007 is the RMM of N.
               !14.007 kg N occupy volume of 22.41 m3 at STP.

         !Conductance for NH3 (MW = 17) transport.  Assume this is the
            !same as for water vapour transport (MW = 18):
               IF ( gBoundaryLayer .GT. zero ) THEN 
                   !gBoundaryLayer = boundary layer conductance (m s-1).
                  rBoundaryLayer = one / gBoundaryLayer         !s m-1.
               ELSE
                  rBoundaryLayer = clarge !a large number.
               ENDIF

               IF ( gcan .GT. zero ) THEN !gcan = canopy conductance.
                  rcan = one / gcan        !s m-1.
               ELSE
                  rcan = clarge
               ENDIF

               rssc_atm = rcan  + rBoundaryLayer  !Resistance, sub-stomatal
                                        !cavity to atmosphere. s m-1.
               IF ( rssc_atm .NE. zero ) THEN
                  gNamm_le = one / rssc_atm                    !m s-1.
                                   !canopy + boundary layer conductances.
               ELSE
                  gNamm_le = clarge
               ENDIF

         !Flux of NH3 to atmosphere (can be + or -):
             ONSle_atm_gnd = s_leaf * s_Namm_le_atm * c86400 &
                                    * gNamm_le &
                                    * ( Namm_le - Namm_atm )
                                                !kg ammonia N m-2 day-1.
                !s_leaf, for simulating no leaves present (when 0).
                Constant s_Namm_le_atm = 1 !For switching off flux.
             ONSle_atm_stem = ONSle_atm_gnd / nstems 
                                              !kg ammonia N stem-1 day-1.
             INatm_NSle_gnd = - ONSle_atm_gnd !kg ammonia N m-2 day-1.
                                              !kg ammonia N m-2 day-1.


   !Photosynthetic N pool, MNph, MNph_can (canopy)
      !(kg photosynthetic N stem-1).
      !ONSle_Nph, output of N substrate to photosynthetic N synthesis.
             !Modify synthetic (growth) rate constant for temperature, water:
                kG_Nph = s_leaf * kG_Nph20 * fTWle
                        !s_leaf = 0 simulates no leaves present.
                   Constant kG_Nph20 = 0.03
                      !kg photosynthetic N (kg XDM)-1 day-1. 
                      !Rate constant for synthesis (growth) of 
                      !photosynthetic N from foliage N substrate.
                      !This = value in HPM. But SLAmax = 25 (HPM),
                      !and SLAmax = 10 here in EFM.  We do this otherwise
                      !Pmax20 is about 5 times too big.  We want Pmax20 to
                      !be about 1.5 to 2 e-6 kg CO2 m-2 s-1 in EFM.
             !Michaelis_Menten modifiers for N substrate and light:
                fNSle_Nph = Nle / ( Nle + KNSle_Nph ) 
                   Constant KNSle_Nph = 0.01  ![N].  
                      !Michaelis-Menten constant, involved in
                      !synthesis of photosynthetic N from foliage N substrate.
                jPARsc_ul = jPARsc * kcan !Light incident on upper leaves.
                fjPAR_Nph = jPARsc_ul / ( jPARsc_ul + KjPAR_Nph )
                   Constant KjPAR_Nph = 100 !J PAR m-2 s-1.  Michaelis-Menten
                      !constant, involved in light-stimulated
                      !synthesis of photosynthetic N from shoot N substrate.
          ONSle_Nph = MXle * kG_Nph * fNSle_Nph * fjPAR_Nph
                                           !kg photosynthetic N stem-1 day-1.
                      INSle_Nph = ONSle_Nph !Input to Nph pool.

      !ONph_NSle.  Degradation of photosynthetic N to N substrate.
             !Modify degradation rate constant for temperature, water:
                kD_Nph = s_leaf * kD_Nph20 * fTWle
                        !s_leaf = 0 simulates no leaves present.
                   Constant kD_Nph20 = 0.15 !day-1.  
                      !Half-life is 0.69 / 0.15 = 5 days.
                      !Rate constant for degradation of photosynthetic N.
          ONph_NSle = kD_Nph * MNph

      !INph_NSle (kg N substrate stem-1 day-1). 
         !Input from degradation of photosynthetic N.
          INph_NSle = ONph_NSle
             !ONph_NSle is calculated above.


      !ONph_li0, output towards surface soil metabolic pool with litter
               !turnover (senescence) flux (kg substrate N stem-1 day-1). 
          ONph_li0 = Nph * OXle4_li 
               !A fraction of this actually accompanies the litter to the 
               !surface litter pools:
                  fNphli = ( fNphli_min * KNphli + Nle ) / &
                             ( KNphli + Nle )
                             !If Nle = 0, then fNphli = fNphli_min.
                             !If Nle is high, then fNphli = 1.
                     Constant fNphli_min = 0.3   !Dimensionless.  
                        !The minimum fraction of photosynthetic
                        !N leaving the plant with the senescing litter fluxes.
                     Constant KNphli = 0.01  ![N]. 
                        !Michaelis-Menten constant for photosynthetic N 
                        !leaving the plant in senescing litter fluxes.
               !The flux of photosynthetic N to surface litter is:
                    ONph_li = fNphli * Nph * OXle4_li 
               !The remainder enters the foliage (le) N substrate pool:
                    INph_li_NSle = ONph_li0 - ONph_li
                                   !kg N substrate stem-1 day-1.


   !Leaf area, Aleaf (m2 stem-1)
      !Incremental specific leaf area, SLAXnew. This is the specific leaf area
         !for new leaves [m2 (leaf) (kg structural DM)-1]:
            SLAXnew = SLAmax * fSLA_leS * fSLA_W 
               Constant SLAmax = 10.0 !m2 (leaf) (kg structure)-1.
                  !Maximum value of incremental SLA.
                  !This is a single-sided SLA. 
                  !If all surfaces of the needles are counted,
                  !the value is double. 
                  !Refs:
                     !Ford ED. 1982. Forestry 55, 1-17. Table 3. Specific
                     !needle area (SNA) varies from 3 to 6 m2 kg-1,
                     !(depending on age of branch) 
                     !and level in the plantation. Paper contains some
                     !nice data.
                  !Landsberg, JJ. 1986. Physiological Ecology of
                     !Forest Production, Academic Press, London.
                     !1 m2 of foliage area has a mass of 286 g (3.4 m2 kg-1).
                  !Cannell, MGR. 1987. Proc Roy Soc Edin 93B, 61-73.
                     !Table 1. Sitka Spruce. 4.0 m2 kg-1.
               !3 options are provided for calculating dependence of new SLA
               !on foliage (le) substrate (S) levels.
               IF ( s_SLA .EQ. one ) THEN
                  Constant s_SLA = 1      !Default value of switch.
                  fSLA_leS = fSLA_C       !depends on le C substrate only.
               ELSE IF (s_SLA .EQ. two ) THEN
                  fSLA_leS = fSLA_CMM     !depends on le C substrate according
               ELSE                       !to Michaelis-Menten.
                  fSLA_leS = fSLA_rCN     !depends on le C:N substrate ratio.
               ENDIF

              !fSLA_C. Dependence of incremental SLA on C substrate only,
                      !linearly, from 1 down to a minimum value of 1/4.
                  fSLA_Cz =  one - cSLA_C * Cle 
                     Constant cSLA_C = 2.5 ![C]-1. Incremental SLA parameter.
                        !A Cle = 0.1 decreases SLA by 25%.
                        !This value may be rather low.
                        !The HPM uses a value of 10, supported by data
                         !(see pasture.csl).  This gives a bigger
                        !response of SLA to increased CO2.
                        !LINGRA_CC (L perenne uses 7).
                  IF ( fSLA_Cz .LT. quarter ) THEN
                       fSLA_C = quarter
                  ELSE  
                       fSLA_C = fSLA_Cz 
                  ENDIF


              !fSLA_CMM. Dependence of incremental SLA on C substrate 
                        !according to a Michaelis-Menten equation.
               fSLA_CMM = ( KCle_SLA + fSLA_CMM_min * Cle ) &
                                       / ( KCle_SLA + Cle )
                  Constant fSLA_CMM_min = 0.5 !Minimum value of f
                                              !when Cle large.
                  Constant KCle_SLA = 0.25 ![C]-1. Determines initial slope
                                      !of f. df/dCle = - K(1-f)/(K+Cle)^2.
                                      !At Cle=0, df/dCle = -(1-f)/K.
                                      !or, -2.  A +delC of 0.1, decreases
                                      !f by 0.2.

              !fSLA_rCN. Dependence of incremental SLA on ratio of 
                        !foliage C substrate : N substrate
                        !according to a sigmoidal Michaelis-Menten equation.
               fSLA_rCN =  ( KrCNleSLAq  + rCNleq * fSLA_rCNmin ) &
                                        / ( KrCNleSLAq + rCNleq )
                                  rCNleq = rCNle ** qrCNle
                                          !rCNle = Cle / Nle. See above.
                                !If rCNle = 0, fSLA_rCN = 1.
                                !If rCNle = KrCNleSLA, 
                                   !then, fSLA_rCN = 1 - fSLA_rCNdec/2 
                                   != 1 - 0.8/2 = 0.6.
                                !If rCNle = large, 
                                   !fSLA_rCN = fSLA_rCNmin = 0.2.
                                !As the C:N (le) substrate ratio increases, 
                                !fSLA_rCN decreases, and SLA decreases. 
                      Constant fSLA_rCNmin = 0.2
                         !Minimum value of incremental specific leaf
                         !area (SLA) modifier fraction.
                         !LINGRA_CC (Rodriguez D, Van Oijen M, Schapendonk AHMC
                         !(?New Phytologist, 2000) for SLA versus C substrate
                         !for L perenne grown in the Wageningen Rhizolab.
                         !Too high maybe?
                      Constant KrCNleSLA = 2  !substrate [C] (substrate [N])-1.
                         !Michaelis-Menten constant for above.
                         !KrCNleSLAq = KrCNleSLA ** qrCNle (Initial Section).
                         !If you increase KrCNleSLA, then, if everything
                         !remains the same, SLA increases (because fSLA_rCN is
                         !closer to 1.
                      Constant qrCNle = 2 !Sigmoid constant for above.

               fSLA_W =  one - s_water * cSLA_W * ( one - thetale ) 
         Constant cSLA_W = 1  !Dimensionless.
            !Constant determining the effect of foliage relative water content
            !on leaf area expansion. If thetale = 0.9, rather than 1.0, 
            !SLA is decreased by 10%.

         !Growth rate in leaf area (m2 stem-1 day-1) results from buds
            !opening.  See <Ibud_Aleaf1 = > above.

         !Actual specific leaf area (for total leaf area present):
            IF ( s_leaf .EQ. one .AND. Mle .GT. c1E_14 ) THEN
                 SLA = Aleaf / Mle         !m2 leaf (kg leaf DM)-1.
            ELSE
                 SLA = zero
            ENDIF
                 SLAs_leaf = s_leaf * SLA  !for calculating averages.
                                           !This is the SLA when the leaves
                                           !are present (beech, s_leaf = 1). 
                 rCNles_leaf = rCNle * s_leaf 
                                           !Ditto for ratio C:N le substrates.
               
   !C substrate flux from foliage (le) to branches (br):
      !OCSle_CSbr (kg C stem-1 day-1).
         !Resistances, rCle, rCbr, are associated separately with
         !foliage (le), branches (br) [stem day (kg XDM)-1]:
            !rCle:
               IF ( MXle .GT. c1E_14 ) THEN
                                       MXleqC = MXle ** qroC 
                      rCle20 = roC20 / MXleqC 
                               denfTWle = fTWle
                  rCle = rCle20 / fTWle  !(fTWle = fTsh * fWle).
                                 ![kg XDM (stem day)-1]-1. 
                  !Substrate C transport resistance between foliage
                  !and branches:
                     rClebr = rCle + rCbr  !stem day (kg XDM)-1.
                  OCSle_CSbr = s_leaf * ( Cle - Cbr ) / rClebr 
                  ICSle_CSbr = OCSle_CSbr !Input into C substrate branches
                                          !pool.
               ELSE
                  OCSle_CSbr = zero
                  ICSle_CSbr = OCSle_CSbr
                  !rCle and rClebr are left unassigned.
               ENDIF
                  Constant roC20 = 0.1 !stem day (kg XDM)**(qroC - 1). 
                     !C resistivity constant, 20 oC value.
                  Constant qroC = 1          !Dimensionless. 
                     !Scaling (allometric) parameter for C substrate
                     !transport resistances within the tree.
                  !rCbr is calculated in branches section below.

      !There is a respiratory cost associated with loading carbohydrate
      !into the phloem.  We use Bouma's number of 0.7 mol CO2 per mol 
      !sucrose, or 0.06 C per C exported.  This is taken from the C 
      !substrate pool:
         OCSle_loading = cphloem_loading * OCSle_CSbr      !kg C stem-1 day-1.
         Rphloem_loading = OCSle_loading          !kg C respired stem-1 day-1.
         Constant cphloem_loading = 0.06 !C respired per C loaded into phloem.
            !Bouma, thesis, 1995: 0.7 mol CO2 per mol sucrose.
         Rphloem_loading_gnd = nstems * Rphloem_loading      !kg C m-2 year-1.

   !N substrate flux from branches (br) to foliage (le), 
      !ONSbr_le (kg N stem-1 day-1), is calculated in branches section below.


   !Respiration fluxes. 
      !For maintenance, use either 1 (then s kXle_mai20 = 0)
         !or 2 (then set kmai20 = 0).
      !1. C substrate-dependent maintenance respiration, depending on N
         !components of foliage.
         !OCSle_mai (kg C stem-1 day-1) is the foliage C substrate pool
                                               !maintenance respiration.
         !This is assumed proportional to N content.
            kmai_le = s_leaf * kmai20 * fTWle  
           !s_leaf is to switch off process if no leaves are present.
           !To turn this process off compeltely, s kmai20 = 0.
            Constant kmai20 = 0.1  !kg C substrate (kg total N)-1 day-1.
                    !Maintenance respiration constant at 20 oC.
                    !See Fig 3 of Ryan, 1995, PC&E 18, 765-772.
                    !0.56 = 8e-6 (ordinate) * 86400 * 12 / [3 (abscissa)
                    ! * 14 * 0.35] (0.35 is to correct Ryan's 10 deg C
                    !value to 20 deg C).
            fCSmai_le = Cle / ( Cle + KCmai )
            Constant KCmai = 0.05  ![C]; this turns down maintenance
                                   !respiration at low C substrate levels.   
                !Components of le N mass which contribute to maintenance:
                    IF ( MNXle .GT. zero ) THEN
                         MNle_maiX = s_NX_mai * MNXle * &
                                      ( MNXle / MNXle0z ) ** qNX_mai_1
                    ELSE
                         MNle_maiX = zero
                    ENDIF
                    MNle_maiS = s_NS_mai * MNSle
                    MNle_maiph = s_Nph_mai * MNph_can !kg N stem-1.
                    Constant qNX_mai = 1 !Dimensionless. Allometric constant.
         MNle_mai = MNle_maiX + MNle_maiS + MNle_maiph 
                !kg N stem-1. N content which causes maintenance respiration.
                Constant s_NX_mai = 1.0, s_NS_mai = 0, s_Nph_mai = 1.0

         OCSle_mai = kmai_le * fCSmai_le * MNle_mai

      !2. Structural DM flux to maintenance.
         !(There is no loss in leaf area).
         !Foliage structural DM loss, OXle_mai (kg foliage XDM stem-1 day-1):
            OXle1_mai = kXle_mai * MXle1; OXle2_mai = kXle_mai * MXle2
            OXle3_mai = kXle_mai * MXle3; OXle4_mai = kXle_mai * MXle4
            OXle_mai = OXle1_mai + OXle2_mai + OXle3_mai + OXle4_mai
                       kXle_mai = s_leaf * kXle_mai20 * fTWle
                       !s_leaf is to switch off process if no leaves present.
                        Constant kXle_mai20 = 0.0      !day-1.
                                             !Default: process switched off.
                       !Constant kXle_mai20 = 0.00015  !day-1. 
                       !This is 0.5 of litter parameter, kXle_li20.
         !OCXle_mai, ONXle_mai (kg XC, XN stem-1 day-1):
               !Structural C and N fluxes to maintenance. C flux goes to
               !environment as CO2.  N flux is returned to NS pool.
               !The structural C:N ratio is unchanged.
            OCXle_mai = fCleX * OXle_mai   !kg XC stem-1 day-1.
            ONXle_mai = fNleX * OXle_mai   !kg XN stem-1 day-1.
         !The C flux is respired:
               RmaiXle = OCXle_mai         !kg C respired stem-1 day-1.
         !The N flux is returned to the N substrate pool:
            INmaiX_NSle = ONXle_mai         !kg NS stem-1 day-1.

      !3. OCSle_Nnit_red, respiration associated with nitrate reduction in
         !the shoot.
            OCSle_Nnit_red = s_leaf * fuNnit_red_sh_CS * cnit_red &
                                    * fuNnit_red_sh * uNnit
                                             !kg C substrate stem-1 day-1.
            RNnit_red_le = OCSle_Nnit_red    !kg C respired stem-1 day-1.
               Constant fuNnit_red_sh_CS = 0.5 !Fraction of nitrate reduced in
                  !shoot requiring shoot C substrate.  It is assumed that
                  !the rest is reduced using ATP and reducing power
                  !obtained directly from photosynthesis.
               Constant cnit_red = 1.7 !kg substrate C (kg nitrate N)-1.
                  !Respiratory cost of nitrate reduction.
                  !Based on: HNO3 + 8H = NH3 + 3H2O.
                  !C6H12O6 + 6H2O = 6CO2 + 24H.
                  !Thus 1 kg NO3 N needs 8/24 72/14 = 1.71 kg C substrate.
               Constant fuNnit_red_rt = 0.5 !Fraction of nitrate taken up by
                  !root which is reduced in root. Rest is reduced in shoot.
                  fuNnit_red_sh = 1 - fuNnit_red_rt 
      !Total foliage respiration, Rle (kg C stem-1 day-1)
         Rle_mai = OCSle_mai + RmaiXle 
         Rle = Rle_mai + RGle_bud + Rphloem_loading + RNnit_red_le
         Rle_gnd = Rle * nstems



   !Fluxes between age categories and fluxes to litter. 
      !Leaf area transfers (m2 stem-1 day-1):
         OAleaf1_2 =  m_kXle1_li * kXle_li * Aleaf1
         OAleaf2_3 =  m_kXle2_li * kXle_li * Aleaf2
         OAleaf3_4 =  m_kXle3_li * kXle_li * Aleaf3
         OAleaf4_li = m_kXle4_li * kXle_li * Aleaf4   !to litter.
                  denkXle_li = MAX( fWle, fWle_min )
                     Constant fWle_min = 0.1 !This is to prevent problems 
                                             !occurring when fWle is small 
                                             !(deciduous trees).
                  kXle_li = s_leaf * m_dorm1_kXle_li * kXle_li20 &
                                   * fTsh / denkXle_li
                     !s_leaf is to switch off process if no leaves present.
                     !m_dorm1_kXle_li is a multiplier, to increase the
                     !leaf senescence rate as dormancy apporoaches in 
                     !deciduous mode.  Conifer mode: m_dorm1_kXle_li = 1.
                      Constant kXle_li20 = 0.002              !day-1.
                     !Half-life of foliage at 10 deg C (fTsh = 0.35)
                     != 0.69/ (0.35 * k) = 1000 day.  4 compartments.
                     !Overall: 4000 days.  About 11 years for fully
                     !illuminated foliage.
               !Leaf senescence depends on temperature (fTsh).
               !Leaf senescence increases with increasing water stress
                  !(decreasing fWle, as in Hurley Pasture Model).
               !The multipliers, m_kXle1_li, etc increase the rates, 
               !depending on the
               !light level, averaged over time, of the leaves in that
               !category.  See above.  Switch the multipliers to 1 with
               !s s_light_KXle_li = 0.0.

      !Foliage structural DM transfers:
         !(there is assumed to be no flux from meristematic structure)
         kXle1_2 =  m_kXle1_li * kXle_li !day-1.
         kXle2_3 =  m_kXle2_li * kXle_li
         kXle3_4 =  m_kXle3_li * kXle_li
         kXle4_li = m_kXle4_li * kXle_li
         OXle1_2 =  kXle1_2 * MXle1   !kg foliage XDM stem-1 day-1.
         OXle2_3 =  kXle2_3 * MXle2
         OXle3_4 =  kXle3_4 * MXle3
         OXle4_li = kXle4_li * MXle4  !to litter.
                                      !Note no self-thinning term. Cf OXbr_li.

      !C, N fluxes to surface litter, OCXle_li, ONXle_li 
                                       !(kg XC, XN stem-1 day-1).
         !Some of the structural C is recycled to the C substrate pool.
         OCXle_li1 = fCleX * OXle4_li   !kg XC stem-1 day-1.
            !OCXle_li1 is the C flux towards litter before recycling.
               ICXli_rec_CSle = fCXle_rec * OCXle_li1   !kg C stem-1 day-1. 
                  !This is the recycled C flux, where
                  fCXle_rec = fCXle_rec_max / ( Cle / KCXli_rec + one ) 
                  !fCXle_rec is the fraction of foliage structural C flux to
                  !litter recycled to the foliage substrate C pool.
               Constant fCXle_rec_max = 0.5 !Dimensionless.
               Constant KCXli_rec = 0.02    !kg C substrate (kg XDM)-1.
                  !Michaelis-Menten constant.
                  !fCXle_rec_max is maximum value of fCXle_rec if Cle = 0.
         OCXle_li = OCXle_li1 - ICXli_rec_CSle

            !Some of the structural N is recycled:
               ONXle_li1 = fNleX * OXle4_li !The N flux without recycling.
               INXli_rec_NSle = fNXle_rec * ONXle_li1   !kg N stem-1 day-1. 
                  !This is the recycled N flux, where
                  fNXle_rec = one / ( Nle / KNXli_rec + one ) 
               Constant KNXli_rec = 0.01   !kg N substrate (kg XDM)-1.
                  !Michaelis-Menten constant.
                  !fNXle_rec is the fraction of foliage structural N flux to
                  !litter recycled to the foliage substrate N pool.
                  !If Nle ---> 0, this fraction becomes 1. Data suggest for
                  !Scots Pine about 70% can be recycled 
                  !(Berg et al 1982. Oikos 38: 291-296).
                  !In alder (N-fixing), the recycled fraction falls to 30%. 
                  !Berg B has published many papers on this topic.
         ONXle_li = ONXle_li1 - INXli_rec_NSle 

      !OCSle_li, ONSle_li (kg substrate C, N m-2 day-1). 
         !Substrate C and N fluxes to surface litter.
                  fCSleli = ( fCSli_min * KCSli + Cle ) / &
                             ( KCSli + Cle )
                             !This is the fraction of C substrate in the
                             !structural litter flux which is lost to litter.
                     Constant fCSli_min = 0.3   !Dimensionless.  
                        !The minimum fraction of
                        !C substrate lost in the senescing litter fluxes.
                     Constant KCSli = 0.05  ![C]. 
                        !Michaelis-Menten constant for C substrate
                        !loss in senescing litter fluxes.
          OCSle_li = fCSleli * Cle * OXle4_li

                  fNSleli = ( fNSli_min * KNSli + Nle ) / &
                             ( KNSli + Nle )
                             !This is the fraction of N substrate in the
                             !structural litter flux which is lost to litter.
                     Constant fNSli_min = 0.3   !Dimensionless.  
                        !The minimum fraction of
                        !N substrate lost in the senescing litter fluxes.
                     Constant KNSli = 0.01   ![N]. 
                        !Michaelis-Menten constant for N substrate
                        !loss in senescing litter fluxes.
          ONSle_li = fNSleli * Nle * OXle4_li

   
   !Outputs to/from self-thinning (sn) /generation of new stems:
      !It is assumed that trees dying from self-thinning have
      !no foliage.  New trees, are generated at a net 
      !fractional growth rate of FGRnstems_sn (this can be > or < 0).
      ! If FGRnstems_sn > 0, this causes nstems to increase so that any
      ! variable per unit ground area will decrease.
      !by sn, this acts as an output on that per stem vaiable.
      !(if FGRnstems_sn < 0) the average per stem of
      !foliage variables , so that the foliage per unit 
      !ground area, or any other foliage variable per unit ground area, is
      !unaffected by natural death and rebirth.

      !Outputs from leaf area compartments (per stem):
      OAleaf1_sn = FGRnstems_sn * Aleaf1; OAleaf2_sn = FGRnstems_sn * Aleaf2
      OAleaf3_sn = FGRnstems_sn * Aleaf3; OAleaf4_sn = FGRnstems_sn * Aleaf4
                                                       !m2 leaf stem-1 day-1.
      !Leaf structural dry matter (XMD) outputs:
      OXle1_sn = FGRnstems_sn * MXle1;  OXle2_sn = FGRnstems_sn * MXle2
      OXle3_sn = FGRnstems_sn * MXle3;  OXle4_sn = FGRnstems_sn * MXle4
                      !kg leaf structural dry matter stem-1 day-1.
      OCSle_sn = FGRnstems_sn * MCSle 
      ONSle_sn = FGRnstems_sn * MNSle
      ONph_sn =  FGRnstems_sn * MNph
         !kg leaf carbon, nitrogen substrate, photosynthetic N stem-1 day-1.
      !These fluxes are switched off if there are no leaves
      !present, e.g. with s_leaf = 0, during the winter for deciduous
      !trees.  Also for pruning below.


   !Outputs to pruning.
      !If it is applied, then pruning is applied at a constant rate
      !throughout the year.
         kle_prune = s_prune * s_leaf * kle_prunez !day-1.
            !Pruning rate constant.  kle_prunez is calculated near the
            !beginning of Derivative Section (from fpruneyr). 
            !Default values of k??_prune, k??_prunez,  = 0.
            !?? = le, br, st, co, fi.
            !We turn off the effects of pruning on the leaves when there
            !are no leaves (s_leaf = 0), which includes the day of budburst
            !and of leaf fall.
      !All foliage state variables are decreased at the same rate.
      !Pruning of leaf area:
         OAleaf1_prune = kle_prune * Aleaf1              !m2 stem-1 day-1.
         OAleaf2_prune = kle_prune * Aleaf2              !m2 stem-1 day-1.
         OAleaf3_prune = kle_prune * Aleaf3              !m2 stem-1 day-1.
         OAleaf4_prune = kle_prune * Aleaf4              !m2 stem-1 day-1.
      !Foliage structural compartments:
         OXle1_prune = kle_prune * MXle1              !kg XDM stem-1 day-1.
         OXle2_prune = kle_prune * MXle2              !kg XDM stem-1 day-1.
         OXle3_prune = kle_prune * MXle3              !kg XDM stem-1 day-1.
         OXle4_prune = kle_prune * MXle4              !kg XDM stem-1 day-1.
         OXle_prune = OXle1_prune + OXle2_prune + OXle3_prune + OXle4_prune
         OCXle_prune = fCleX * OXle_prune             !kg XC stem-1 day-1.
         ONXle_prune = fNleX * OXle_prune             !kg XN stem-1 day-1.
      !Foliage C and N substrates:
         OCSle_prune = kle_prune * MCSle      !kg C substrate stem-1 day-1.
         ONSle_prune = kle_prune * MNSle      !kg N substrate stem-1 day-1.
      !Photosynthetic N:
         ONph_prune = kle_prune * MNph   !kg photosynthetic N stem-1 day-1.
      !Water:
         OWle_prune = kle_prune * Wle         !kg W stem-1 day-1.

      !On a ground area basis:
         OCXle_prune_gnd = nstems * OCXle_prune         !kg CX m-2 day-1.
         ONXle_prune_gnd = nstems * ONXle_prune         !kg NX m-2 day-1.
         OCSle_prune_gnd = nstems * OCSle_prune         !kg CS m-2 day-1.
         ONSle_prune_gnd = nstems * ( ONSle_prune + ONph_prune ) 
                                                        !kg NS m-2 day-1.
         OWle_prune_gnd = nstems * OWle_prune           !kg W m-2 day-1. 


   !Differential eqns:
                IAleaf1 = Ibud_Aleaf1 !
                         !sn = self-thinning.  lf = leaf fall.
      DAleaf1 = treevr * ( IAleaf1    - OAleaf1_2  - OAleaf1_sn &
                                      - OAleaf1_prune - OAleaf1_lf &
                                      - OAleaf1_fire )
      DAleaf2 = treevr * ( OAleaf1_2  - OAleaf2_3  - OAleaf2_sn &            
                                      - OAleaf2_prune - OAleaf2_lf &
                                      - OAleaf2_fire )
      DAleaf3 = treevr * ( OAleaf2_3  - OAleaf3_4  - OAleaf3_sn &            
                                      - OAleaf3_prune - OAleaf3_lf &
                                      - OAleaf3_fire )
      DAleaf4 = treevr * ( OAleaf3_4  - OAleaf4_li - OAleaf4_sn &            
                                      - OAleaf4_prune - OAleaf4_lf &
                                      - OAleaf4_fire )
                DAleaf = DAleaf1 + DAleaf2 + DAleaf3 + DAleaf4

                           IXle1 = Ibud_Xle1
                           IXle = IXle1 !For convenience, similar to IXbr etc.
                           IMXle = IXle1 !For consistancy of notation.
         OXle1 = OXle1_2 + OXle1_mai + OXle1_sn + OXle1_prune + OXle1_lf &
                 + OXle1_fire !Output from MXle1 pool. New statement, 
                              !not used elsewhere except to *1Jul15h, 
                              !OXle1da, OXle1ya
      DMXle1 =  treevr * ( IXle1   - OXle1_2  - OXle1_mai - OXle1_sn &       
                                   - OXle1_prune - OXle1_lf - OXle1_fire )
      DMXle2 =  treevr * ( OXle1_2 - OXle2_3  - OXle2_mai - OXle2_sn &       
                                   - OXle2_prune - OXle2_lf - OXle2_fire )
      DMXle3 =  treevr * ( OXle2_3 - OXle3_4  - OXle3_mai - OXle3_sn &
                                   - OXle3_prune - OXle3_lf - OXle3_fire )
      DMXle4 =  treevr * ( OXle3_4 - OXle4_li - OXle4_mai - OXle4_sn &
                                   - OXle4_prune - OXle4_lf - OXle4_fire )
      DMXle = DMXle1 + DMXle2 + DMXle3 + DMXle4  !Total of 4 age categories.
         !IMXle is given above.
      OXle_sn = OXle1_sn + OXle2_sn + OXle3_sn + OXle4_sn !Output to 
               !self-thinning.
      OMXle = OXle_mai + OXle_lf + OXle_fire + OXle_prune + OXle_sn &
                       + OXle4_li
      DMXle_chk = IMXle - OMXle !Check. Cf with DMXle.
             !OK when self-thinning is occurring.

                          ICSle = ICph_CSle + ICXli_rec_CSle + ICbud_CSle
                          OCSle = OCSle_CSbr + OCSle_mai &
                                  + OCSle_loading + OCSle_Nnit_red &
                                  + OCSle_bud &
                                  + OCSle_li + OCSle_sn + OCSle_prune &
                                  + OCSle_lf + OCSle_aph + OCSle_fire
                                  !Note: C output for bud/leaf growth
                                  !is taken from CSle and CSbr.
      DMCSle = treevr * ( ICSle - OCSle )

                          INSle = INSbr_NSle + INXli_rec_NSle &
                                + INph_NSle + INph_li_NSle &
                                + INmaiX_NSle + INbud_NSle
                          ONSle = ONSle_Nph + ONSle_atm_stem &
                                          + ONSle_bud &
                                          + ONSle_li + ONSle_sn &
                                          + ONSle_prune + ONSle_lf &
                                          + ONSle_aph + ONSle_fire
      DMNSle = treevr * ( INSle - ONSle )

                            INph = INSle_Nph + INbud_Nph
                            ONph = ONph_NSle + ONph_li0 + ONph_sn &
                                   + ONph_prune + ONph_lf + ONph_fire
      DMNph = treevr * ( INph - ONph )
                                            
   !Integration statements:
      Aleaf1 = INTEG( DAleaf1, Aleaf10 )
      Aleaf2 = INTEG( DAleaf2, Aleaf20 )
      Aleaf3 = INTEG( DAleaf3, Aleaf30 ) 
      Aleaf4 = INTEG( DAleaf4, Aleaf40 ) 
      MXle1 = INTEG( DMXle1,  MXle10 ) 
      MXle2 = INTEG( DMXle2,  MXle20 ) 
      MXle3 = INTEG( DMXle3,  MXle30 ) 
      MXle4 = INTEG( DMXle4,  MXle40 ) 
      MCSle = INTEG( DMCSle, MCSle0 ) 
      MNSle = INTEG( DMNSle, MNSle0 ) 
      MNph = INTEG( DMNph, MNph0 )       !Photosynthetic N in upper leaves.

      !Assume photosynthetic N varies from a value equivalent to MNph at
      !the top of the canopy, according to exp ( - kcan * LAI ) on descending
      !the canopy.  This is equivalaent to the Charles-Edwards assumption
      !(used for calculating photosynthesis) that Pmax  varies as 
      !exp ( - kcan * LAI ) within the canopy.
            denkcanLAI = kcanLAI
         IF ( kcanLAI .GT. zero ) THEN
            zexp_kcanLAI = one_exp_kcanLAI / kcanLAI
               !one_exp_kcanLAI = one - EXP( - kcan * LAI ) 
               !kcanLAI = kcan * LAI
         ELSE
            zexp_kcanLAI = one
         ENDIF
         !zexp_kcanLAI is the average of EXP( - kcan * LAI) over the canopy.
            ! = integral EXP( - kcan * LAI) dL / integral 1 * dL.
            !Small LAI, zexp_kcanLAI = 1,
            !Large LAI, zexp_kcanLAI = 1 / (kcan * LAI).
      !DMNph_can = DMNph * zexp_kcanLAI   !Not used.
       MNph_can =  MNph * zexp_kcanLAI
          MNple = MNph_can !For output only. D MN?le.

   !Foliage balance checks
      !Checks on leaf foliage C balance:
         DMCle = fCleX * DMXle + DMCSle                   !kg C stem-1 day-1.
         DCle_gnd = Dnstems * MCle + nstems * DMCle       !kg C m-2 day-1.
         ICle = s_leaf * Pcan_IP + OCbud_le_gnd           !kg C m-2 day-1.
            OCle_li = nstems * ( OCSle_li + OCXle_li )    !kg C m-2 day-1.
            OXle_lf = OXle1_lf + OXle2_lf + OXle3_lf + OXle4_lf 
                                                          !kg X stem-1 day-1.
            OCXle_lf = fCleX * OXle_lf                    !kg CX stem-1 day-1.
            OCXle_lf_gnd = OCXle_lf * nstems              !kg CS m-2 day-1.
            OCSle_lf_gnd = OCSle_lf * nstems
            OCle_lf_gnd = OCXle_lf_gnd + OCSle_lf_gnd     !kg C m-2 day-1.
            OCle_prune_gnd = OCXle_prune_gnd + OCSle_prune_gnd  
                                                          !kg C m-2 day-1.
            OCle_sn = Cle * MXle * nstems * FGRnstems_sn  !kg C m-2 d-1.
                 !Cle, kg C substrate (kg XDM)-1. MXle: kg XDM stem-1.
         OCle = IC_lebud_gnd + Rle_gnd + OCle_IP_atm_gnd &
                              + nstems * OCSle_CSbr &
                              + OCle_li + OCle_prune_gnd &
                              + OCle_th + OCle_lf_gnd + OCle_fire_gnd &
                              + OCle_sn
                                                            !kg C m-2 day-1.
         DCle_gnd_chk = ICle - OCle                !This should = DCle_gnd.
               !Not ok when self-thinning is occurring. 

      !Checks on leaf foliage N balance:
         DMNle = fNleX * DMXle + DMNSle + DMNph            !kg N stem-1 day-1.
         DNle_gnd = Dnstems * MNle + nstems * DMNle        !kg N m-2 day-1.
         INle = nstems * INSbr_NSle + ONbud_le_gnd         !kg N m-2 day-1.
            ONle_li = nstems * ( ONSle_li + ONXle_li + ONph_li )    !ditto.
            ONXle_lf = fNleX * OXle_lf                     !kg NX stem-1 day-1.
            ONXle_lf_gnd = ONXle_lf * nstems               !kg NX m-2 day-1.
            ONSle_lf_gnd = ONSle_lf * nstems               !kg NS m-2 day-1.
            ONSle_bud_gnd = nstems * ONSle_bud             !kg NS m-2 day-1.
            ONph_lf_gnd = ONph_lf * nstems                 !kg Nph m-2 day-1.
            ONle_lf_gnd = ONXle_lf_gnd + ONSle_lf_gnd + ONph_lf_gnd
                                                           !kg N m-2 day-1.
            ONle_prune_gnd = ONXle_prune_gnd + ONSle_prune_gnd 
                                                           !kg N m-2 day-1.
         ONle = ONle_li + ONle_prune_gnd + ONle_th + ONle_lf_gnd &
                        + ONSle_bud_gnd &
                        + ONSle_atm_gnd + ONle_fire_gnd    !kg N m-2 day-1.
         DNle_gnd_chk = INle - ONle                !This should = DNle_gnd.
             !Not ok when self-thinning is occurring.

      !Checks on leaf foliage water balance: 
         DWle_gnd = Dnstems * Wle + nstems * DWle          !kg W m-2 day-1.
         !IWle is calculated below.
            IWle_gnd = nstems * IWle
            OWle_lf_gnd = OWle_lf * nstems                 !kg W m-2 day-1.
            IWle_lf_Wsoil = OWle_lf_gnd
            IWle_prune_Wsoil = OWle_prune_gnd
         OWle_gnd = OWle_atm_gnd + OWle_prune_gnd + OWle_th + OWle_lf_gnd &
                                 + OWle_fire_gnd
         DWle_gnd_chk = IWle_gnd - OWle_gnd         !This should = DWle_gnd.
              !True when self-thinning is occurring.

!BRANCHES (br)
         !Note: denominators.  All the / denominators likely to give
         !trouble have been labelled up to this point.  To see these
         !do display den* at runtime.  I did not get beyond this point
         !because I found the bug I was looking for.
   !Variables
      !Total structural dry matter:
         MXbrtot = MXbr + MXbrm                       !kg XDM stem-1.
      !Fraction of total XDM in meristem XDM:
         fXbrm = MXbrm / MXbrtot                      !Dimensionless.
      !Total substrate dry matter (kg substrate DM stem-1):
         MSbr = ( MCSbr * rmmCS12 + MNSbr * rmmNS14 )  
                                            !See above for rmmCS12, rmmNS14.
      !Total branch dry matter:    
         Mbr = MXbrtot + MSbr                         !kg DM stem-1.
      !Branch structural C (heartwood, meristem, total):
         MCXbr = fCbrX * MXbr; MCXbrm = fCbrm * MXbrm
         MCXbrtot = MCXbr + MCXbrm                        !kg XC stem-1.
      !Total branch C: 
         MCbr = MCSbr + MCXbrtot                      !kg C stem-1.
      !Nitrogen:  
         MNXbr = fNbrX * MXbr      !kg XN stem-1. Structural N in branch
                                   !heartwood.
         MNXbrm = fNbrm * MXbrm    !kg XN stem-1. Structural N in branch
                                   !meristem.
         MNXbrtot = MNXbr + MNXbrm !kg XN stem-1. Total structural branch DM.
         MNbr = MNSbr + MNXbrtot   !kg N stem-1.  Total branch N.
      !C and N concs (substrates stored in meristem only):
          Cbr = MCSbr / MXbrm;    Nbr = MNSbr / MXbrm
                                            ![kg C, N substrate (kg XDM)-1].
   !Growth rates
      !Growth of meristem (kg meristematic XDM stem-1 day-1):
         !Potential branch meristem size, MXbrmpot:
            CNbr = Cbr * Nbr              ![CS][NS].  Branch nutrient status.
            Abrm = Abr  !m2 stem-1.  Area of of branch meristem.
                  !We have assumed that branch area Abr is all meristematic,
                  !and can support growth of further branches.
                  !Maybe this is not a good assumption, and we could add on
                  !a term fAst_brm * Ast, proportional to stem area, where
                  !Constant fAst_brm = 0.2  !Dimensionless.  Fraction of stem
                  !area Ast which can support branch meristem.
            MXbrmpot = cpotbrm * Abrm * CNbr                  !kg XDM stem-1.
               Constant cpotbrm = 1000 !kg XDM (m2 branch surface [C] [N])-1.

            !Intrinsic specific growth rate of branch meristem is (day-1)
                     kGbrm = kGbrm20 * fTWle !fTWle = fTsh * fWle. See above.
            ISGRbr = kGbrm * CNbr
            Constant kGbrm20 = 200 !([CS] [NS] day)-1. Growth rate constant.
         !Total growth (production) activity of branch meristem:
            PXDMbrm = ISGRbr * MXbrm         !kg XDM stem-1 day-1.
            PXDMbrm_gnd = nstems * PXDMbrm   !kg XDM m-2 day-1.
               rbrmpot_brm = MXbrmpot / MXbrm  !Ratio of potential:actual.
               zbrm = MIN( rbrmpot_brm - one, 0.999999 )  !Working variable.
            IXbrm = PXDMbrm * zbrm 
               !zbrm is a working variable whose range is restricted to (-1,1).
   
      !Growth of branch structure (kg XDM stem-1 day-1):
         IXbr =  PXDMbrm * ( one - zbrm ) 
         GXbr = IXbr

      !Flux of C utilized for growth of M and X (kg C stem-1 day-1): 
         IC_Xbrtot = fCbrm * IXbrm + fCbrX * IXbr !kg C input into br X.
         OCSbr_G = IC_Xbrtot / YGbr !kg br sC required for this X flux.
         Constant fCbrX = 0.4, fCbrm = 0.4  !kg C (kg XDM)-1.
         Constant YGbr = 0.8   !kg C in XDM (kg substrate C utilized)-1.
         IC_Xbrtot_gnd = nstems * IC_Xbrtot !kg C into Xbr m-2 d-1.

      !Flux of N utilized for growth of M and X (kg N stem-1 day-1):
         ONSbr_G = fNbrm * IXbrm + fNbrX * IXbr 
         Constant fNbrm = 0.025, fNbrX = 0.005   !kg N (kg XDM)-1. 
         !N content of branch meristem structural DM, branch structural DM.
  
   !Branch surface area, Abr (m2 stem-1)
      !This is a function of branch total structural DM. 
         Abr = cAbr * MXbr ** qAbr
         Constant cAbr = 0.2, qAbr = 0.666666667
            !If branch height:diameter ratio = hbr / dbr = rhdbr = 20, 
            !branch density = rob,
            !Abr = pi * dbr * hbr = pi * rhdbr * dbr**2
            !Volume Vbr = (pi/4) * dbr**2 * hbr = (pi/4) * rhdbr * dbr**3 
            ! = MXbr / robr
            !dbr = [4 * MXbr / ( pi * robr * rhdbr)] ** 0.3333
            !Abr = (pi * rhdbr)**0.3333  * (4 MXbr / robr)**0.6667 
            !With pi = 3.14, rhdbr = 20, robr = 350 (see rostem), 
            !this gives Abr = 0.2 * MXbr ** 0.6667 
   
   
   !C substrate flux from foliage to branches, OCSle_CSbr = ICSle_CSbr 
      !(kg C stem-1 day-1) is calculated in the foliage section above.
   
   !C substrate flux from branches (br) to stem (st)
      !OCSbr_CSst (kg C stem-1 day-1).
         !Resistances rCbr, rCst, are associated separately with branches
            !(br), stem (st) [stem day (kg XDM)-1]:
                                       MXbrqC = MXbrm ** qroC 
                      rCbr20 = roC20 / MXbrqC 
               rCbr = rCbr20 / fTWle 
                      !Constants roC20 and qroC are given above.
              !rCst is calculated in the stem section below.
          !Substrate C transport resistance between branches and stem:
             rCbrst = rCbr + rCst  !stem day (kg XDM)-1.
      OCSbr_CSst = ( Cbr - Cst ) / rCbrst 
      ICSbr_CSst = OCSbr_CSst  !in input to the CSst pool.
      
   
   !N substrate flux from stem (st) to branches (br),
      !ONSst_br (kg N stem-1 day-1), is calculated in stem section below.
   
   !N substrate flux from branches (br) to foliage (le)
      !ONSbr_le (kg N stem-1 day-1):
         !Resistances, rNbr, rNle, are associated separately with
            !branches (br) and with foliage (le):
                                       MXbrqN = MXbrm ** qroN 
                      rNbr20 = roN20 / MXbrqN 
               rNbr = rNbr20 / fTWle  !(fTWle = fTsh * fWle).
                      Constant roN20 = 2 !stem day (kg XDM)**(qroN - 1). 
                         !N resistivity constant, 20 oC value.
                      Constant qroN = 1          !Dimensionless. 
                         !Scaling (allometric) parameter for N substrate
                         !transport resistances within the tree.
               !rNle:
                  IF ( MXle .GT. c1E_14 ) THEN
                                       MXleqN = MXle ** qroN 
                      rNle20 = roN20 / MXleqN 
                     rNle = rNle20 / fTWle  !(fTWle = fTsh * fWle).
                     rNbrle = rNbr + rNle  !stem day (kg XDM)-1.
                     ONSbr_le = s_leaf * ( Nbr - Nle ) / rNbrle 
                       !Output from branch N substrate
                       !pool. s_leaf is a switch
                       !in case no leaves are present.
                     INSbr_NSle = ONSbr_le !Input to N substrate leaf pool.
                  ELSE
                     ONSbr_le = zero
                     INSbr_NSle = zero
                  ENDIF
  
   
   !Respiration fluxes
      !C substrate-dependent maintenance respiration, 
      !OCSbr_mai (kg C stem-1 day-1). 
         !This is assumed proportional to total N content.
            !Components of N mass which contribute to maintenance:
                    MNbr_maiXme = MNXbrm
                    IF ( MNXbr .GT. zero ) THEN
                       MNbr_maiX = s_NX_mai * MNXbr * &
                                      ( MNXbr / MNXbr0z ) ** qNX_mai_1
                    ELSE
                       MNbr_maiX = zero
                    ENDIF
                    MNbr_maiS = s_NS_mai * MNSbr           !kg br N stem-1.
         MNbr_mai = MNbr_maiXme + MNbr_maiX + MNbr_maiS
                   !kg N stem-1. Branch N causing maintenance respiration.

            kmai_br = kmai20 * fTWle               !fTWle = fTsh * fWle
            fCSmai_br = Cbr / ( Cbr + KCmai )
               !Constant kmai20 = 0.86 !kg C substrate (kg total N)-1 day-1.
               !Constant KCmai = 0.01 ![C]. !See above for explanation of
               !constants.
         OCSbr_mai = fCSmai_br * kmai_br * MNbr_mai

      !Structural DM flux to maintenance.
         !Branches structural DM loss, OXbr_mai (kg branches XDM stem-1 day-1):
            OXbr_mai = kXbr_mai * MXbr
                       kXbr_mai = kXbr_mai20 * fTWle
                       Constant kXbr_mai20 = 0.0      !day-1. 
         !OCXbr_mai, ONXbr_mai (kg XC, XN stem-1 day-1):
               !Structural C and N fluxes to maintenance. C flux goes to
               !environment as CO2.  N flux is returned to NS pool.
               !The structural C:N ratio is unchanged.
            OCXbr_mai = fCbrX * OXbr_mai   !kg XC stem-1 day-1.
            ONXbr_mai = fNbrX * OXbr_mai   !kg XN stem-1 day-1.
         !The C flux is respired:
               RmaiXbr = OCXbr_mai         !kg C respired stem-1 day-1.
         !The N flux is returned to the N substrate pool:
            INmaiX_NSbr = ONXbr_mai         !kg NS stem-1 day-1.

      !Growth respiration, RGbr (kg C stem-1 day-1): 
         RGbr = OCSbr_G * ( one - YGbr )   
         !Note: the way we have modelled growth of M and X, we must (?)
            !have fCbrm = fCbrX and a single growth efficiency YGbr.
               !(kg substrate C used for synthesis)-1. 

      !Total branch respiration, Rbr:
         Rbr_mai = OCSbr_mai + RmaiXbr !kg C stem-1 day-1. Total maintenance.
         Rbr = Rbr_mai + RGbr_bud + RGbr  !kg C stem-1 day-1. Maintenance 
                                                           ! + growth.
         Rbr_gnd = nstems * Rbr                              !kg C m-2 day-1.
   
   !Fluxes to litter
      !Branch structural DM loss, OXbr_li (kg XDM stem-1 day-1):
         kXbr_li = m_kXle_li * kXbr_li20 * fTsh / ( fWle + fWle_min )
                  !Constant fWle_min = 0.1 !This is to stop problems when
                                           !fWle is very small 
                                           !(deciduous trees).
            Constant kXbr_li20 = 0.001                               !day-1. 
            !Half-life of branches at 10 deg C = 0.69/(0.35 * k) = 2000 day.
            !m_kXle_li is average multiplier for increasing foliage
            !litter rate.  The idea is that if the foliage senescences 
            !faster due to poor light, then so do the branches.
         OXbr0_li = kXbr_li * MXbr !Direct litter flux from branch structure
                                   !(not due to loss of stems).
         OXbr_sn_li = FDRnstems * MXbr  !Litter flux due to self-thinning.
         OXbr_li = OXbr0_li + OXbr_sn_li   !Total of these two.

      !C, N fluxes to litter, OCXbr_li, ONXbr_li (kg XC, XN stem-1 day-1):
         !Senescing branches carry no C, N substrates.
         !Self-thinning flux of XC:
            OCXbr_sn_li = fCbrX * OXbr_sn_li      !kg XC stem-1 day-1.
         !Initial XC flux from normal branch senescence:
            OCXbr_li1 = fCbrX * OXbr0_li          !kg XC stem-1 day-1.
            !Some of this structural C is recycled.  
            !OCXbr_li1 is the C flux without recycling.
               ICXli_rec_CSbr = fCXbr_rec * OCXbr_li1   !kg C stem-1 day-1. 
                  !This is the recycled C flux, where
                  fCXbr_rec = fCXbr_rec_max / ( Cbr / KCXli_rec + one ) 
                  !fCXbr_rec is the fraction of branches structural C flux to
                  !litter recycled to the branches substrate C pool.
               Constant fCXbr_rec_max = 0.5 !Dimensionless.
              !Constant KCXli_rec = 0.02 kg C substrate (kg XDM)-1. See above.
                  !Michaelis-Menten constant.
                  !fCXbr_rec_max is maximum value of fCXbr_rec if Cbr = 0.
         OCXbr0_li = OCXbr_li1 - ICXli_rec_CSbr 
         OCXbr_li = OCXbr0_li + OCXbr_sn_li

         !Self-thinning flux of (structural N) XN:
            ONXbr_sn_li = fNbrX * OXbr_sn_li      !kg XN stem-1 day-1.
         !Initial structural N flux towards litter is:
            ONXbr_li1 = fNbrX * OXbr0_li  
         !fNXbr_rec is the fraction of branches structural N flux towards
            !litter recycled to the branches substrate N pool: 
               fNXbr_rec = one / ( Nbr / KNXli_rec + one )
                  !Constant KNXli_rec = 0.01 ![N].                        
                  !Michaelis-Menten constant.  See above.
                  !If Nbr = 0, then fNXbr_rec = 1.
         !The recycled N flux, input to the branch N substrate pool is:
               INXli_rec_NSbr = fNXbr_rec * ONXbr_li1   !kg N stem-1 day-1.
            !Finally, the XN flux to litter is given by difference, with:
         ONXbr0_li = ONXbr_li1 - INXli_rec_NSbr !Direct term.
         ONXbr_li = ONXbr0_li + ONXbr_sn_li  !Add on self-thinning term.

   !Outputs to/from self-thinning/generation of new stems
      !See foliage section above for comments. Dying trees are assumed to
      !be without foliage and fine roots, but to possess branches, stems
      !and coarse roots.
      !The litter flux OXbr_li (see above) already
      !includes a self-thinning term proportional to the self-thinning
      !death rate (FDRnstems).
      !The following 4 terms are to account for changing stem numbers m-2.
      !Eg, there might be a zero death rate (FDR..), but a positive birth
      !rate (FBR..) of trees giving a positive 
      !stem number/m2 growth rate (FGR).  As the branch state variables/m2
      !do not change, then the branch state variables/stem decrease because
      !stem numbers are increasing.  Look at
      !<dQ/dt = IQ - OQ - FGRnstems_sn * Q> statement + comments p. 105.
      OXbrm_sn =  FGRnstems_sn * MXbrm 
      OXbr_sn =   FGRnstems_sn * MXbr 
      OCSbr_sn =  FGRnstems_sn * MCSbr 
      ONSbr_sn =  FGRnstems_sn * MNSbr 
   

   !Outputs to pruning
      !Branch pruning are applied at the same rate as foliage pruning.
      !Rate constant is kbr_prune (day-1).
      !See above for more information about pruning.

      !Branch structure alone is removed by pruning.
      !No substrates (CS, NS) or branch meristem (brm) are removed by pruning.
      !Branch structural compartment:
        !kbr_prune = s_prune * kbr_prunez         !day-1. Working variable.

         OXbr_prune = kbr_prune * MXbr            !kg XDM stem-1 day-1.
         OCXbr_prune = fCbrX * OXbr_prune         !kg XC stem-1 day-1.
         ONXbr_prune = fNbrX * OXbr_prune         !kg XN stem-1 day-1.

        !Per unit ground area:
         OCXbr_prune_gnd = nstems * OCXbr_prune   !kg CX m-2 day-1.
         ONXbr_prune_gnd = nstems * ONXbr_prune   !kg NX m-2 day-1.

        !Fractions of these fluxes are diverted to products (prod):
         Constant fbr_prune_prod = 0.1 !A dimensionless fraction.
         OCXbr_prune_prod = fbr_prune_prod * OCXbr_prune_gnd
         ONXbr_prune_prod = fbr_prune_prod * ONXbr_prune_gnd
                                                  !kg CX, NX m-2 day-1.
        !The remainder enters the surface litter pools:
         OCXbr_prune_li = OCXbr_prune_gnd - OCXbr_prune_prod
         ONXbr_prune_li = ONXbr_prune_gnd - ONXbr_prune_prod
                                                  !kg CX, NX m-2 day-1.


   !Differential eqns
                                  OXbrm = OXbrm_sn + OXbrm_fire
      DMXbrm = treevr * ( IXbrm - OXbrm )

                                 OXbr = OXbr_li + OXbr_mai + OXbr_sn &
                                                + OXbr_prune + OXbr_fire
      DMXbr =  treevr * ( IXbr - OXbr )

                          ICSbr = ICSle_CSbr + ICXli_rec_CSbr 
                          OCSbr = OCSbr_CSst + OCSbr_mai + OCSbr_G &
                                  + OCSbr_bud + OCSbr_sn + OCSbr_fire
      DMCSbr = treevr * ( ICSbr - OCSbr ) 

                          INSbr = INSst_NSbr + INmaiX_NSbr + INXli_rec_NSbr
                          ONSbr = ONSbr_bud + ONSbr_le + ONSbr_G &
                                            + ONSbr_sn + ONSbr_fire
      DMNSbr = treevr * ( INSbr - ONSbr ) 
   
   !Integration statements
      MXbr =  INTEG( DMXbr,  MXbr0 )
      MXbrm = INTEG( DMXbrm, MXbrm0 )
      MCSbr = INTEG( DMCSbr, MCSbr0 )
      MNSbr = INTEG( DMNSbr, MNSbr0 )

   !Branches balance checks
      !Checks on branches C balance:
         DMCbr = fCbrX * DMXbr + fCbrm * DMXbrm + DMCSbr !kg C stem-1 day-1.
         DCbr_gnd = Dnstems * MCbr + nstems * DMCbr         !kg C m-2 day-1.
         ICbr = nstems * OCSle_CSbr                         !kg C m-2 day-1.
            OCbr_li = nstems * OCXbr_li                     !kg C m-2 day-1.
           !OCXbr_prune_gnd = nstems * OCXbr_prune          !kg CX m-2 day-1.
            OCbr_prune_gnd = OCXbr_prune_gnd                !kg C m-2 day-1.
         OCbr = IC_brbud_gnd + Rbr_gnd + nstems * OCSbr_CSst + OCbr_li &
                           + OCXbr_prune_gnd + OCbr_th + OCbr_fire_gnd
                                                         !kg C m-2 day-1.
         DCbr_gnd_chk = ICbr - OCbr                !This should = DCbr_gnd.
            !Note: some of the flux OCSbr_bud appears in Rbr_gnd which is why,
            !above, we use ICbrbud_gnd (C input to bud) and not OCSbr_bud 
            !(C output from CSbr pool for bud growth, some which is respired).
                 !Ok with self-thinning.

      !Checks on branches N balance:
         DMNbr = fNbrX * DMXbr + fNbrm * DMXbrm &
                               + DMNSbr                 !kg N stem-1 day-1.
         DNbr_gnd = Dnstems * MNbr + nstems * DMNbr        !kg N m-2 day-1.
         INbr = nstems * INSst_NSbr                        !kg N m-2 day-1.
            ONSbr_bud_gnd = nstems * ONSbr_bud             !kg N m-2 day-1.
            ONbr_li = nstems * ONXbr_li                    !kg N m-2 day-1.
           !ONXbr_prune_gnd =  nstems * ONXbr_prune        !kg NX m-2 day-1.
         ONbr = ONSbr_bud_gnd + nstems * INSbr_NSle + &
                ONbr_li + ONXbr_prune_gnd + ONbr_th + ONbr_fire_gnd
                                                           !kg N m-2 day-1.
                            !No N substrate carried by senescing  branches.
         DNbr_gnd_chk = INbr - ONbr                !This should = DNbr_gnd.
                 !Ok with self-thinning.



!STEM (st)
   !Variables
       !Total structural dry matter:
          MXsttot = MXst + MXstm                      !kg XDM stem-1.
      !Fraction of total XDM in meristem XDM:
         fXstm = MXstm / MXsttot                      !Dimensionless.
      !Total substrate dry matter: 
          MSst = ( MCSst * rmmCS12 + MCstorest * rmmCS12 + MNSst * rmmNS14 )
                                             !kg substrate DM stem-1.
                                             !See above for rmmCS12, rmmNS14.
      !Total dry matter:    
         Mst = MXsttot + MSst                         !kg DM stem-1.
         Mst_gnd = nstems * Mst                       !kg DM m-2.
      !Carbon contents:
      !Stem structural C (XC) (Heartwood, meristem, total):
         MCXst = fCstX * MXst;  MCXstm = fCstm * MXstm
         MCXsttot = MCXst + MCXstm
         MCst = MCSst + MCstorest + MCXsttot     !Substrate C + structural C.
      !Nitrogen:
         MNXst = fNstX * MXst       !kg NX stem-1.  Heartwood NX content.
         MNXstm = fNstm * MXstm     !kg NX stem-1.  Meristem NX content.
         MNXsttot = MNXst + MNXstm  !kg NX stem-1.  Total stem NX content.
         MNst = MNSst + MNXsttot    !kg total N (NS + NX) stem-1. 

      !C and N concs (substrate stored in meristem only):
          denMXstm = MXstm !For debugging purposes only,
          Cst = MCSst / MXstm;    Nst = MNSst / MXstm

   !Combined water-temperature function for the stem.
      fTWst = fTsh * fWst

   !Growth rates
      !Growth of stem meristem structure: 
         !Potential stem meristem size, MXstmpot (kg structural DM stem-1): 
                CNst = Cst * Nst       
                Constant cpotstm = 1000 !kg XDM (m2 stem surface [C] [N])-1. 
             MXstmpot = cpotstm * Ast * CNst

         !Intrinsic specific growth rate of stem meristem, ISGRst, is: 
             kGstm = kGstm20 * fTWst
                Constant kGstm20 = 200 !([CS] [NS] day)-1.
                                       !Growth rate constant.
             ISGRst = kGstm * CNst                  !day-1.   

         !Growth rate of stem meristem (IXstm):
            !Total meristem production:
                PXDMstm = ISGRst * MXstm       !kg meristem XDM stem-1 day-1.
                PXDMstm_gnd = nstems * PXDMstm !kg meristem XDM m-2 day-1.
                   rstmpot_stm = MXstmpot / MXstm !Ratio of potential:actual.
                   zstm = MIN( rstmpot_stm - 1.0, 0.999999 ) 
                      !zstm is a working variable whose range is restricted 
                      !to (-1,1).
             IXstm = PXDMstm * zstm  !kg meristem XDM stem-1 day-1. 
  
      !Growth activity of stem meristem (kg XDM stem-1 day-1):
          IXst =  PXDMstm * ( one - zstm ) 
          GXst = IXst   

      !Growth of stem height and stem radius.
         !Ratio of stem height (hstem) to stem diameter (dstem) is
            rhdstem = hstem / dstem    !Dimensionless.

         Constant allovr = 1  !Gives variable allometry. Plantation mode.
            !Set allovr = 0 for a constant height:stem ratio = rhdstem0.
            !In natural forest mode, height:stem ratio = constant 
            ! = rhdstem0 = 60.

         !First calculate the ratio of intrinsic specific growth rate (ISGR)
         !of foliage meristem (le) / the ISGR of the stem (st).
         !This ratio lies in the range 0.6 to 1.4
         !except for a t = 0 transient):
            ISGRle = ISGRbud     !day-1. Not too sure
                       !about this. We added the bud/leaf stuff after the 
                       !variable allometry which might not work too well now.
            IF ( ISGRst .NE. zero ) THEN
               rISGRle_st = ISGRle / ISGRst
            ELSE
               rISGRle_st = one
            ENDIF

         !Possibly amplify this ratio (e.g. with qhd > 1)
            rISGRle_stq = rISGRle_st ** qhd
            Constant qhd = 1.0       !Allometric factor.

         !Ratio of pressure potential in foliage to that in the fine roots:
            rpsiPle_fi = psiPle / psiPfi  !Not yet used.

         !Raise foliage pressure potential to power q:
            psiPleq = psiPle ** qpsiPle
            Constant qpsiPle = 4

         !Calculation of dstem and hstem from allometry, when allovr = 0:
            dstem_allometry = ( four * Vstem / ( pi * rhdstem0 )) ** third
            !This is based on: Vstem = (pi d*d/4) * (rhdstem0 * d) =
            !(area of stem assumed to be a uniform cylinder)*(height of stem).

            hstem_allometry =  rhdstem0 * dstem_allometry

         !Calculate ratio (r) of the rates of growth (D = d/dt) of
            !hstem to dstem, rDhDdstem:
               IF ( allovr .EQ. zero .OR. s_selfthin .EQ. one ) THEN  
                  rDhDdstem = rhdstem0 
                  !Constant = 60. Dimensionless height:diameter ratio.
                  !Constant allometry may be chosen by setting allovr = 0,
                  !or in natural forest mode, the allometry is constant,
                  !because this mode won't handle variable allometry.
               ELSE !
                  !Effect of growth rates:
                     rDhDdstemG = ( rhdmin + rhdmax * rISGRle_stq ) &
                                        / ( one + rISGRle_stq )
                        Constant rhdmax =  120    !Maximum value of Dh/Dd.
                        Constant rhdmin =    0    !Minimum value of Dh/Dd.
                        !rISGRle_stq = 1, rDhDdstem = 0.5 * ( hdmin + hdmax ).
                  !Effect of foliage pressure potential, psiPle:
                     rDhDdstemW = psiPleq / ( KpsiPleq + psiPleq )
                        Constant KpsiPle = 800 !J (kg water)-1.
                  rDhDdstem = rDhDdstemG * rDhDdstemW
               ENDIF

         !Ratio (r) of fractional growth rates (FGR) of hstem to dstem:
                  rFGRhdstem = rDhDdstem / rhdstem
   
         !Tree stem mass (and volume) specific growth rate: 
           sgrMXst = DMXst / MXst
           sgrMXst_chk = sgrhstem + sgrdstem + sgrdstem  !equals sgrMXst.
                 !Ok with self-thinning.
           sgrMXst0sn = DMXst0sn / MXst !Without self-thinning.

         !Diameter growth rate, Ddstem (m day-1):
               !Working variable:
                  zrFGRhdstem = one / ( two + rFGRhdstem )  
               SGRdstem = treevr * sgrMXst * zrFGRhdstem 
            Ddstem = dstem * SGRdstem
   
         !Height growth rate, Dhstem (m day-1):
            SGRhstem = rFGRhdstem * SGRdstem
            Dhstem = hstem * SGRhstem 

!   PROCEDURAL
!    ilogd = i8
!     IF ( calllogd ) CALL LOGD( .true. ) !7
!   END

         !Maximum canopy area allowed by stem height hstem, Acanmax_hstem:
            dcanmax_hstem = rcandiam_ht * hstem !m. Maximum diameter of
               !canopy allowed by the height.
               Constant rcandiam_ht = 0.33333 !Dimensionless. Ratio of canopy
                  !diameter to height. 
                  !Maximum canopy diameter is one third of stem height.
            Acanmax_hstem = dcanmax_hstem * dcanmax_hstem !m2.
               !Here we have just squared dcanmax_hstem.

         !Transmission of a black canopy to downward radiation, Tblack:
            !(following Section 9.2.3, p. 284 of Thornley & France, 2007)
            !Fraction of radiation intercepted by a black canopy
            !of zero height:
               fint_ht0z = Acanmax_hstem / Acanmax_nstems !Dimensionless.
               fint_ht0 = MIN( fint_ht0z , one )          !Dimensionless.
            !Define a dimensionless function, ufint_ht:
               gap_canopy = MAX( zero, dcanmax_nstems - dcanmax_hstem ) !m.
               ufint_ht = hstem / ( hstem + cufint_ht * gap_canopy )
                                   Constant cufint_ht = 1    !Dimensionless.
               fint_ht = fint_ht0 + ( one - fint_ht0 ) * ufint_ht
                                                            !Dimensionless.
               Tblack_chk = ( one - fint_ht0 ) * ( one - ufint_ht )  !OK.
            !We are getting some odd results with a variable Tblack, so 
            !lets give ourselves the option of fixing it.  e.g. a bit like
            !in grassland.
            Tblackz = one - fint_ht
               IF ( s_Tblackc .EQ. one ) THEN !Switch for black canopy
                                              !transmission = constant.
                    Tblack = Tblackc !Tblack has a constant value, Tblackc.
               ELSE
                    Tblack = Tblackz
               ENDIF
               Constant Tblackc = 0.3, s_Tblackc = 0 !Default value. So that 
                  !Tblack varies if s_Tblackc = 0.  
            one_Tblack = one - Tblack     

            
   
      !Fluxes of C utilized for growth of m and X (kg C stem-1 day-1): 
         IC_Xsttot = fCstm * IXstm + fCstX * IXst  !kg C input into st X.
         OCSst_G = IC_Xsttot / YGst   !kg sC required to sustain this flux.
         Constant fCstX = 0.4, fCstm = 0.4               !kg C (kg XDM)-1. 
         Constant YGst = 0.8    !kg C in XDM (kg substrate C utilized)-1.
         IC_Xsttot_gnd = nstems * IC_Xsttot !kg C into Xst m-2 d-1.

      !Fluxes of N utilized for growth of m and X (kg N stem-1 day-1): 
         ONSst_G = fNstm * IXstm + fNstX * IXst
         Constant fNstm = 0.025, fNstX = 0.001  !kg N (kg XDM)-1. 
         !N content of stem meristem structural DM, stem structural DM.

   !Stem geometry
      !Circumferences of stem:
         circstem = pi * dstem                            !m.      
      !Surface area of stem:
         Ast = circstem * hstem                           !m2.
      !Cross-sectional area of stem:
         CSAstem = quarter * circstem * dstem
      !Stem volume:
         Vstem = MXst / rostem                            !m3.
         Vstem_chk = CSAstem * hstem                  !should = Vstem.
          !Small discrepancy in the 7th digit.
      !Stem meristem cross-sectional area:
         CSAstm = ( MXstm / rostem ) / hstem             !m2.
      !Thickness of meristematic layer is:
         hstm = CSAstm / circstem                        !m. Not used.

   !C substrate flux from branches to stem (kg C stem-1 day-1), 
      !ICSbr_CSst = OCSbr_CSst, is calculated in the branches section above.
   
   !C substrate flux from stem (st) to coarse roots (co)
      !OCSst_CSco (kg C stem-1 day-1).
         !Resistances, rCst, rCco, are associated separately with 
            !stem (st), coarse roots (co):
                                     MXstqC = MXstm ** qroC 
                    rCst20 = roC20 / MXstqC 
             rCst = rCst20 / fTWst 
                    !Constants roC20 and qroC are given above.
            !rCco is calculated in the coarse roots section below.
         !Substrate C transport resistance between stem (st) and
            !coarse roots (co):
               rCstco = rCst + rCco  !stem day (kg XDM)-1.
      OCSst_CSco = ( Cst - Cco ) / rCstco 
      ICSst_CSco = OCSst_CSco  !input to the CSco pool.

   !N substrate flux from coarse roots (co) to stem (st), ONSco_NSst  
      !(kg N stem-1 day-1), calculated in coarse roots section below.
   
   !N substrate flux from stem (st) to branches (br)
      !ONSst_br (kg N stem-1 day-1):
         !Resistances, rNst, rNbr, are associated separately with
            !stem (st) and with branches (br):
                                    MXstqN = MXstm ** qroN 
                   rNst20 = roN20 / MXstqN 
            rNst = rNst20 / fTWst  !(fTWst = fTsh * fWst).
                   !Constants roN20 and qroN are given above.
            !rNbr is calculated in the branches section above.

         !Transport resistance between stem (st) and branches (br):
            rNstbr = rNst + rNbr  !stem day (kg XDM)-1.
      ONSst_br = ( Nst - Nbr ) / rNstbr 
      INSst_NSbr = ONSst_br   !input to N substrate branches pool.
   
   !Respiration fluxes
      !C substrate-dependent maintenance respiration, 
      !OCSst_mai (kg C stem-1 day-1). 
         !This is assumed proportional to total N content.
                    MNst_maiXme = MNXstm
                    IF ( MNXst .GT. zero ) THEN
                       MNst_maiX = s_NX_mai * MNXst * &
                                      ( MNXst / MNXst0z ) ** qNX_mai_1
                    ELSE
                       MNst_maiX = zero
                    ENDIF
                    MNst_maiS = s_NS_mai * MNSst  !kg st N stem-1.
                   !Components of N mass which contribute to maintenance.
         MNst_mai = MNst_maiXme + MNst_maiX + MNst_maiS     !kg N stem-1. 
                         !Component of st N causing maintenance respiration.


            kmai_st = kmai20 * fTWst               !fTWst = fTsh * fWst
            fCSmai_st = Cst / ( Cst + KCmai )
               !Constant kmai20 = 0.86 !kg C substrate (kg total N)-1 day-1.
               !Constant KCmai = 0.01 ![C]. !See above for explanation of
               !constants.
         OCSst_mai = fCSmai_st * kmai_st * MNst_mai

      !Structural DM flux to maintenance.
         !Stem structural DM loss, OXst_mai (kg stem XDM stem-1 day-1):
            OXst_mai = kXst_mai * MXst
                       kXst_mai = kXst_mai20 * fTWst
                       Constant kXst_mai20 = 0.0     !day-1. 
         !OCXst_mai, ONXst_mai (kg XC, XN stem-1 day-1):
               !Structural C and N fluxes to maintenance. C flux goes to
               !environment as CO2.  N flux is returned to NS pool.
               !The structural C:N ratio is unchanged.
            OCXst_mai = fCstX * OXst_mai   !kg XC stem-1 day-1.
            ONXst_mai = fNstX * OXst_mai   !kg XN stem-1 day-1.
         !The C flux is respired:
               RmaiXst = OCXst_mai         !kg C respired stem-1 day-1.
         !The N flux is returned to the N substrate pool:
            INmaiX_NSst = ONXst_mai         !kg NS stem-1 day-1.

      !Growth respiration, RGst (kg C stem-1 day-1)
         RGst = OCSst_G * ( one - YGst )   

      !Total stem respiration, Rst:
         Rst_mai = OCSst_mai + RmaiXst !kg C stem-1 day-1. Total maintenance.
         Rst = Rst_mai + RGst       !kg C stem-1 day-1. Maintenance + growth.
         Rst_gnd = nstems * Rst                              !kg C m-2 day-1.
      

   !C substrate, MCstorest.  State variable. kg stem-1. C substrate associated
                                                            !with the stem.
      !Concentration of C substrate store in the stem:
         Cstorest = MCstorest / MXstm

      !Conversion of stem C substrate to storage.
         Constant kmaxCSst_store20 = 0.02 !day-1. Fraction of C substrate
            !used to synthesize storage per day. Maximum value at 20 oC.
            kmaxCSst_store = fTWst * kmaxCSst_store20    !day-1.
            CstqCSst_store = Cst ** qCSst_store 
            fCSst_store = CstqCSst_store &
                          / ( CstqCSst_store + KstqCSst_store )
                                                           !Dimensionless.
                    !KstqCSst_store = KCSst_store ** qCSst_store 

            Constant KCSst_store = 0.01 !CS concentration in stem.
            Constant qCSst_store = 3    !Dimensionless.
         OCSst_storez = kCSst_store * fCSst_store * MCSst 
                                                  !kg stem CS stem-1 day-1.
         OCSst_store = s_Cstore * OCSst_storez    !kg stem CS stem-1 day-1.
               Constant s_Cstore = 1 !Carbon store is switched on.

      !Conversion of storage to stem C substrate.
         Constant kstore_CSst20 = 0.02 !day-1. Fraction of storage degraded to
            !C substrate per day. Maximum value at 20 oC.
            kstore_CSst = fTWst * kstore_CSst20          !day-1.
            fstore_CSst = Cstorest &
                           / ( Cstorest + KCstorest )  !Dimensionless.
            Constant KCstorest = 0.005  !Cstore concentration in stem.
         OCstore_CSstz = kstore_CSst * ( one - fCSst_store ) * fstore_CSst &
                         * MCstorest             !kg C store stem-1 day-1.
         OCstore_CSst = s_Cstore * OCstore_CSstz !kg C store stem-1 day-1.
         ICstore_CSst = OCstore_CSst !Is input to SCst without loss.

   !Fluxes to litter
      !Stem structural DM loss, OXst_li (kg XDM stem-1 day-1):
            kXst_li = kXst_li20 * fTsh  !Should we / eg by fWle to allow
                                        !for water stress?
             Constant kXst_li20 = 0.0   !day-1
         OXst0_li = kXst_li * MXst !Initial litter flux from stem structure.
         OXst_sn_li = cDnstXst * FDRnstems * MXst  !Litter flux due to
                                                      !self-thinning.
             Constant cDnstXst = 2  !dimensionless.
                !This constant adjusts the average stem XDM (MXst)
                !to a possibly higher value (if > 1) which may apply
                !more realistically to the death of stems.
         OXst_li = OXst0_li + OXst_sn_li                        !Total flux.
                !Note that, with kXst_li20 (as above), 
                !then OXst_li = OXst_sn_li. And OXst_li maybe = - OXst_sn,
                !because  OXst_sn = FGRnstems_sn * MXst, if
                !FGRnstems_sn = FBRnstems - FDRnstems and FBR... = 0.
                

      !C, N fluxes to litter, OCXst_li, ONXst_li (kg C, N stem-1 day-1):
            !Structural C and N only. 
            !Senescing stem carries no C, N substrates.
            !For the stem, there is no recycling of structural C, N to the
            !C, N substrate pools (cf. br, co). 
         OCXst_li = fCstX * OXst_li   !kg XC stem-1 day-1.
         ONXst_li = fNstX * OXst_li   !kg XN stem-1 day-1.
   
   !Outputs to/from self-thinning/generation of new stems
      OXstm_sn =  FGRnstems_sn * MXstm 
      OXst_sn =   FGRnstems_sn * MXst
      OCSst_sn =  FGRnstems_sn * MCSst 
      OCstorest_sn =  FGRnstems_sn * MCstorest
      ONSst_sn =  FGRnstems_sn * MNSst 
         !See branches section for explanation.
         !See also the term OXst_sn_li calculated above.


   !Outputs to pruning
      !Stem pruning is applied at the rate:
         kst_prune = s_prune * kst_prunez  !day-1. Working variable.
           !Pruning rate constant.  kst_prunez is calculated near beginning
           !of Derivative Section from fpruneyr (fraction pruned
           !per year). Default value = 0.

      !Neither stem substrates (C, N, store) 
         !nor stem meristem are removed by pruning.
         !Only structural material is removed.
      !Stem structural compartment:
         OXst_prune = kst_prune * MXst                !kg XDM stem-1 day-1.
         OCXst_prune = fCstX * OXst_prune             !kg XC stem-1 day-1.
         ONXst_prune = fNstX * OXst_prune             !kg XN stem-1 day-1.

      !It is assumed that stem pruning does not change stem density, nstems.
      !Changes in stem density are achieved by thinning.

      !On a per ground area basis:
         OCXst_prune_gnd = nstems * OCXst_prune         !kg CX m-2 day-1.
         ONXst_prune_gnd = nstems * ONXst_prune         !kg NX m-2 day-1.

      !Fractions of these fluxes are diverted to products (prod), with
         Constant fst_prune_prod = 0.8 !Dimensionless fraction.

      !Fluxes to products and to surface litter are therefore
         OCXst_prune_prod = fst_prune_prod * OCXst_prune_gnd 
         ONXst_prune_prod = fst_prune_prod * ONXst_prune_gnd
         OCXst_prune_li = OCXst_prune_gnd - OCXst_prune_prod
         ONXst_prune_li = ONXst_prune_gnd - ONXst_prune_prod
                                            !kg structural C, N m-2 day-1.
      
   !Differential eqns
     !See above for "Dnstems = ..." and "nstems = INTEG(...)" statements.
 
                               !IXstm = PXDMstm * zstm  !Meristem production.
                                OXstm = OXstm_sn + OXstm_fire
      DMXstm = treevr * ( IXstm - OXstm )

                                 OXst = OXst_li + OXst_mai + OXst_sn &
                                                + OXst_prune + OXst_fire
      DMXst =  treevr * ( IXst - OXst )
                                 OXst0sn = OXst0_li + OXst_mai &
                                           + OXst_prune + OXst_fire
                                !Without self-thinning. Note there is a
                                !self-thinning component in OXst_li.
                                 DMXst0sn =  treevr * ( IXst - OXst0sn )

                          ICSst = ICSbr_CSst + ICstore_CSst 
                          OCSst = OCSst_CSco + OCSst_mai + OCSst_G &
                                  + OCSst_store &
                                  + OCSst_sn + OCSst_fire 
      DMCSst = treevr * ( ICSst - OCSst )

                          ICstorest = OCSst_store 
                          OCstorest = OCstore_CSst + OCstorest_sn &
                                                   + OCstorest_fire 
      DMCstorest = treevr * ( ICstorest - OCstorest ) 

                          INSst = INSco_NSst + INmaiX_NSst
                          ONSst = ONSst_br + ONSst_G + ONSst_sn + ONSst_fire
      DMNSst = treevr * ( INSst - ONSst )
   
   !Integration statements:
      MXst =  INTEG( DMXst,  MXst0 )
      MXstm = INTEG( DMXstm, MXstm0 )
      MCSst = INTEG( DMCSst, MCSst0 )
      MCstorest = INTEG( DMCstorest, MCstorest0 )
         !MCstorest is the carbon store associated with stem. 
         !The stem C substrate storage.  kg C store stem-1.
      MNSst = INTEG( DMNSst, MNSst0 )
      hstemvr = INTEG( Dhstem, hstem0 )
      dstemvr = INTEG( Ddstem, dstem0 )
      hstem = ( one - allovr ) * hstem_allometry + allovr * hstemvr
      dstem = ( one - allovr ) * dstem_allometry + allovr * dstemvr
   

   !Stem balance checks
      !Checks on stems C balance:
         DMCst = fCstX * DMXst + fCstm * DMXstm &
                               + DMCSst + DMCstorest       !kg C stem-1 day-1.
         DCst_gnd = Dnstems * MCst + nstems * DMCst        !kg C m-2 day-1.
         ICst = nstems * ICSbr_CSst                        !kg C m-2 day-1.
            OCst_li = nstems * OCXst_li                    !kg C m-2 day-1.
            OCst_prune_gnd = OCXst_prune_gnd               !kg C m-2 day-1.
         OCst = Rst_gnd + nstems * ICSst_CSco + OCst_li + OCXst_prune_gnd &
                        + OCst_th + OCst_fire_gnd          !kg C m-2 day-1.
         DCst_gnd_chk = ICst - OCst                !This should = DCst_gnd.
                 !Ok with self-thinning.
      !Checks on stems N balance:
         DMNst = fNstX * DMXst + fNstm * DMXstm &
                               + DMNSst                 !kg N stem-1 day-1.
         DNst_gnd = Dnstems * MNst + nstems * DMNst        !kg N m-2 day-1.
         INst = nstems * INSco_NSst                        !kg N m-2 day-1.
            ONst_li = nstems * ONXst_li                    !kg N m-2 day-1.
         ONst = nstems * INSst_NSbr + ONst_li + ONXst_prune_gnd &
                                    + ONst_th + ONst_fire_gnd
                                                            !kg N m-2 day-1.
         DNst_gnd_chk = INst - ONst   !This should = DNst_gnd.
                       !Ok with self-thinning.

!COARSE ROOTS (co) 
   !Variables
      !Total structural dry matter:
          MXcotot = MXco + MXcom                        !kg XDM stem-1.
      !Fraction of total XDM in meristem XDM:
         fXcom = MXcom / MXcotot                        !Dimensionless.
      !Total substrate dry matter:
          MSco = ( MCSco * rmmCS12 + MNSco * rmmNS14 )  !kg SDM stem-1.
                                            !See above for rmmCS12, rmmNS14.
      !kg structural C (CX) stem-1:
         MCXco = fCcoX * MXco; MCXcom = fCcom * MXcom   !kg XC stem-1.
         MCXcotot = MCXco + MCXcom                      !kg XC stem-1.
      !Total dry matter:    
         Mco = MXcotot + MSco                           !kg DM stem-1.
      !Total kg C stem-1:
         MCco = MCSco + MCXcotot                        !kg C stem-1.
      !Nitrogen:
         MNXco =  fNcoX * MXco      !kg NX stem-1. Heartwood.
         MNXcom = fNcom * MXcom     !kg NX stem-1. Meristem.
         MNXcotot = MNXco + MNXcom  !kg NX stem-1. Total NX for coarse roots.
         MNco = MNSco + MNXcotot    !kg N stem-1.  Total N (NS + NX).

      !C and N substrate concs (substrate stored in meristem only):
          Cco = MCSco / MXcom;    Nco = MNSco / MXcom

   !Growth rates 
      !Growth of meristem.
         !Potential coarse root meristem size, MXcompot:
            CNco = Cco * Nco        ![CS][NS].  Coarse roots nutrient status.
            Acom = Aco  !m2 stem-1.  Area which can support coarse root
                        !meristem.  See <Abrm = > for discussion.
            MXcompot = cpotcom * Acom * CNco                  !kg XDM stem-1.
              Constant cpotcom = 1000 
                                  !kg XDM (m2 coarse root surface [C] [N])-1.
         !Intrinsic specific growth rate of coarse root meristem, ISGRco, is 
            kGcom = kGcom20 * fTWfi
            Constant kGcom20 = 200 !([CS] [NS] day)-1. Growth rate constant.
            ISGRco = kGcom * CNco   !day-1.

         !Total meristem growth (production of XDM) activity:
            PXDMcom = ISGRco * MXcom          !kg meristem XDM stem-1 day-1.
            PXDMcom_gnd = nstems * PXDMcom    !kg meristem XDM m-2 day-1.

         !Growth rate of (input flux to) coarse root meristem (IXcom):
               rcompot_com = MXcompot / MXcom !Ratio of potential:actual.
               zcom = MIN( rcompot_com - 1.0, 0.999999) !zcom is a 
                  !working variable whose range is restricted to (-1,1).  
            IXcom = PXDMcom * zcom    !kg meristem XDM stem-1 day-1.

         !Growth rate of coarse root structure (kg XDM stem-1 day-1):
             IXco =  PXDMcom * ( one - zcom ) 
             GXco = IXco

      !Fluxes of C utilized for growth of M and X (kg C stem-1 day-1):
         IC_Xcotot = fCcom * IXcom + fCcoX * IXco !kg C input into co X.
         OCSco_G = IC_Xcotot / YGco !kg sC required to sustain this flux.
         Constant fCcoX = 0.4, fCcom = 0.4               !kg C (kg XDM)-1. 
         Constant YGco = 0.8    !kg C in XDM (kg substrate C utilized)-1.
         IC_Xcotot_gnd = nstems * IC_Xcotot !kg C into Xco m-2 d-1.

      !Fluxes of N utilized for growth of M and X (kg N stem-1 day-1):
         ONSco_G = fNcom * IXcom + fNcoX * IXco
         Constant fNcom = 0.025, fNcoX = 0.005   !kg N (kg XDM)-1.
         !N content of coarse root meristem structural DM, 
         !coarse root structural DM.

      !Coarse root surface area, Aco (m2 stem-1):
         !This is a function of coarse root total structural dm.  We assume
              MXcoz = MAX( MXco, c1E_10 )  !This is to prevent
             !catastrophic failure if MXco becomes .le. 0.0
          Aco = cAcoXc * MXcoz ** qAco
                Constant cAcoXc = 0.16, qAco = 0.6666666667
               !See discussion under Branch surface area in Branches.

      !Coarse root area index, CAI
         !CAI = nstems * Aco   !Not used.

   !C substrate flux from stem to coarse roots (kg C stem-1 day-1),
      !ICSst_CSco = OCSst_CSco is calculated in the stem section above.

   !C substrate flux from coarse roots (co) to fine roots and mycorrhiza (fi)
      !OCSco_CSfi (kg C stem-1 day-1).
         !Resistances, rCco, rCfi, are associated separately with coarse 
            !roots and fine roots and mycorrhiza:
                                     MXcoqC = MXcom ** qroC 
                    rCco20 = roC20 / MXcoqC 
             rCco = rCco20 / fTWfi 
                    !Constants roC20 and qroC are given above.
                    !roC20 = 0.1, qroC = 1 see above.
            !rCfi is calculated in the fine roots and mycorrhiza section below.
         !Substrate C transport resistance between coarse roots (co) 
            !and fine roots and mycorrhiza (fi):
            rCcofi = rCco + rCfi  !stem day (kg XDM)-1.
      OCSco_CSfi = ( Cco - Cfi ) / rCcofi 
      ICSco_CSfi = OCSco_CSfi  !input to the CSfi pool.

   !N substrate flux from fine roots and mycorrhiza (fi) to coarse roots (co), 
      !INSfi_NSco = ONSfi_NSco (kg N stem-1 day-1) is calculated in fi 
      !section below. 

   !N substrate flux from coarse roots to stem
      !ONSco_NSst (kg N stem-1 day-1)
         !Resistances, rNco, rNst, are associated separately with 
             !coarse roots (co) and stem (st):
                                     MXcoqN = MXcom ** qroN 
                    rNco20 = roN20 / MXcoqN  
             rNco = rNco20 / fTWfi  !(fTWfi = fTsoil * fWfi).
                    !Constants roN20 and qroN are given above.
             !rNst is calculated in the stem section above.
         !Transport resistance between coarse roots (co) and stem (st):
            rNcost = rNco + rNst  !stem day (kg XDM)-1.
      ONSco_NSst = ( Nco - Nst ) / rNcost  !output from coarse roots NS pool
                                           !to sten NS pool.
      INSco_NSst = ONSco_NSst              !input to stem N substrate pool.

   !Respiration fluxes
      !C substrate-dependent maintenance respiration, 
      !OCSco_mai (kg C stem-1 day-1). 
         !This is assumed proportional to total N content.
         !Components of N mass which contribute to maintenance:
                    MNco_maiXme = MNXcom
                    MNco_maiX = s_NX_mai * MNXco * &
                                      ( MNXco / MNXco0z ) ** qNX_mai_1
                    MNco_maiS = s_NS_mai * MNSco     !kg st N stem-1.
         MNco_mai = MNco_maiXme + MNco_maiX + MNco_maiS     !kg N stem-1.
                                !N component causing maintenance respiration.
            kmai_co = kmai20 * fTWfi                !fTWfi = fTsoil * fWfi
            fCSmai_co = Cco / ( Cco + KCmai )
               !Constant kmai20 = 0.1 !kg C substrate (kg total N)-1 day-1.
               !Constant KCmai = 0.05 ![C]. !See above for explanation of
               !constants.
         OCSco_mai = fCSmai_co * kmai_co * MNco_mai

      !Structural DM flux to maintenance.
         !Coarse roots (cr) structural DM loss, 
         !OXco_mai (kg cr XDM stem-1 day-1):
            OXco_mai = kXco_mai * MXco
                       kXco_mai = kXco_mai20 * fTWfi
                       Constant kXco_mai20 = 0.0      !day-1. 
         !OCXco_mai, ONXco_mai (kg XC, XN stem-1 day-1):
               !Structural C and N fluxes to maintenance. C flux goes to
               !environment as CO2.  N flux is returned to NS pool.
               !The structural C:N ratio is unchanged.
            OCXco_mai = fCcoX * OXco_mai   !kg XC stem-1 day-1.
            ONXco_mai = fNcoX * OXco_mai   !kg XN stem-1 day-1.
         !The C flux is respired:
               RmaiXco = OCXco_mai         !kg C respired stem-1 day-1.
         !The N flux is returned to the N substrate pool:
            INmaiX_NSco = ONXco_mai         !kg NS stem-1 day-1.

      !Growth respiration, RGco (kg C stem-1 day-1)
         RGco = OCSco_G * ( one - YGco ) 

      !Total coarse root respiration, Rco:
         Rco_mai = OCSco_mai + RmaiXco !kg C stem-1 day-1. Total maintenance.
         Rco = Rco_mai + RGco       !kg C stem-1 day-1. Maintenance + growth.
         Rco_gnd = nstems * Rco                              !kg C m-2 day-1.


   !Fluxes to litter
      !Coarse root structural DM loss, OXco_li (kg XDM stem-1 day-1):
           KXco_li = KXco_li20 * fTrt / fWfi
           Constant kXco_li20 = 0.001                           !day-1.
             !Half-life of coarse roots at 10 deg C = 0.69 / (0.35 * k) 
             ! = 2000 day.
         OXco0_li = kXco_li * MXco  !Initial litter flux from co rt structure.
         OXco_sn_li = FDRnstems * MXco  !Litter flux due to self-thinning.
         OXco_li = OXco0_li + OXco_sn_li   !Total of these two.

      !C, N fluxes to litter, OCXco_li, ONXco_li (kg XC, XN stem-1 day-1):
            !Structural C and N only. 
            !Senescing coarse roots carry no C, N substrates.
         !Self-thinning flux of XC:
            OCXco_sn_li = fCcoX * OXco_sn_li      !kg XC stem-1 day-1.
         !Initial XC flux from normal coarse roots senescence:
            OCXco_li1 = fCcoX * OXco0_li          !kg XC stem-1 day-1.
            !Some of the structural C is recycled.  
            !OCXco_li1 is the C flux without recycling.
               ICXli_rec_CSco = fCXco_rec * OCXco_li1   !kg C stem-1 day-1. 
                  !This is the recycled C flux, where
                  fCXco_rec = fCXco_rec_max / ( Cco / KCXli_rec + one ) 
                  !fCXco_rec is the fraction of coarse roots structural C flux
                  !to litter recycled to the coarse roots substrate C pool.
               Constant fCXco_rec_max = 0.5 !Dimensionless.
              !Constant KCXli_rec = 0.02 kg C substrate (kg XDM)-1. See above.
                  !Michaelis-Menten constant.
                  !fCXco_rec_max is maximum value of fCXco_rec if Cco = 0.
         OCXco0_li = OCXco_li1 - ICXli_rec_CSco  !is the XC flux to litter.
         OCXco_li = OCXco0_li + OCXco_sn_li

         !Self-thinning flux of XN:
            ONXco_sn_li = fNcoX * OXco_sn_li      !kg XN stem-1 day-1.
         !Initial structural N flux towards litter is:
            ONXco_li1 = fNcoX * OXco0_li
         !fNXco_rec is the fraction of co structural N flux towards
         !litter recycled to the co substrate N pool, with: 
            fNXco_rec = KNXli_rec / ( Nco + KNXli_rec )
                    !Constant KNXli_rec = 0.01  ![N]. 
                    !Michaelis-Menten constant. See above.
         !The recycled N flux input to the co N substrate pool is:
            INXli_rec_NSco = fNXco_rec * ONXco_li1  !kg N stem-1 day-1.  
         !Finally, the XN flux to litter is given by difference, with:
         ONXco0_li = ONXco_li1 - INXli_rec_NSco
         ONXco_li = ONXco0_li + ONXco_sn_li

   
   !Outputs to/from self-thinning/generation of new stems
      OXcom_sn =  FGRnstems_sn * MXcom 
      OXco_sn =   FGRnstems_sn * MXco 
      OCSco_sn =  FGRnstems_sn * MCSco 
      ONSco_sn =  FGRnstems_sn * MNSco 
         !See branches section for explanation.
         !See also the self-thinning term OCXco_sn_li calculated above.

   !Outputs to pruning
      !Coarse root pruning is applied at a rate of kco_prune day-1.
         kco_prune = s_prune * kco_prunez !day-1. 
           !Pruning rate constant.  kco_prune is calculated near end of
           !Initial Section from fpruneyr. Default value = 0.

      !See foliage section above for more information about pruning.

      !Coarse root structure alone is removed by pruning.
         !No substrates (CS, NS) or meristem (com) are removed by pruning.
         !Coarse roor structural compartment:
            OXco_prune = kco_prune * MXco             !kg XDM stem-1 day-1.
            OCXco_prune = fCcoX * OXco_prune          !kg XC stem-1 day-1.
            ONXco_prune = fNcoX * OXco_prune          !kg XN stem-1 day-1.
         !Ground area basis:
            OCXco_prune_gnd = nstems * OCXco_prune    !kg CX m-2 day-1.
            ONXco_prune_gnd = nstems * ONXco_prune    !kg NX m-2 day-1.
         !Fluxes to soil litter are:
            OCXco_prune_li = OCXco_prune_gnd          !kg CX m-2 day-1.
            ONXco_prune_li = ONXco_prune_gnd          !kg NX m-2 day-1.

   !Differential eqns
                                  OXcom = OXcom_sn + OXcom_fire
      DMXcom = treevr * ( IXcom - OXcom ) 

                                 OXco = OXco_li + OXco_mai + OXco_sn &
                                                + OXco_prune + OXco_fire
      DMXco =  treevr * ( IXco - OXco )

                          ICSco = ICSst_CSco + ICXli_rec_CSco 
                          OCSco = OCSco_CSfi + OCSco_mai &
                                  + OCSco_G + OCSco_sn + OCSco_fire
      DMCSco = treevr * ( ICSco - OCSco )

                          INSco = INSfi_NSco + INmaiX_NSco + INXli_rec_NSco
                          ONSco = ONSco_NSst + ONSco_G + ONSco_sn &
                                             + ONSco_fire
      DMNSco = treevr * ( INSco - ONSco ) 

   !Integration statements
      MXco =  INTEG( DMXco,  MXco0 )
      MXcom = INTEG( DMXcom, MXcom0 )
      MCSco = INTEG( DMCSco, MCSco0 )
      MNSco = INTEG( DMNSco, MNSco0 )

   !Coarse roots balance checks
      !Checks on coarse roots C balance:
         DMCco = fCcoX * DMXco + fCcom * DMXcom &
                               + DMCSco                 !kg C stem-1 day-1.
         DCco_gnd = Dnstems * MCco + nstems * DMCco        !kg C m-2 day-1.
         ICco = nstems *  ICSst_CSco                       !kg C m-2 day-1.
         OCco = nstems * ( Rco + ICSco_CSfi + OCXco_li ) + OCco_th &
                + OCXco_prune_gnd + OCco_fire_gnd          !kg C m-2 day-1.
                         !No C substrate carried by senescing coarse roots.
         DCco_gnd_chk = ICco - OCco                !This should = DCco_gnd.
               !OK with self-thinning.

      !Checks on coarse roots N balance:
         DMNco = fNcoX * DMXco + fNcom * DMXcom &
                               + DMNSco                 !kg N stem-1 day-1.
         DNco_gnd = Dnstems * MNco + nstems * DMNco        !kg N m-2 day-1.
         INco = nstems * ( INSfi_NSco )                    !kg N m-2 day-1.
         ONco = nstems * ( INSco_NSst + ONXco_li ) + ONco_th &
                + ONXco_prune_gnd + ONco_fire_gnd           !kg N m-2 day-1.
                         !No N substrate carried by senescing coarse roots.
         DNco_gnd_chk = INco - ONco                !This should = DNco_gnd.
               !OK with self-thinning.


!FINE ROOTS and MYCORRHIZA (fi) 
   !Variables
      !Total structural dry matter:
          MXfi = MXfi1 + MXfi2 + MXfi3 + MXfi4 !total for all 4 age categories.
          MXfi_gnd = nstems * MXfi   !kg fine root XDM m-2.  A sort of
                                     !root area index. Per unit ground area.
                                     !Does not include meristem structure.
          MXfi_gndsq = MXfi_gnd * MXfi_gnd  !Squared.
          rLAI_MXfi_gnd = LAI / MXfi_gnd !m2 gnd (fiXDM)-1 m2 leaf (m2 gnd)-1.
          rLAI_Xfignd = rLAI_MXfi_gnd !For output only.
          MXfitot = MXfi + MXfim  !kg XDM in fine roots & mycorrhiza stem-1.
      !Fraction of XDM in fine roots & mycorrhiza in meristem XDM:
         fXfim = MXfim / MXfitot                      !Dimensionless.
      !Total fine roots and mycorrhiza substrate dry matter:
          MSfi = ( MCSfi * rmmCS12 + MNSfi * rmmNS14 )
                                     !See above for rmmCS12, rmmNS14.
      !Total fine roots and mycorrhiza dry matter:   
          Mfi = MXfitot + MSfi    !kg DM stem-1. 
      !kg structural C (CX) stem-1: 
          MCXfi = fCfiX * MXfi;  MCXfim = fCfim * MXfim
          MCXfitot = MCXfi + MCXfim 
      !Total kg C stem-1:
         MCfi = MCSfi + MCXfitot                               !kg C stem-1.
      !Nitrogen:
         MNXfi =  fNfiX * MXfi     !kg NX stem-1. Non-meristem structure.
         MNXfim = fNfim * MXfim    !kg NX stem-1. Meristem structure.
         MNXfitot = MNXfi + MNXfim !kg NX stem-1. Total fine root structural
                                   !N.
         MNfi = MNSfi + MNXfitot   !kg N stem-1.  Total N in fine roots
                                   !(structure + substrate).

      !C and N substrate concentrations:
          Cfi = MCSfi / MXfitot;    Nfi = MNSfi / MXfitot
               !MNSfi:  kg N substrate stem-1.
             !Here it is assumed that C and N substrates are distributed over
             !both M (meristematic) and X (non-meristematic) structural DM.
          NXfi = MNXfitot / MXfitot  !kg NX (kg XDM)-1

      !Structural N concn.
      !Ratio of fine roots C to N substrates:
           rCNfi = Cfi / Nfi  !kg C (kg N)-1.

   !N uptake by the fine roots and mycorrhiza, uN_stem (kg N stem-1 day-1)
      !Effective mineral N concentration for plant uptake (Neff_uN) is:
          Neff_uN = Namm + fTuNmin * Nnit  !kg N m-2.
      !Working variable, dimensionless denominator of uptake eqn:
         denzuN = one + ( KCuN / Cfi ) * ( one + ( Nfi / JNuN ) ** quN )
         Constant KCuN = 0.01, JNuN = 0.01, quN = 3
            !Root activity parameters:
               !Michaelis-Menten parameter, KCuN [CS].
               !Inhibition capacity, JNuN, [NS].
      ![NS] is units of N substrate concn in fine roots & mycorrhiza, ie:
      !kg N subsrate in fine roots & mcyorrhiza (kg XDM in same)-1
               !Steepness of inhibitory response, quN, dimensionless. 
      !Working variable, factor in uptake expression:
         zNeff_uN = one / ( one + KNeff_uN / Neff_uN )       !dimensionless.
         Constant KNeff_uN = 0.001   !kg N m-2.  Michaelis-Menten parameter.
      !Effect of temperature and water on fine root processes:
         fTWfi = fTsoil * fWfi                               !dimensionless.
      !Working variable, root activity parameter modified for temperature 
         !and water:
         kuN = kuN20 * fTWfi
            Constant kuN20 = 0.1          !kg N (kg root structure)-1 day-1.
               !Root specific activity parameter at 20 C, 
               !Note that in the equation below, both uN and MXfi are
               !per stem (rather per m2 as in the pasture model. 
               !This value is not the same as in the Hurley Pasture Model.
               !Should uN depend on soil relative water content?
       uN_stem = kuN * zNeff_uN * MXfi / denzuN        !(kg N stem-1 day-1).
       INmin_NSfi = uN_stem            !This is the input to the fi NS pool.

      !N uptake from soil ammonia (Namm) and nitrate (Nnit) pools are 
              !Working variables (dimensionless fractions):
                  zfNamm = Namm / Neff_uN
                  zfNnit = fTuNmin * Nnit / Neff_uN
          uNamm = uN_stem * zfNamm       !kg ammonium N stem-1 day-1.
          uNnit = uN_stem * zfNnit       !kg nitrate N stem-1 day-1.
                  uNmin = uNamm + uNnit  !kg mineral N stem-1 day-1.
   
      !Outputs from soil Namm and Nnit pools on a ground area basis:
         ONamm_rt = nstems * uNamm;  ONnit_rt = nstems * uNnit !kg N m-2 day-1.
      !Total mineral N uptake by root:
         ONsoil_fi = ONamm_rt + ONnit_rt                       !kg N m-2 day-1.
         uN_gnd = ONsoil_fi                                    !kg N m-2 day-1.
   
         uN_gndINsys = uN_gnd * INsys !These are used for evaluating
         uN_gndONsys = uN_gnd * ONsys !correlation coefficients.
         uN_gndPnet = uN_gnd * Pnet
   
      !Respiration in soil associated with plant uptake of N
                                                         !kg C stem-1 day-1:
         RNamm_upt = uN_stem * cNamm_upt * zfNamm    !from soil ammonia pool.
         RNnit_upt = uN_stem * cNnit_upt * zfNnit    !from soil nitrate pool.
                  Constant cNamm_upt = 0.17  !kg C substrate (kg N)-1.
                      !Respiratory cost of N uptake from soil ammonia, Namm.
                  Constant cNnit_upt = 0.34 !kg C substrate (kg N)-1.
                     !Respiratory cost of N uptake from soil nitrate, Nnit.
                     !Based on: NO3 requires 2H+ is equivalent to 2ATP.
                     !C6H12O6 + 6O2 = 6CO2 + 6H2O + 30ATP gives 1C equiv 5ATP.
                     !1 kg N(NO3) requires [ 2 mole ATP / mole N ] / 
                     ![ 5 mole ATP / mole C ] 
                     ![ 12 kg C substrate / mole C ] / [ 14 kg N / mole N ]
                     ! = 2/5 12/14 = 0.34.
                     !Bouma et al 1996.
                     !We assume uptake costs of NH3 are like those of K+, with 
                     ! 1H+ per NH3, giving half the NO3 cost.
                  !Total respiration associated with N uptake:
                     RNmin_upt = RNamm_upt + RNnit_upt     !kg C stem-1 year-1.
                     RNmin_upt_gnd = nstems * RNmin_upt    !kg C m-2 year-1.


   !Growth rates
      !Growth of meristem (IXfim):
         !Intrinsic specific growth rate of fine roots and mycorrhiza
            !meristem, ISGRfi (day-1):
            kGfim = kGfim20 * fTWfi     !fTWfi = fTsoil * fWfi.
            Constant kGfim20 = 200 !([CS] [NS] day)-1. Growth rate constant.
            CNfi = Cfi * Nfi  
            ISGRfi = kGfim * CNfi

         !Potential fine roots and mycorrhiza meristem size, MXfimpot,  
            !is assumed proportional to coarse root surface area,
            !Aco (m2 coarse root surface stem-1), and nutrient status CNfi:
             MXfimpot = cpotfim * Aco * CNfi
                 Constant cpotfim = 1000
                          !kg XDM (m2 coarse root surface [C] [N])-1.

         !Total meristem growth production of XDM) activity:
            PXDMfim = ISGRfi * MXfim         !kg meristem XDM stem-1 day-1.

            PXDMfim_gnd = nstems * PXDMfim       !kg meristem XDM m-2 day-1.

         !Growth rate of (input flux to) fine root meristem (IXfim):
            rfimpot_fim = MXfimpot / MXfim
            zfim = MIN( rfimpot_fim - one, 0.9999 )  !working variable.
            IXfim = PXDMfim * zfim          !(kg meristem XDM stem-1 day-1).

      !Growth rate of fine roots and mycorrhiza structure (IXfi1):
         IXfi1 =  PXDMfim * ( one - zfim )         !kg XDM stem-1 day-1.
                  IXfi = IXfi1 !For convenience, similar to IXbr etc.

      !Fluxes of C utilized for growth of M and X, (kg C stem-1 day-1):
         IC_Xfitot = fCfim * IXfim + fCfiX * IXfi1 !kg C input into fi X.
         OCSfi_G = IC_Xfitot / YGfi  !kg sC required to sustain this flux.
         Constant fCfiX = 0.4, fCfim = 0.4        !kg C (kg X dry matter)-1.
         Constant YGfi = 0.8      !kg C in XDM (kg substrate C utilized)-1.
         IC_Xfitot_gnd = nstems * IC_Xfitot !kg C into Xfi m-2 d-1.


      !Fluxes of N utilized for growth of M and X (kg N stem-1 day-1):
         ONSfi_G = fNfim * IXfim + fNfiX * IXfi1
         Constant fNfim = 0.025, fNfiX = 0.01   !kg N (kg X dm)-1
            !N contents of fi meristem structural DM, and structural DM.
   
   !C substrate flux from coarse roots (co) to fine roots and mycorrhiza (fi), 
      !OCSco_CSfi (kg C stem-1 day-1), is calculated above.

         !Resistance to C substrate transport associated with fine roots
         !and mycorrhiza, rCfi (stem day (kg XDM)-1): 
                                    MXfiqC = MXfitot ** qroC 
                   rCfi20 = roC20 / MXfiqC 
            rCfi = rCfi20 / fTWfi  !(fTWfi = fTsoil * fWfi).

   !N substrate flux from fine roots and mycorrhiza (fi) to coarse roots (co)
      !ONSfi_NSco (kg N stem-1 day-1):
         !Resistances, rNfi, rNco, are associated separately with
         !fine roots and mycorrhiza (fi), coarse roots (co):
                                    MXfiqN = MXfitot ** qroN 
                   rNfi20 = roN20 / MXfiqN 
            rNfi = rNfi20 / fTWfi  !(fTWfi = fTsh * fWfi).
           !rNco is calculated in the coarse roots (co) section above.
         !Substrate N transport resistance between fine roots and 
         !mycorrhiza (fi) and coarse roots (co):
            rNfico = rNfi + rNco  !stem day (kg XDM)-1.
      ONSfi_NSco = ( Nfi - Nco ) / rNfico 
      INSfi_NSco = ONSfi_NSco !Input into N substrate co pool.

   !Respiration fluxes 
      !1. C substrate-dependent maintenance respiration, 
      !OCSfi_mai (kg C stem-1 day-1). 
         !This is assumed proportional to total N content.
         !Components of fi N mass which contribute to maintenance:
                    MNfi_maiXme = MNXfim ;
                    MNfi_maiX = s_NX_mai * MNXfi * &
                                      ( MNXfi / MNXfi0z ) ** qNX_mai_1
                    MNfi_maiS = s_NS_mai * MNSfi          !kg fi N stem-1.
         MNfi_mai = MNfi_maiXme + MNfi_maiX + MNfi_maiS   !kg fi N stem-1.
                   !Component of fine root N causing maintenance respiration.

            kmai_fi = kmai20 * fTWfi              !fTWfi = fTsoil * fWfi
            fCSmai_fi = Cfi / ( Cfi + KCmai )
               !Constant kmai20 = 0.86 !kg C substrate (kg total N)-1 day-1.
               !Constant KCmai = 0.01 ![C]. !See above for explanation of
               !constants.
         OCSfi_mai = fCSmai_fi * kmai_fi * MNfi_mai

      !2. Structural DM flux to maintenance.
         !Fine roots and mycorrhiza (fr) structural DM loss, 
         !OXfi_mai (kg fi XDM stem-1 day-1):
            OXfi1_mai = kXfi_mai * MXfi1;    OXfi2_mai = kXfi_mai * MXfi2
            OXfi3_mai = kXfi_mai * MXfi3;    OXfi4_mai = kXfi_mai * MXfi4
            OXfi_mai = OXfi1_mai + OXfi2_mai + OXfi3_mai + OXfi4_mai 
                       kXfi_mai = kXfi_mai20 * fTWfi
                       Constant kXfi_mai20 = 0.0     !day-1. 
         !OCXfi_mai, ONXfi_mai (kg XC, XN stem-1 day-1):
               !Structural C and N fluxes to maintenance. C flux goes to
               !environment as CO2.  N flux is returned to NS pool.
               !The structural C:N ratio is unchanged.
            OCXfi_mai = fCfiX * OXfi_mai   !kg XC stem-1 day-1.
            ONXfi_mai = fNfiX * OXfi_mai   !kg XN stem-1 day-1.
         !The C flux is respired:
               RmaiXfi = OCXfi_mai         !kg C respired stem-1 day-1.
         !The N flux is returned to the N substrate pool:
            INmaiX_NSfi = ONXfi_mai         !kg NS stem-1 day-1.

      !3. Growth respiration, RGfi (kg C stem-1 day-1):
         RGfi =  OCSfi_G * ( one - YGfi )

      !4. RNnit_red_fi (OCSfi_Nnit_red_fi), respiration of root C substrate
         !associated with nitrate reduction in the root
         !(kg C respired stem-1 day-1). 
         RNnit_red_fi = cnit_red * &
                        ( one - s_leaf * ( one - fuNnit_red_rt ) ) &
                        * uNnit  
         OCSfi_Nnit_red = RNnit_red_fi        !Put into standard notation.

      !5. Rmin_upt (OCSfi_min_upt), respiration of root C substrate associated
         !with mineral (exc. N) uptake 
         !(kg root C substrate respired stem-1 day-1).
         !A problem emerged with this when applying the EFM to beech.
         !This flux drove MCSfi negative.  The fix applied below is to
         !make the respiration required dependent on CSfi concentration.
         !Mineral flux into the plant is:
            umin_tree = fmin_treeX * ( PXDMtree - fminli_re * OXtree_li ) 
                                                  !kg mineral stem-1 day-1.
            !The need of new growth (PXDMtree, kg XDM stem-1 day-1) for 
            !minerals is decreased because
            !a fraction of the minerals (fminli_re) in the plant litter
            !flux (OXtree_li, structural DM) is recycled (retained in plant).
            Constant fminli_re = 0.5 !Dimensionless. 
               !Fraction of minerals (exc. N) in
               !litter which is recycled (therefore does not have to be
               !taken for growth.
            Constant fmin_treeX = 0.05  !kg minerals (exc. N) (kg structure)-1.
               !Fractional mineral (exc. N) content of plant (tree)
               !structural dry matter.
            fCSfi = Cfi / ( Cfi + KCSfi_umin ) !30 Nov 2004.
                  Constant KCSfi_umin = 0.01 !Carbon substrate concentration.
         Rmin_upt1 = fCSfi * cmin_upt * umin_tree  !This can be + or -.
            Constant cmin_upt = 0.06  !kg C substrate (kg ash).
                    !Respiratory cost of 
                    !minerals (excluding N) uptake from the soil. Value is
                    !based on a modified eqn (12.21g, page 349,
                    !Thornley & Johnson, 1990.  1 glucose gives 30 ATP.
                    !Therefore 1 kg minerals requires 1/40 x 6/30 x 12 =
                    !0.06 kg substrate C. 

         Rmin_upt = half * ( Rmin_upt1 + ABS( Rmin_upt1 ) )
            !This ensures that Rmin_upt is zero or greater than zero.
            !If umin and Rminupt1 are < 0, then Rmin_upt = 0.
         OCSfi_min_upt = Rmin_upt               !Put into standard notation.
         Rmin_upt_gnd = nstems * Rmin_upt              !kg C m-2 year-1.

      !Total fine roots and mycorrhiza respiration, Rfi:
         Rfi_mai = OCSfi_mai + RmaiXfi        !kg C stem-1 day-1.
                   !Total maintenance.
         Rfi = Rfi_mai + RGfi + RNnit_red_fi + RNmin_upt + Rmin_upt
                                                          !kg C stem-1 day-1. 
               !Total fi respiration: maintenance, growth, nitrate reduction,
               !N uptake.
         Rfi_gnd = nstems * Rfi               !kg C m-2 day-1.
               !Ditto, per unit ground area.

   !Exudation fluxes
      !OCSfi_ex, loss of C substrate to soil Csol pool by
         !root exudation (kg substrate C stem-1 day-1):
            OCSfi_ex = kCSfi_ex20 * fTWfi * MXfi * Cfi 
              Constant kCSfi_ex20 = 0.02 !day-1.  Root exudation of root C
                                         !substrate.  2% per day.
            ICfi_Csol = nstems * OCSfi_ex !(kg substrate C m-2 day-1).
                                          !Input to Csol pool.  
   
      !ONSfi_ex, loss of N substrate to soil Namm pool by root exudation.
          ONSfi_ex = kNSfi_ex20 * fTWfi * MXfi * Nfi !kg NS stem-1 day-1.
            Constant kNSfi_ex20 = 0.005 !day-1. Root exudation of root N
                                        !substrate.  0.5% per day.
          INfi_Namm = nstems * ONSfi_ex     !kg SN m-2 day-1.  
                                            !Input to Namm pool.


   !Age transfer fluxes and fluxes to litter
      !Rate constant:
                   kXfi_li = ( s_leaf + ( one - s_leaf ) * s_kXfi_li ) &
                             * kXfi_li20 * fTrt / fWfi
                    Constant s_kXfi_li = 1 !Switch: when 0, fine root
                       !turnover is switched off when there are no leaves,
                       !that is, when s_leaf = 0.
                    Constant kXfi_li20 = 0.01                       !day-1.
                    !Halflife at 10 deg C = 0.69 / (k * 0.35) = 200 days,
                    !for each of the four compartments.

      !Transfers between age categories:
         OXfi1_2 =  kXfi_li * MXfi1;    OXfi2_3 =  kXfi_li * MXfi2
         OXfi3_4 =  kXfi_li * MXfi3                     !kg XDM stem-1 day-1.

      !Structural DM flux towards litter:
         OXfi4_li = kXfi_li * MXfi4                     !kg XDM stem-1 day-1.
                !Note no self-thinning term. Cf OXbr_li, OXst_li, OXco_li.
                !See Black et al (1998) Differences in root lengevity of 
                !some tree species. Tree Physiol 18, 259-264. Sitka spruce,
                !k = 0.06/14 day-1 = 0.0043 day-1 at 10 C (10 C assumed by
                !me, for unheated glass near Edinburgh).

      !C, N fluxes to litter: OCXfi_li, ONXfi_li (kg XC, XN stem-1 day-1).
            !Some of the structural C is recycled.
             OCXfi_li1 = fCfiX * OXfi4_li   !kg XC stem-1 day-1.
            !OCXfi_li1 is the C flux without recycling.
               ICXli_rec_CSfi = fCXfi_rec * OCXfi_li1   !kg C stem-1 day-1. 
                  !This is the recycled C flux, where
                  fCXfi_rec = fCXfi_rec_max / ( Cfi / KCXli_rec + one ) 
                  !fCXfi_rec is the fraction of fine roots structural C flux
                  !to litter recycled to the fine roots substrate C pool.
               Constant fCXfi_rec_max = 0.5 !Dimensionless.
              !Constant KCXli_rec = 0.02 kg C substrate (kg XDM)-1. See above.
                  !Michaelis-Menten constant.
                  !fCXfi_rec_max is maximum value of fCXfi_rec if Cfi = 0.
         OCXfi_li = OCXfi_li1 - ICXli_rec_CSfi  !is the XC flux to litter.

            !Initial structural N flux towards litter is:
               ONXfi_li1 = fNfiX * OXfi4_li
            !fNXfi_rec is the fraction of fine roots structural N flux to
            !litter recycled to the fine roots substrate N pool.
                fNXfi_rec = KNXli_rec / ( Nfi + KNXli_rec )
                   !Constant KNXli_rec = 0.01  ![N]. 
                   !Michaelis-Menten constant. See above.
            !The recycled N flux is:
                INXli_rec_NSfi = fNXfi_rec * ONXfi_li1  !kg N stem-1 day-1.
            !By difference, the structural N flux to litter is:
         ONXfi_li = ONXfi_li1 - INXli_rec_NSfi          !kg N stem-1 day-1.

      !OCSfi_li, ONSfi_li (kg substrate C, N m-2 day-1). 
         !Substrate C and N fluxes to soil litter.
                  fCSfili = ( fCSli_min * KCSli + Cfi ) / &
                             ( KCSli + Cfi )
                             !This is the fraction of C substrate in the
                             !structural litter flux which is lost to litter.
                     !Constant fCSli_min = 0.3   !Dimensionless.  
                        !The minimum fraction of
                        !C substrate lost in the senescing litter fluxes.
                     !Constant KCSli = 0.05  ![C]. 
                        !Michaelis-Menten constant for C substrate
                        !loss in senescing litter fluxes.
          OCSfi_li = fCSfili * Cfi * OXfi4_li

                  fNSfili = ( fNSli_min * KNSli + Nfi ) / &
                             ( KNSli + Nfi )
                             !This is the fraction of N substrate in the
                             !structural litter flux which is lost to litter.
                     !Constant fNSli_min = 0.3   !Dimensionless.  
                        !The minimum fraction of
                        !N substrate lost in the senescing litter fluxes.
                     !Constant KNSli = 0.01   ![N]. 
                        !Michaelis-Menten constant for N substrate
                        !loss in senescing litter fluxes.
          ONSfi_li = fNSfili * Nfi * OXfi4_li

 
   !Outputs to/from self-thinning/generation of new stems
      OXfim_sn =  FGRnstems_sn * MXfim 
      OXfi1_sn =  FGRnstems_sn * MXfi1;   OXfi2_sn =   FGRnstems_sn * MXfi2 
      OXfi3_sn =  FGRnstems_sn * MXfi3;   OXfi4_sn =   FGRnstems_sn * MXfi4 
      OCSfi_sn =  FGRnstems_sn * MCSfi 
      ONSfi_sn =  FGRnstems_sn * MNSfi 
         !See branches section for explanation.
         !Note there is no direct self-thinning flux (cf. OCXco_sn_li above).
 

   !Outputs to pruning
      !If it is applied, then pruning is applied at a constant rate
      !throughout the year.
         !Set s_prune = 1 to activate pruning.
         kfi_prune = s_prune * kfi_prunez  !day-1. 
           !Pruning rate constant.  kfi_prune is calculated near end of
           !Initial Section from fpruneyr. Default value = 0.
      !All fine root state variables are decreased at the same rate.
      !Fine root meristem:
         OXfim_prune = kfi_prune * MXfim              !kg XDM stem-1 day-1.
         OCXfim_prune = fCfim * OXfim_prune           !kg XC stem-1 day-1.
         ONXfim_prune = fNfim * OXfim_prune           !kg XN stem-1 day-1.
      !Fine root structural compartments:
         OXfi1_prune = kfi_prune * MXfi1              !kg XDM stem-1 day-1.
         OXfi2_prune = kfi_prune * MXfi2              !kg XDM stem-1 day-1.
         OXfi3_prune = kfi_prune * MXfi3              !kg XDM stem-1 day-1.
         OXfi4_prune = kfi_prune * MXfi4              !kg XDM stem-1 day-1.
         OXfi_prune = OXfi1_prune + OXfi2_prune + OXfi3_prune + OXfi4_prune
         OCXfi_prune = fCfiX * OXfi_prune             !kg XC stem-1 day-1.
         ONXfi_prune = fNfiX * OXfi_prune             !kg XN stem-1 day-1.
      !Fine root C and N substrates:
         OCSfi_prune = kfi_prune * MCSfi      !kg C substrate stem-1 day-1.
         ONSfi_prune = kfi_prune * MNSfi      !kg N substrate stem-1 day-1.
      !Water:
         OWfi_prune = kfi_prune * Wfi         !kg W stem-1 day-1.

      !On a ground area basis:
         OCXfi_prune_gnd = nstems * ( OCXfim_prune + OCXfi_prune )
                                                      !kg CX m-2 day-1.
         OCSfi_prune_gnd = nstems * OCSfi_prune       !kg CS m-2 day-1.
         OCfi_prune_gnd = OCXfi_prune_gnd + OCSfi_prune_gnd 
                                                      !kg C m-2 day-1.
         ONXfi_prune_gnd = nstems * ( ONXfim_prune + ONXfi_prune )
                                                      !kg NX m-2 day-1.
         ONSfi_prune_gnd = nstems * ONSfi_prune       !kg NS m-2 day-1.
         ONfi_prune_gnd = ONXfi_prune_gnd + ONSfi_prune_gnd 
                                                      !kg N m-2 day-1.
         OWfi_prune_gnd = nstems * OWfi_prune         !kg W m-2 day-1.
         IWfi_prune_Wsoil = OWfi_prune_gnd            !kg W m-2 day-1.

      !The 4 C and N fluxes (CX, NX, CS, NS) enter soil litter.
      !The water (W) flux enters the soil water pool (Wsoil).


   !Differential eqns
                                  OXfim = OXfim_sn + OXfim_prune + OXfim_fire
      DMXfim = treevr * ( IXfim - OXfim )

      DMXfi1 = treevr * ( IXfi1 - OXfi1_2 - OXfi1_mai - OXfi1_sn &
                                - OXfi1_prune - OXfi1_fire )
      DMXfi2 = treevr * ( OXfi1_2 - OXfi2_3 - OXfi2_mai - OXfi2_sn &
                                - OXfi2_prune - OXfi2_fire )
      DMXfi3 = treevr * ( OXfi2_3 - OXfi3_4 - OXfi3_mai - OXfi3_sn &
                                - OXfi3_prune - OXfi3_fire )
      DMXfi4 = treevr * ( OXfi3_4 - OXfi4_li - OXfi4_mai - OXfi4_sn &
                                - OXfi4_prune - OXfi4_fire )
      DMXfi = DMXfi1 + DMXfi2 + DMXfi3 + DMXfi4 !Total for 4 age categories.

                          ICSfi = ICSco_CSfi + ICXli_rec_CSfi 
                          OCSfi = OCSfi_mai + OCSfi_G + RNmin_upt &
                                  + OCSfi_Nnit_red + OCSfi_min_upt &
                                  + OCSfi_li + OCSfi_ex + OCSfi_sn &
                                  + OCSfi_prune + OCSfi_fire
      DMCSfi = treevr * ( ICSfi - OCSfi ) 

                          INSfi = INmin_NSfi + INmaiX_NSfi + INXli_rec_NSfi
                          ONSfi = ONSfi_NSco + ONSfi_G + ONSfi_li &
                                  + ONSfi_ex + ONSfi_sn + ONSfi_prune &
                                  + ONSfi_fire
      DMNSfi = treevr * ( INSfi - ONSfi )

   !Integration statements
      MXfi1 =  INTEG( DMXfi1,  MXfi10 )
      MXfi2 =  INTEG( DMXfi2,  MXfi20 )
      MXfi3 =  INTEG( DMXfi3,  MXfi30 )
      MXfi4 =  INTEG( DMXfi4,  MXfi40 )
      MXfim = INTEG( DMXfim, MXfim0 )
      MCSfi = INTEG( DMCSfi, MCSfi0 )
      MNSfi = INTEG( DMNSfi, MNSfi0 )

   !Fine roots and mycorrhiza balance checks
      !Checks on fine roots and mycorrhiza C balance:
         DMCfi = fCfiX * DMXfi + fCfim * DMXfim &
                               + DMCSfi                 !kg C stem-1 day-1.
            !DMCSfi = treevr * ( ICSfi - OCSfi ) 
         DCfi_gnd = Dnstems * MCfi + nstems * DMCfi        !kg C m-2 day-1.
         ICfi = nstems * ICSco_CSfi                        !kg C m-2 day-1.
            OCfi_li = nstems * ( OCSfi_li + OCXfi_li )     !kg C m-2 day-1.

         OCfi = nstems * ( Rfi + OCSfi_ex ) &
                         + OCfi_li + OCfi_th &
                         + OCfi_prune_gnd + OCfi_fire_gnd  !kg C m-2 day-1.
         DCfi_gnd_chk = ICfi - OCfi                !This should = DCfi_gnd.
          !OK with self-thinning.

      !Checks on fine roots and mycorrhiza N balance:
         DMNfi = fNfiX * DMXfi + fNfim * DMXfim &
                               + DMNSfi                 !kg N stem-1 day-1.
         DNfi_gnd = Dnstems * MNfi + nstems * DMNfi        !kg N m-2 day-1.
         INfi = nstems * INmin_NSfi                        !kg N m-2 day-1.
            ONfi_li = nstems * ( ONSfi_li + ONXfi_li )     !kg N m-2 day-1.
         ONfi = nstems * ( ONSfi_NSco + ONSfi_ex ) &   
                         + ONfi_li + ONfi_th &
                         + ONfi_prune_gnd + ONfi_fire_gnd  !kg N m-2 day-1.
         DNfi_gnd_chk = INfi - ONfi                !This should = DNfi_gnd.
          !OK with self-thinning.
!CALL LOGD(.TRUE.)
      !Checks on fine roots and mycorrhiza W balance:
         !DWfi is calculated below.                     !kg W stem-1 day-1.
         DWfi_gnd = Dnstems * Wfi + nstems * DWfi       !kg W m-2 day-1.
         IWfi_gnd = nstems * IWso_fi                    !kg W m-2 day-1.

         OWfi_gnd = OWfi_bud_gnd + OWfi_Wle_gnd + OWfi_prune_gnd &
                                 + OWfi_th + OWfi_fire_gnd   !kg W m-2 day-1.
         DWfi_gnd_chk = IWfi_gnd - OWfi_gnd          !This should = DWfi_gnd.
          !OK with self-thinning.

   !Fine root density
      !Fine root density, rort (an average for the fine root pool) with 
      !units of kg structural DM (m3 soil)-1.

      !The structural density of newly synthesized root material is
         !affected by soil water content, thetasoil, according to:
            rortnew = rortmax - s_water * ( rortmax - rortmin ) * &
                      ( (thetasoil_max - thetasoil) / thetasoil_max )
                      Constant rortmax = 1   !kg structural DM (m3 soil)-1.
                             !Maximum density of root structural matter.
                      Constant rortmin = 0.1 !kg structural DM (m3 soil)-1.
                             !Minimum density of root structural matter.

      !Differential equation:
         !It is assumed that the rate of change of the average root density is:
            Drort = treevr * ( IXfi1 * ( rortnew - rort ) / MXfi )
             rort = INTEG( Drort, rort0 )
         !IXfi1 is the growth rate of fine roots and mycorrhiza structure
            !(kg XDM stem-1 day-1).




!TREE VARIABLES
   !Whole-tree variables
      !Structural dry mass used for substrate storage:
          MXstorage =  MXle + MXbrm + MXstm + MXcom + MXfitot 
                                         !kg structural dry mass stem-1.
      !Mass of N contributing to maintenance (kg N stem-1):
          MNtree_mai = MNle_mai + MNbr_mai + MNst_mai + MNco_mai + MNfi_mai
          Ntree_mai_gnd = nstems * MNtree_mai   !kg N m-2.  
      !Average value of substrate-dependent Michaelis-Menten respiration
         !turn-down factor:
          fCSmai_tree = (fCSmai_le * MNle_mai + fCSmai_br * MNbr_mai + &
                         fCSmai_st * MNst_mai + fCSmai_co * MNco_mai + &
                         fCSmai_fi * MNfi_mai ) / MNtree_mai
      !Nutritional status, CNtree, defined as mean value of CN substrates
        !product. This has components
          zCNle = CNle * MXle; zCNbr = CNbr * MXbrm; zCNst = CNst * MXstm 
          zCnco = CNco * MXcom; zCNfi = CNfi * MXfitot
          CNtree = ( zCNle + zCNbr + zCNst + zCNco + zCNfi ) &
                   / MXstorage
                           ![(kg substrate C)(kg substrate N) (kg X DM)-2].
                      !MXstorage =  MXle + MXbrm + MXstm + MXcom + MXfitot 
                                             !kg structural dry mass stem-1.
          !MXfitot = MXfi + MXfim  !kg XDM in fine roots & mycorrhiza stem-1.

      !C and N average substrate concentrations in the tree:
          CStree = ( Cle * MXle + Cbr * MXbrm + Cst * MXstm &
                      + Cco * MXcom + Cfi * MXfitot ) / MXstorage
                                              !kg substrate C (kg X DM)-1.
          NStree = ( Nle * MXle + Nbr * MXbrm + Nst * MXstm &
                      + Nco * MXcom + Nfi * MXfitot ) / MXstorage
                                              !kg substrate N (kg X DM)-1.
      !C:N ratio in substrate C and N:
          IF ( NStree .GT. zero ) THEN
               rCNStree = CStree / NStree
          ELSE
               rCNStree = csmall
          ENDIF
          rCNStrees_leaf = rCNStree * s_leaf !Just when leaves are present.

      !Total meristem XDM production of tree (kg XDM stem-1 day-1):
         PXDMtree = PXDMbud + PXDMbrm + PXDMstm + PXDMcom + PXDMfim
      !Total structural litter flux from tree to litter (before any 
         !recycling, and without the self-thinning component):
         OXtree_li = OXle4_li + OXbr0_li + OXst0_li + OXco0_li + OXfi4_li
                                                     !kg XDM stem-1 day-1.

   !Shoot:root ratios (on a total DM basis):
      !foliage (le) / fine roots (fi):
         rlefi = Mle / Mfi 
      !(foliage + branches) / (coarse + fine roots):
         rshrt = ( Mle + Mbr ) / ( Mco + Mfi )
      !Ratio of foliage:fine root structural DM allocation:
         rlefiGX =  IXle1 / IXfi1

   !C and N substrate contents of the tree:
      MCStree = MCSle + MCSbr + MCSst + MCSco + MCSfi !kg C substrate stem-1.
      MNStree = MNSle + MNSbr + MNSst + MNSco + MNSfi !kg N substrate stem-1.

   !Structural DM of tree (including meristem DM) (kg XDM stem-1):
      MXtreesh = Mbud + MXle + MXbrtot + MXsttot
      MXtreert = MXcotot + MXfitot
      MXtree = MXtreesh + MXtreert
   !Storage DM of tree (kg storage DM stem-1): 
      MStreesh = MSle + MSbr + MSst
           !MSst is the total storage DM of the stem which includes C, N
           !substrates as well as the actual stem storage pool.
      MStreert = MSco + MSfi   
      MStree = MStreesh + MStreert
   !Total dry matter (kg DM stem-1):
         Mtreesh = MXtreesh + MStreesh 
         Mtreert = MXtreert + MStreert 
         Mtree =   MXtree + MStree !kg DM structure and storage per stem.
                 log10Mtree = LOG10( Mtree )
                 log10MXtree = LOG10( MXtree )
                 log10MXst = LOG10( MXst )
                 log10Mtreesh = LOG10( Mtreesh )
                 log10Mtreert = LOG10( Mtreert )
                 log10Mtree3v2 = log10Mtree_t0 - c1x5 * &     !Three-halves
                                 ( log10nstems - log10nstems_t0 ) !equation.
                 log10Mtree1MXst = log10Mtree_t0 + one * &    !Allometric
                                 ( log10MXst - log10MXst_t0 ) !dependence on
                                                              !MXst^1.

   !Fraction of Mtree which is MX??:
      fMXle_Mtree = MXle / Mtree
      fMXbr_Mtree = MXbr / Mtree
      fMXst_Mtree = MXst / Mtree
      fMXco_Mtree = MXco / Mtree
      fMXfi_Mtree = MXfi / Mtree

   !Fraction of Mtree which is MXtree (MXtree includes meristem X):
      fMXtree_Mtree = MXtree / Mtree

   !Total dry matter [kg DM (m2 ground)-1)]:
         Mtree_gnd = nstems * Mtree

   !Structural growth rates of tree components:
      IXtree = IXle1 + IXbr + IXst + IXco + IXfi1  !kg XDM stem-1 d-1.
      IXtree_gnd = nstems * IXtree                 !kg XDM m-2 d-1.

      IC_Xtree = ICbud_Xle1 + IC_Xbrtot + IC_Xsttot + IC_Xcotot + IC_Xfitot 
                                        !kg C entering tree XDM stem-1 day-1.
      IC_Xtree_gnd = nstems * IC_Xtree !kg C in to tree XDM m-2 day-1.

   !Fractional structural growth:
      IF ( IXtree .NE. zero ) THEN
           fGXle = IXle1 / IXtree
           fGXbr = IXbr / IXtree
           fGXst = IXst / IXtree
           fGXco = IXco / IXtree
           fGXfi = IXfi1 / IXtree
      ELSE
           fGXle = csmall  !7.7777e-17.
           fGXbr = csmall
           fGXst = csmall
           fGXco = csmall
           fGXfi = csmall
      ENDIF
           

   !Whole-tree respiration rates (kg C stem-1 day-1)
      !Maintenance:
         !From C substrate utilization:
            RtreemCS_stem = OCSle_mai + OCSbr_mai + OCSst_mai + OCSco_mai &
                                 + OCSfi_mai
         !From structural DM degradation:
            RtreemX_stem = RmaiXle + RmaiXbr + RmaiXst + RmaiXco + RmaiXfi 
         !Total maintenance respiration:
            Rtreem_stem = RtreemCS_stem + RtreemX_stem 
      !Growth of structure:
         RtreeG_stem = RGbud + RGbr + RGst + RGco + RGfi !kg C stem-1 year-1.
      !Nitrate reduction:
         RNnit_red_tree = RNnit_red_le + RNnit_red_fi
         RNnit_red_tree_gnd = nstems * RNnit_red_tree    !kg C m-2 year-1.
      !Whole tree:
         Rtree_stem = Rle + Rbr + Rst + Rco + Rfi        !kg C stem-1 year-1.
           !e.g. total foliage respiration, Rle (kg C stem-1 day-1), see above.
      
      !Per unit ground area (kg C m-2 day-1):
         Rtreem_gnd = nstems * Rtreem_stem !Total maintenance respiration.
         RtreeG_gnd = nstems * RtreeG_stem !Structural growth respiration.
         Rtree_gnd =  nstems * Rtree_stem  !Tree respiration.

   !Total initial flux of N in senescing structure towards litter:
      ONtreeX = ONXle_li1 + ONXbr_li1 + ONXst_li + ONXco_li1 + ONXfi_li1 
                !kg N stem-1 day-1.
      ONtreeX_gnd = ONtreeX * nstems   !kg N m-2 day-1.
   !Recycled N flux in tree N substrate pools (no stem structure recycling): 
      INtreeS = INXli_rec_NSle + INXli_rec_NSbr &
                + INXli_rec_NSco + INXli_rec_NSfi        !kg N stem-1 day-1.
      INtreeS_gnd = INtreeS * nstems                     !kg N m-2 day-1.
   !Ratio of recycled N flux / total initial litter N flux:
      IF ( ONtreeX .NE. zero ) THEN
           rINtreeS_ONtreeX = INtreeS / ONtreeX 
      ELSE
           rINtreeS_ONtreeX = 9.999E10
      ENDIF

   !Tree balance checks
   !C check:
      !C content of tree (kg C stem-1).
!      MCbud = fCbud * Mbud           !fCbud = 0.4 !kg C (kg dry mass)-1.
          fCbrmxMXbrm = fCbrm * MXbrm !fCbrm = 0.4
          fCbrXxMXbr = fCbrX * MXbr   !fCbrX = 0.4
          fCcomxMXcom = fCcom * MXcom !fCcom = 0.4
          fCcoXxMXco = fCcoX * MXco   !fCcoX = 0.4
          fCfimxMXfim = fCfim * MXfim !fCfim = 0.4
          fCfiXxMXfi = fCfiX * MXfi   !fCfiX = 0.4
          fCleXxMXle = fCleX * MXle   !fCleX = 0.4
          fCstmxMXstm = fCstm * MXstm !fCstm = 0.4
          fCstXxMXst = fCstX * MXst   !fCstX = 0.4
         MCtree = MCbud &
                  + MCSle + fCleXxMXle &
                  + MCSbr + fCbrXxMXbr + fCbrmxMXbrm &
                  + MCSst + MCstorest + fCstXxMXst + fCstmxMXstm &
                  + MCSco + fCcoXxMXco + fCcomxMXcom &
                  + MCSfi + fCfiXxMXfi + fCfimxMXfim    !kg C stem-1.
          Ctree = nstems * MCtree                      !kg C m-2.
      !Rate of change of C content of tree (kg C stem-1 day-1):
         DMCtree =   DMCbud +         fCleX * DMXle + DMCSle &
                   + fCbrm * DMXbrm + fCbrX * DMXbr + DMCSbr &
                   + fCstm * DMXstm + fCstX * DMXst + DMCSst + DMCstorest &
                   + fCcom * DMXcom + fCcoX * DMXco + DMCSco &
                   + fCfim * DMXfim + fCfiX * DMXfi + DMCSfi
          DCtree = nstems * DMCtree + Dnstems * MCtree      !kg C m-2 day-1.
      !C input to tree:
         ICtree = Pcan   !kg C m-2 day-1. Canopy photosynthesis.
      !C outputs from tree:
         !Respiration, isoprene emission, and fire:
            OCtree_atm = Rtree_gnd + OCle_IP_atm_gnd + OCtree_fire_atm
                                                            !kg C m-2 day-1.
         !Litter (direct litter fluxes, including self-thinning litter, 
            !but not litter from thinning - total thinning loss is given
            !below.
            !loss of structural C:
               OCXtree_li = OCXle_li + OCXbr_li + OCXst_li + OCXco_li &
                          + OCXfi_li         !kg structural C stem-1 day-1.
            !loss of substrate C:
               OCStree_li = OCSle_li + OCSfi_li !kg substrate C stem-1 day-1.
            !total C loss to litter from tree:
               OCtree_li = OCXtree_li + OCStree_li        !kg C stem-1 day-1.

         !C flux from tree to soil (litter + root exudate):
            OCtree_soil = nstems * ( OCXtree_li + OCStree_li + OCSfi_ex ) &
                          + OCtree_fire_soil_li + OCtree_fire_Char
                                                             !kg C m-2 day-1.
         !Total C loss from tree to pruning:
            OCtree_prune = OCbud_prune_gnd &
                         + OCle_prune_gnd + OCbr_prune_gnd &
                         + OCst_prune_gnd &
                         + OCXco_prune_gnd + OCfi_prune_gnd !kg C m-2 day-1.

         !C loss from phloem to aphids:
            OCphloem_aph = nstems * OCSle_aph               !kg C m-2 day-1.

      !Total C output from tree (to environment - including fire to atmosphere,
          !soil + litter, pruning, thinning, leaf fall, aphids)
         OCtree = OCtree_atm + OCtree_soil + OCtree_prune + OCtree_th &
                             + OCle_lf_gnd + OCphloem_aph
                             
                                                            !kg C m-2 day-1.
      !Check C accounting:
         DCtree_chk = ICtree - OCtree  !This should = DCtree.
          !OK with self-thinning.

      !On a per stem basis (kg C stem-1 day-1):
          ICph_CSle_chk = DMCtree + Rtree_stem + OCtree_li + OCSfi_ex 
         !This should = ICph_CSle, the instantaneous gross photosynthetic
         !rate on a per stem basis.
               !Not ok with self-thinning - maybe this is ok as
               ! fGRnstems = -1.8681D-05.   

   !N check:
      !N content of tree:
         MNtree = MNbud         + fNleX * MXle + MNSle + MNph &
                + fNbrm * MXbrm + fNbrX * MXbr + MNSbr &
                + fNstm * MXstm + fNstX * MXst + MNSst &
                + fNcom * MXcom + fNcoX * MXco + MNSco &
                + fNfim * MXfim + fNfiX * MXfi + MNSfi        !kg N stem-1.
          Ntree = nstems * MNtree                        !kg N m-2.
   
      !Rate of change of N content of tree:
         DMNtree = DMNbud &
                                  + fNleX * DMXle + DMNSle + DMNph &
                 + fNbrm * DMXbrm + fNbrX * DMXbr + DMNSbr &
                 + fNstm * DMXstm + fNstX * DMXst + DMNSst &
                 + fNcom * DMXcom + fNcoX * DMXco + DMNSco &
                 + fNfim * DMXfim + fNfiX * DMXfi + DMNSfi !kg N stem-1 day-1.
          DNtree = nstems * DMNtree + Dnstems * MNtree     !kg N m-2 day-1.
      !N input to tree:
         INtree = uN_gnd                                   !kg N m-2 day-1.
      !N output from tree:
         !Ammonia N loss from foliage: ONSle_atm_gnd (can be + or -).
         !Fire:
            !ONtree_fire    See above    .                  !kg N m-2 day-1.
         !Litter loss of structural N (kg structural N stem-1 day-1):
            ONXtree_li = ONXle_li + ONXbr_li + ONXst_li + ONXco_li + ONXfi_li
         !Litter loss of substrate N (kg substrate N stem-1 day-1):
            ONStree_li = ONSle_li + ONSfi_li + ONSfi_ex
         !Total N direct litter loss from tree (kg N m-2 day-1):
            ONtree_li = nstems * ( ONXtree_li + ONStree_li + ONph_li )
         !Total N loss from tree to pruning:
            ONtree_prune = ONbud_prune_gnd &
                         + ONle_prune_gnd + ONXbr_prune_gnd &
                         + ONXst_prune_gnd &
                         + ONXco_prune_gnd + ONfi_prune_gnd  !kg N m-2 day-1.
         !N loss from phloem to aphids:
            ONphloem_aph = nstems * ONSle_aph               !kg N m-2 day-1.
         !Total N loss from tree, including thinnings (kg N m-2 day-1):
            ONtree = ONSle_atm_gnd + ONtree_li + ONtree_prune + ONtree_th & 
                                   + ONle_lf_gnd + ONphloem_aph &
                                   + ONtree_fire
                                                         
      !Check N accounting:
         DNtree_chk = INtree - ONtree
         !This should = DNtree. OK with self-thining.
      !On a per stem basis (kg N stem-1 day-1):
         uN_stem_chk = DMNtree + FGRnstems_sn * MNtree + ONXtree_li & !???
                               + ONSfi_ex 
         !This should = uN_stem, the root N uptake rate.
         !Not ok with self-thinning when fGRnstems = -1.8681D-05
!End of TREE SUBMODEL



!SOIL AND LITTER SUBMODEL
   !Parameters
      Constant Cbiomin = 0.001 !kg C in microbial biomass m-2.
                       !This is a minimum on the size of the biomass pool.
      Constant c_bioDclay = 3  !Dimensionless.  Determines dependence on clay
                       !content of fraction of dying microbial biomass C 
                       !entering the unprotected and protected SOM pools.
      Constant c_lit_prot = 3 !Dimensionless. Determines fraction of decaying
                       !lignin litter which enters the protected SOM pool.
      Constant cNbio = 1 !kg ammonium N (kg nitrate N)-1. 
                       !Relative uptake efficiency
                       !of Nnit cf Namm of microbial biomass in taking up N.
      Constant crCNli = 25.0 !kg C (kg N)-1. CN ratio effect on
                           !decomposition rate of litter.
      Constant c_sSOMclay = 3 !Dimensionless.  Dependence of CN ratio of
                       !stabilized SOM (sSOM) on clay content, fclay.  See
                       !Initial section.
      Constant fCbioDR = 0.5 !Dimensionless.  Fraction of C from biomass death
                       !which is respired.
      Constant fCbioD_Csol = 0.1 !Dimensionless. Fraction of C from biomass
                       !death which is returned to Csol (soluble C) pool.
      Constant fCbioD_uSOM_sandy = 0.7, fCbioD_uSOM_clay = 0.3 
                       !Dimensionless.  Fractions of dying biomass C entering
                       !unprotected SOM pool, CuSOM.  Dependence on actual clay
                       !content calculated in Initial section.
      Constant fCrtli_met = 0.2, fCrtli_cel = 0.65, fCrtli_lig = 0.15
      Constant fCshli_met = 0.2, fCshli_cel = 0.65, fCshli_lig = 0.15
                       !Fractions of C in root, shoot litter
                       !which is metabolic, cellulose, lignin.
      Constant fCsoil_li_metR = 0.6 !Dimensionless.  Fractions of C
      Constant fCsoil_li_celR = 0.4 !     in soil litter components
      Constant fCsoil_li_ligR = 0.2 !            which are respired.
      Constant fCsurf_li_metR = 0.6 !Dimensionless.  Fractions of C
      Constant fCsurf_li_celR = 0.4 !  in surface litter components
      Constant fCsurf_li_ligR = 0.2 !            which are respired.
      Constant fCpSOM_minR = 0.4    !Dimensionless.
      Constant fCsSOM_minR = 0.4    !Fractions of C in fluxes from
      Constant fCuSOM_minR = 0.4    !pSOM, sSOM, uSOM to
                                    !mineralization which are respired.
      Constant fCpSOM_sSOMR = 0.2   !Dimensionless. Fractions of C in
      Constant fCuSOM_sSOMR = 0.2   !fluxes from pSOM and uSOM to sSOM
                                    !which are respired.
      Constant fclay_default = 0.2  !Dimensionless. Clay content. 
                                    !Default value.
      Constant fnitrif = 0.05       !Fraction of nitrification flux from Namm
                                    !which is lost to the environment.
      Constant fSOMbio = 0.05       !kg C in microbial biomass (kg C in SOM)-1.
                                    !Ceiling value of Cbio is f * Csom.
   
      Constant JNeff_bio_Nfix = 0.001 !kg N m-2.
                       !Inhibition constant of N fixation by soil
                       !microbial biomass. As more N becomes available in the
                       !soil, N fixation is turned off.
      Constant KCbioG = 0.001, KNbioG = 0.0002 !kg C, N m-2.
                       !Microbial biomass growth Michaelis-Menten constants.
      Constant KCsol_Nfix = 0.0005 !kg C m-2.  Michaelis-Menten constant for
                       !effect of soil soluble C on non-symbiotic N fixation.
      Constant KrCNpSOM = 0.0005, KrCNsSOM = 0.0005, KrCNuSOM = 0.0005 
                       !kg N m-2.
                       !Gives Michaelis-Menten dependencies on Nmin of C/N
                       !ratios in new SOM material in the three SOM pools.
      Constant kbioD20 = 0.01 !day-1.
                       !Maximum specific death rate of soil biomass
                       !at 20 oC.
      Constant kbioG20 = 0.1  !(kg C) ** (1 - qbio) day-1.
                       !Maximum specific growth rate of soil microbial biomass
                       !for qbio = 1 at 20 oC.
      Constant kCsolR20 = 0.1 !day-1.  Direct respiration of Csol pool
                       !to environment.
      Constant kdenit20 = 0.1  !m2 (kg biomass C)-1 day-1.
                       !Denitrification rate constant.
      Constant kNfix_bio20 = 0.2e-3   !kg N (kg biomass C)-1 day-1.
                       !Diazotrophic soil N fixation rate constant.
                       !If Cbio = 0.1 kg biomass C m-2, Neff_bio = 0,
                       !this gives a rate of 20.0e-6 kg N m-2 day-1,
                       !or about 73 kg N ha-1 year-1.
      Constant knit20 = 1.0  !(kg biomass C m-2)-1 day-1.
                       !With Cbio = 0.2, Namm = 0.001, this gives
                       !2.0 * 0.2 * 0.001 = 1500 x 10-6 kg N m-2 day-1
                       !equivalent to c. 730 kg N ha-1 year-1.
      Constant kpSOM_min20 = 0.075e-3  !day-1.
                       !Rate constant for mineralization of
                       !protected SOM. Time constant: c. 20 years.
      Constant kpSOM_sSOM20 = 0.02e-3 !day-1. Rate constant for
                       !chemical stabilization of protected SOM.
      Constant ksSOM_min20 = 0.015e-3   !day-1.
                       !Rate constant for mineralization of
                       !stabilized SOM. Time constant: c. 100 years.
      Constant kuSOM_min20 = 1.5e-3   !day-1.
                       !Rate constant for mineralization of
                       !unprotected SOM. Time constant: c. 1 years.
      Constant kuSOM_sSOM20 = 0.2e-3 !day-1.  Rate constant for
                       !chemical stabilization of unprotected SOM.
      Constant ksoil_li_met20 = 0.2  !day-1. Rate constants for
      Constant ksoil_li_cel20 = 0.1         !decomposition of soil, surface
      Constant ksoil_li_lig20 = 0.02        !litter components:  
      Constant ksurf_li_met20 = 0.2         !metabolic (met),
      Constant ksurf_li_cel20 = 0.1         !cellulose (cel), 
      Constant ksurf_li_lig20 = 0.02        !lignin (lig).
      Constant kvol20 = 0.04 !day-1. !Soil ammonia volatilization rate constant
                       !at 20 oC.  At 20 oC, with Namm = 0.001 kg N m-2,
                       !volatization flux is 10 * 10-6 kg N m-2
                       !day-1, or 36.5 kg N ha-1 year-1.
      Constant qbio = 0.6667 !Dimensionless. Parameter to decrease microbial 
                             !biomass growth rate to slower than exponential.
      Constant qdenit = 10  !Dimensionless.  Denitrification parameter.
                       !It turns off denitrification rapidly as soil dries out.
      Constant qlit_decay_lig = 3.0  !Dimensionless.  Parameter for
                       !dependence of litter decay on lignin fraction.
      Constant qWsoil = 20 !Dimensionless. Effect of water on soil
                           !biochemistry.
      Constant qWsurf = 30 !Dimensionless.  Effect of water on surface
                       !biochemistry.
      Constant rCNbio = 8  !kg C (kg N)-1.  C/N ratio in microbial biomass.
      Constant rCNcel = 150, rCNlig = 100  !kg C (kg N)-1.
                       !C/N ratios in cellulose and lignin.
      Constant rCNpSOMmax = 11, rCNpSOMmin = 7, &
               rCNuSOMmax = 11, rCNuSOMmin = 7 !kg C (kg N)-1.
                       !Maximum and minimum C/N ratios of protected and
                       !unprotected SOM.  These are assumed not to
                       !change with clay content of soil or lignin
                       !content of litter inputs. Actual C/N ratios
                       !decrease as Nmin (soil mineral N concentration)
                       !increases. See KrCNiSOM, i = p,s,u.
      Constant rCNsSOM_sandymax = 12, rCNsSOM_claymax = 10, &
               rCNsSOM_sandymin =  9, rCNsSOM_claymin =  7  !kg C (kg N)-1.
                       !C/N ratio of stabilized SOM. This is assumed
                       !to depend on clay content, fclay.  rCNsSOMmax
                       !and rCNsSOMmin are calculated in the initial section.
                       !Actual rCNsSOM decreases with increasing Nmin.
      Constant Ybio = 0.5 !Dimensionless. C yield coefficient for soil
                          !microbial biomass synthesis.
   
   
   !Temperature functions, fTsoil, fTsurf
      !For soil processes, fTsoil, is assumed to be the same as for plant 
         !processes, and is calculated above (p 79) in the once-a-day 
         !environment section (soil temperature does not vary diurnally).

      !Surface processes.
         !Assume that surface temperature Tsurf is midway between air
         !temperature Tair amd soil temperature Tsoil:
            Tsurf = half * ( Tair + Tsoil )
            IF (( Tsurf .LE. T0 ) .OR. ( Tsurf .GE. T0p ) ) THEN
               fTsurf = c1E_10
            ELSE
               fTsurf = m_fT * (( Tsurf - T0 ) ** qfT1 & 
                        * ( T0p - Tsurf ) ** qfT2 ) * zfT
            ENDIF
               !zfT = one / &
               !      ( ( Tref - T0 ) ** qfT1 * ( T0p - Tref ) ** qfT2  &
               !      )

   !Water functions modifying soil and surface litter biochemistry
      !fWsoil = aWsoil ** ( s_water * qWsoil )    !Soil.     See p 81.
      !fWsurf = aWle ** ( s_water * qWsurf )      !Surface. 
      !The model does not track surface water.  We have assumed that
      !foliage water activity is closer to surface (litter) water activity
      !than root or (bulk) soil water activity.

       
   !Surface litter pools
         !Soil surface litter is derived from shoot litter, 
         !and from thinning.
   
      !Inputs of C, N to surface litter pools (kg C, N m-2 day-1)
            !1. Foliage (le)
               !From normal senescence/litter process.
                  !Structural C, N (CX, NX), substrate C, N (SC, SN), 
                  !photosynthetic N (Nph) fluxes.
                  !(self-thinning does not contribute to foliage litter):
                   OCXle_li_gnd = nstems * OCXle_li
                   ONXle_li_gnd = nstems * ONXle_li
                   OCSle_li_gnd = nstems * OCSle_li
                   ONSle_li_gnd = nstems * ONSle_li
                   ONph_li_gnd =  nstems * ONph_li
   
               !From leaf fall (deciduous trees only):
                  !OCXle_lf_gnd, OCSle_lf_gnd,
                  !ONXle_lf_gnd, ONSle_lf_gnd, ONph_lf_gnd
   
               !From thinning (substrate + structural C, N). 
                  !Calculated in Tree Submodel Thinning section:
                  !OCSle_th (CS), ONSle_th (NS), OCbud_th, ONbud_th, 
                  !OCXle_th (CX), ONXle_th (NX), ONph_th.
   
               !From pruning (substrate + structural C, N).
                  !Calculated in the Tree Submodel, Buds, Foliage section:
                  !OCbud_prune_gnd, ONbud_prune_gnd
                  !OCSle_prune_gnd, OCXle_prune_gnd, 
                  !ONSle_prune_gnd, ONXle_prune_gnd.
                  !NSle term includes Nph contribution.
                  !It is assumed that these fluxes enter the surface litter
                  !pools in their entirety.
   
            !2. Branches (br) and stems (st), together denoted by (brst).
               !From senescence (br_li), and from self-thinning
                  !(CXst_li, structural C, NXst_li, structural N):
                   OCXbrst_li_gnd = nstems * ( OCXbr_li + OCXst_li ) 
                   ONXbrst_li_gnd = nstems * ( ONXbr_li + ONXst_li )
               !From thinning (storage + structural C, N).
                  !Calculated in Tree Submodel Thinning section.
                  !After thinning, fractions fbr_rem_th_prod, fst_rem_th_prod
                  !of the branches and stems are removed as 
                  !products, the remainder being left on the soil surface.
                  !Search (up) <th_surf_li>.
               !From pruning (structural C, N only).
                  !Calculated in the Tree Submodel, Branches section:
                  !OCXbr_prune_gnd, ONXbr_prune_gnd,
                  !OCXst_prune_gnd, ONXst_prune_gnd.
   
   
            !Totals for surface litter 
               !The total SC, SN, XC, XN inputs to surface litter are:
                     !For thinning fluxes, see Tree Submodel Thinning section.
                  ICSsurf_li = OCSle_li_gnd + OCSle_lf_gnd &
                                            + ICSth_surf_li + OCSle_prune_gnd
                  ICXsurf_li = OCXle_li_gnd + OCXle_lf_gnd &
                             + OCXbrst_li_gnd + ICXth_surf_li &
                             + OCbud_prune_gnd &
                             + OCXle_prune_gnd + OCXbr_prune_li &
                             + OCXst_prune_li
                  INSsurf_li = ONSle_li_gnd + ONph_li_gnd &
                             + ONSle_lf_gnd + ONph_lf_gnd &
                             + INSphth_surf_li + ONSle_prune_gnd
                  INXsurf_li = ONXle_li_gnd + ONXle_lf_gnd &
                             + ONXbrst_li_gnd + INXth_surf_li &
                             + ONbud_prune_gnd &
                             + ONXle_prune_gnd + ONXbr_prune_li &
                             + ONXst_prune_li
   
               !Total tree C, N inputs to surface litter are:
                  ICtree_surf_li = ICXsurf_li + ICSsurf_li 
                  INtree_surf_li = INXsurf_li + INSsurf_li 
   
               !Total (tree + aphid honeydew + mortality) C, N inputs to
                                                         !surface litter:
                  ICsurf_li = ICtree_surf_li + ICaph_surf_li_met &
                                             + ICaph_surf_li
                  INsurf_li = INtree_surf_li + INaph_surf_li
                  INsurf_li_chk = INsurf_li_met + INsurf_li_cel + INsurf_li_lig
                              !OK with self-thinning.
   
               !Checks:
                  ICth_surf_li_chk = ICSth_surf_li + ICXth_surf_li  
                  INth_surf_li_chk = INSphth_surf_li + INXth_surf_li 
                     !??? Aphid inputs required???
             !OK, all 0 with self-thinning and aphid mortality and no thinning.
   
         !The substrate C, N fluxes are put straight into the two met pools.
         !The structural fluxes are divided between met, cel, lig.
            ICsurf_li_met = ICSsurf_li + fCshli_met * ICXsurf_li &           
                                       + ICaph_surf_li_met !Aphid honeydew.
               !Aphid mortality, pruning and thinning:
                  ICaph_surf_li_cel = fCaph_cel * ICaph_surf_li
                                Constant fCaph_cel = 0.5 !Dimensionless.
                               !Fraction of C in dead aphids assigned to
                               !surface litter cellulose.
            ICtree_surf_li_cel = fCshli_cel * ICXsurf_li
            ICsurf_li_cel = ICtree_surf_li_cel + ICaph_surf_li_cel
                     !This carries an N flux of:
                      INsurf_li_cel = ICsurf_li_cel / rCNcel
                  !The rest of the dead aphids are assigned to lignin:
                  ICaph_surf_li_lig = ( one - fCaph_cel ) * &
                                                      ICaph_surf_li
            ICtree_surf_li_lig = fCshli_lig * ICXsurf_li
            ICsurf_li_lig = ICtree_surf_li_lig + ICaph_surf_li_lig
                     !This carries an N flux of:
                      INsurf_li_lig = ICsurf_li_lig / rCNlig
   
         !As the cel and lig pools have fixed C/N ratios the N input to met is:
                        INtree_surf_li_cel = ICtree_surf_li_cel / rCNcel
                        INtree_surf_li_lig = ICtree_surf_li_lig / rCNlig
                        INaph_surf_li_cel = ICaph_surf_li_cel / rCNcel
                        INaph_surf_li_lig = ICaph_surf_li_lig / rCNlig 
         !Input flux from aphids to surface litter met pool:
            INaph_surf_li_met =  INaph_surf_li &
                               - INaph_surf_li_cel - INaph_surf_li_lig
            INtree_surf_li_met = INtree_surf_li &
                                - INtree_surf_li_cel - INtree_surf_li_lig 
            INsurf_li_met = INtree_surf_li_met + INaph_surf_li_met 
      
      !Outputs of C, N from surface litter pools (kg C, N m-2 day-1)
         !From metabolic, cellulose, lignin: 
            OCsurf_li_met = ksurf_li_met * Csurf_li_met
            ONsurf_li_met = ksurf_li_met * Nsurf_li_met
            OCsurf_li_cel = ksurf_li_cel * Csurf_li_cel
               !Accompanying this C flux is an N flux of:
!CALL LOGD(.TRUE.)
                  ONsurf_li_cel = OCsurf_li_cel / rCNcel
            OCsurf_li_lig = ksurf_li_lig * Csurf_li_lig
               !Accompanying this C flux is an N flux of:
            ONsurf_li_lig = OCsurf_li_lig / rCNlig
   
   
               !Totals:
                  OCsurf_li = OCsurf_li_met + OCsurf_li_cel + OCsurf_li_lig
                  ONsurf_li = ONsurf_li_met + ONsurf_li_cel + ONsurf_li_lig
   
               !Rate constants are given by (day-1):
               ksurf_li_met = m_ksurf_li * ksurf_li_met20 * fTsurf * fWsurf &
                              * frCNsurf_li
               ksurf_li_cel = m_ksurf_li * ksurf_li_cel20 * fTsurf * fWsurf &
                              * frCNsurf_li * fdecay_lig_surf
               ksurf_li_lig = m_ksurf_li * ksurf_li_lig20 * fTsurf * fWsurf &
                              * frCNsurf_li * fdecay_lig_surf
               !m_ksurf_li is a multiplier of the surface litter decomposition 
                  !rate constants.
                  Constant m_ksurf_li = 1 !Dimensionless. Default value.
               !ksurf_li_*20 are rate constants at 20 deg C.
               !fTsurf, fWsurf are surface temperature and water functions.
               !frCNsurf_li gives the dependence of rates on total
                  !litter C/N ratio, decreasing with increasing C/N:
                     rCNsurf_li = Csurf_li / Nsurf_li !Ratio of C/N.
                  frCNsurf_li = crCNli / rCNsurf_li 
                     !As crCNli = 25 (a constant), then
                     !when rCNsurf_li (C/N ratio in the 
                     !surface litter) = 25, then frCNsurf_li = 1.
               !fdecay_lig_surf gives dependence of cel and lig decay rates
                  !on lignin C fraction in these pools, flig_surf:
                  flig_surf = Csurf_li_lig &
                               / ( Csurf_li_lig + Csurf_li_cel )
                  fdecay_lig_surf =  EXP( -qlit_decay_lig * flig_surf )
                  !Constant qlit_decay_lig = 3
   
      !Respiration from the outputs (kg C respired m-2 day-1)
         Rsurf_li_met =  fCsurf_li_metR * OCsurf_li_met  
         Rsurf_li_cel =  fCsurf_li_celR * OCsurf_li_cel  
         Rsurf_li_lig =  fCsurf_li_ligR * OCsurf_li_lig  
            !Total surface litter respiration (kg C respired m-2 day-1):
            Rsurf_li = Rsurf_li_met + Rsurf_li_cel + Rsurf_li_lig 
   
      !C and N inputs generated to other pools (kg C, N m-2 day-1)
         !To soil soluble C, Csol:
            ICsurf_li_Csol = OCsurf_li_met - Rsurf_li_met &
                             +  OCsurf_li_cel - Rsurf_li_cel
         !To soil ammonium, Namm:
            INsurf_li_Namm = ONsurf_li_met + OCsurf_li_cel / rCNcel 
         !To unprotected and protected SOM pools, uSOM, pSOM:
            ICsurf_li_SOM = OCsurf_li_lig - Rsurf_li_lig  !Total flux to SOM.
               !This flux divides between uSOM and pSOM pools according to
               !clay content, fclay.  The fraction of this litter flux that
               !gets protected is:
                  !fClit_prot = c_lit_prot * fclay.  This is calculated
                  !in INITIAL section.
            ICsurf_li_pSOM = fClit_prot * ICsurf_li_SOM
            ICsurf_li_uSOM = ICsurf_li_SOM - ICsurf_li_pSOM 
   
         !To provide the N needed to give the C/N ratios required
            !for new uSOM and pSOM material demands a total N flux of:
               ReqNsurf_li_lig_SOM = &
                    ICsurf_li_uSOM / rCNuSOMn + ICsurf_li_pSOM / rCNpSOMn
         !This requirement is partially met by release of N from lignin
            !of ONsurf_li_lig. The rest is taken from the Namm and Nnit pools
            !(together designated as Nmin) at a rate:
               ONmin_surf_li_SOM = ReqNsurf_li_lig_SOM - ONsurf_li_lig
            !This is divided between Namm and Nnit pools in the same ratio
            !in which biomass take Namm and Nnit 
            !(see microbial biomass section):
               ONamm_surf_li_SOM = fNamm_bio * ONmin_surf_li_SOM
               ONnit_surf_li_SOM = fNnit_bio * ONmin_surf_li_SOM
   
      !Differential equations (kg C, N m-2 day-1)
         !Metabolic (Csurf_li_met, Nsurf_li_met):
            DCsurf_li_met =  soilvr * ( ICsurf_li_met - OCsurf_li_met &
                                        - OCsurf_li_met_fire )
             Csurf_li_met =  INTEG( DCsurf_li_met, Csurf_li_met0 )
            DNsurf_li_met =  soilvr * ( INsurf_li_met - ONsurf_li_met &
                                        - ONsurf_li_met_fire )
             Nsurf_li_met =  INTEG( DNsurf_li_met, Nsurf_li_met0 )
         !Cellulose (Csurf_li_cel):
            DCsurf_li_cel =  soilvr * ( ICsurf_li_cel - OCsurf_li_cel &
                                        - OCsurf_li_cel_fire )
             Csurf_li_cel =  INTEG( DCsurf_li_cel, Csurf_li_cel0 )
                !Nsurf_li_cel is not a state variable as the C/N ratio of the
                !cellulose pool is fixed, at rCNcel.
         !Lignin (Csurf_li_lig):
            DCsurf_li_lig =  soilvr * ( ICsurf_li_lig - OCsurf_li_lig &
                                        - OCsurf_li_lig_fire )
             Csurf_li_lig =  INTEG( DCsurf_li_lig, Csurf_li_lig0 )
                !Nsurf_li_lig is not a state variables as the C/N ratio of the
                !lignin pool is fixed, at rCNlig.
   
      !Totals for surface litter are:
         Csurf_li = Csurf_li_met + Csurf_li_cel + Csurf_li_lig !kg C m-2.
                    Nsurf_li_cel = Csurf_li_cel / rCNcel
                    Nsurf_li_lig = Csurf_li_lig / rCNlig       !kg N m-2.
         Nsurf_li = Nsurf_li_met + Nsurf_li_cel + Nsurf_li_lig
         DCsurf_li = DCsurf_li_met + DCsurf_li_cel + DCsurf_li_lig
                     DNsurf_li_cel = DCsurf_li_cel / rCNcel
                     DNsurf_li_lig = DCsurf_li_lig / rCNlig
         DNsurf_li = DNsurf_li_met + DNsurf_li_cel + DNsurf_li_lig
         DCsurf_li_chk = ICsurf_li - OCsurf_li
         DNsurf_li_chk = INsurf_li - ONsurf_li
              !All ok with self-thinning,
   
   !Soil litter pools (kg C, N m-2).
         !Soil litter is derived from root litter.

      !Inputs of C, N to soil litter pools (kg C, N m-2 day-1)
         !1. Coarse roots (co)
            !from senescence and self-thinning (structural C (XC) only):
                OCXco_li_gnd = nstems * OCXco_li
                ONXco_li_gnd = nstems * ONXco_li
            !From thinning (substrate + structural C, N). Calculated in Tree
               !Submodel Section from OCSco_th, ONSco_th, OCXco_th, ONXco_th.
            !From pruning (structural C, N only).
               !Calculated in the Tree Submodel, Coarse Roots section:
               !OCXco_prune_li, ONXco_prune_li
               
         !2. Fine roots (fi)
            !Structural C, N (CX, NX), substrate C, N (SC, SN), fluxes
               !from senescence.
               !(self-thinning does not contribute to fine litter):
                OCXfi_li_gnd = nstems * OCXfi_li
                ONXfi_li_gnd = nstems * ONXfi_li
                OCSfi_li_gnd = nstems * OCSfi_li
                ONSfi_li_gnd = nstems * ONSfi_li
            !From thinning (substrate + structural C, N). Calculated in Tree
               !Submodel Section from OCSfi_th, ONSfi_th, OCSfi_th, ONXfi_th. 
   
            !From pruning (substrate + structural C, N).
               !Calculated in the Tree Submodel, Fine Roots section:
                  !OCSfi_prune_gnd, OCXfi_prune_gnd, 
                  !ONSfi_prune_gnd, ONXfi_prune_gnd.
                  !It is assumed that these fluxes enter the soil litter
                  !pools in their entirety.
   
            !The total SC, SN, XC, XN inputs to soil litter are:
                  ICSsoil_li = OCSfi_li_gnd + ICSth_soil_li &
                             + OCSfi_prune_gnd + ICSco_fire_soil_li &
                             + ICSfi_fire_soil_li
                  ICXsoil_li = OCXco_li_gnd + OCXfi_li_gnd + ICXth_soil_li &
                                            + OCXco_prune_li &
                             + OCXfi_prune_gnd + ICXco_fire_soil_li &
                             + ICXfi_fire_soil_li
                  INSsoil_li = ONSfi_li_gnd + INSth_soil_li &
                                            + ONSfi_prune_gnd &
                             + INSco_fire_soil_li + INSfi_fire_soil_li
                  INXsoil_li = ONXco_li_gnd + ONXfi_li_gnd + INXth_soil_li &
                                            + ONXco_prune_li &
                             + ONXfi_prune_gnd + INXco_fire_soil_li &
                             + INXfi_fire_soil_li
   
            !Total C, N inputs to soil litter are:
                  ICsoil_li = ICSsoil_li + ICXsoil_li 
                  INsoil_li = INSsoil_li + INXsoil_li 
   
               !Checks:
                  ICth_soil_li_chk = ICSth_soil_li + ICXth_soil_li 
                  INth_soil_li_chk = INSth_soil_li + INXth_soil_li 
                  
                  ICth_litter_chk = ICth_surf_li_chk + ICth_soil_li_chk 
                  INth_litter_chk = INth_surf_li_chk + INth_soil_li_chk 
                  !All 4 ok under selfthinning.

         !The substrate C, N fluxes are put straight into the two met pools.
         !The structural fluxes are divided between met, cel, lig.
            ICsoil_li_met = ICSsoil_li + fCrtli_met * ICXsoil_li
            ICsoil_li_cel = fCrtli_cel * ICXsoil_li
            ICsoil_li_lig = fCrtli_lig * ICXsoil_li
         !As the cel and lig pools have fixed C/N ratios the N input to met is:
            INsoil_li_met = INsoil_li &
                            - ICsoil_li_cel / rCNcel &
                            - ICsoil_li_lig / rCNlig
   
   
      !Outputs of C, N from soil litter pools (kg C, N m-2 day-1)
         !From metabolic, cellulose, lignin:
            OCsoil_li_met = ksoil_li_met * Csoil_li_met  
            ONsoil_li_met = ksoil_li_met * Nsoil_li_met  
            OCsoil_li_cel = ksoil_li_cel * Csoil_li_cel  
            OCsoil_li_lig = ksoil_li_lig * Csoil_li_lig  
               !The rate constants are given by (day-1):
               ksoil_li_met = ksoil_li_met20 * fTWsoil &
                                                      * frCNsoil_li
               ksoil_li_cel = ksoil_li_cel20 * fTWsoil &
                                    * frCNsoil_li * fdecay_lig_soil
               ksoil_li_lig = ksoil_li_lig20 * fTWsoil &
                                    * frCNsoil_li * fdecay_lig_soil
               !ksoil_li_*20 are rate constants at 20oC.
               !fTsoil, fWsoil are soil temperature and water functions.
               !frCNsoil_li gives the dependence of rates on total
                            !litter C/N ratio, decreasing with increasing C/N.
                            rCNsoil_li = Csoil_li / Nsoil_li  !Ratio of C/N.
                frCNsoil_li = crCNli / rCNsoil_li 
                        !As crCNli = 25 (Constant), then
                        !when rCNsoil_li (C/N ratio in the total
                        !soil litter) = 25, then frCNsoil_li = 1.
               !fdecay_lig_soil gives dependence of cel and lig decay rates
                  !on flig_soil, fraction of lignin by C content in cel + lig
                  !pools:
                     flig_soil = Csoil_li_lig &
                                  / ( Csoil_li_lig + Csoil_li_cel )
                  fdecay_lig_soil =  EXP( -qlit_decay_lig * flig_soil )
                  !Constant qlit_decay_lig = 3.
                  
   
      !Respiration from the outputs (kg C respired m-2 day-1):
         Rsoil_li_met =  fCsoil_li_metR * OCsoil_li_met  
         Rsoil_li_cel =  fCsoil_li_celR * OCsoil_li_cel  
         Rsoil_li_lig =  fCsoil_li_ligR * OCsoil_li_lig  
            !Total within soil litter respiration (kg C m-2 day-1):
            Rsoil_li = Rsoil_li_met + Rsoil_li_cel + Rsoil_li_lig 
   
      !C and N inputs generated to other pools (kg C, N m-2 day-1):
         !To soil soluble C, Csol:
            ICsoil_li_Csol = OCsoil_li_met - Rsoil_li_met &
                             + OCsoil_li_cel - Rsoil_li_cel
         !To soil ammonium, Namm:
            INsoil_li_Namm = ONsoil_li_met + OCsoil_li_cel / rCNcel 
         !To unprotected and protected SOM pool, uSOM, pSOM:
            ICsoil_li_SOM = OCsoil_li_lig - Rsoil_li_lig
               !This flux divides between uSOM and pSOM pools according to
               !clay content, fclay.  The fraction of this litter flux that
               !gets protected is:
                  !fClit_prot = c_lit_prot * fclay. this is calculated
                  !in INITIAL section.
            ICsoil_li_pSOM = fClit_prot * ICsoil_li_SOM 
            ICsoil_li_uSOM = ICsoil_li_SOM - ICsoil_li_pSOM 
    
         !Accompanying the C flux of ICsoil_li_SOM is an N flux of:
            ONsoil_li_lig = OCsoil_li_lig / rCNlig
         !To provide the N needed to give the C/N ratios required
            !for new uSOM and pSOM material demands a total N flux of:
               ReqNsoil_li_lig_SOM = &
                    ICsoil_li_uSOM / rCNuSOMn + ICsoil_li_pSOM / rCNpSOMn
         !This requirement is partially met by release of N from lignin
            !of ONsoil_li_lig. The rest is taken from the Namm and Nnit pools
            !(together designated as Nmin) at a rate:
               ONmin_soil_li_SOM = ReqNsoil_li_lig_SOM - ONsoil_li_lig
            !This is divided between Namm and Nnit pools in the same ratio
            !in which biomass take Namm and Nnit 
            !(see microbial biomass section):
               ONamm_soil_li_SOM = fNamm_bio * ONmin_soil_li_SOM
               ONnit_soil_li_SOM = fNnit_bio * ONmin_soil_li_SOM
   
   
         !Differential equations (kg C m-2 day-1):
         !Metabolic (Csoil_li_met, Nsoil_li_met):
            DCsoil_li_met =  soilvr * ( ICsoil_li_met - OCsoil_li_met)
             Csoil_li_met =  INTEG( DCsoil_li_met, Csoil_li_met0 )
            DNsoil_li_met =  soilvr * ( INsoil_li_met - ONsoil_li_met)
             Nsoil_li_met =  INTEG( DNsoil_li_met, Nsoil_li_met0 )
         !Cellulose (Csoil_li_cel):
            DCsoil_li_cel =  soilvr * ( ICsoil_li_cel - OCsoil_li_cel)
             Csoil_li_cel =  INTEG( DCsoil_li_cel, Csoil_li_cel0 )
                !Nsoil_li_cel is not a state variables as the C/N ratio of the
                !cellulose pool is fixed, at rCNcel.
         !Lignin (Csoil_li_lig):
            DCsoil_li_lig =  soilvr * ( ICsoil_li_lig - OCsoil_li_lig)
             Csoil_li_lig =  INTEG( DCsoil_li_lig, Csoil_li_lig0 )
                !Nsoil_li_lig is not a state variable as the C/N ratio of the
                !lignin pool is fixed, at rCNlig.
   
      !Totals for soil litter are:
         Csoil_li = Csoil_li_met + Csoil_li_cel + Csoil_li_lig
         Nsoil_li = Nsoil_li_met + Csoil_li_cel / rCNcel &
                                 + Csoil_li_lig / rCNlig
         DCsoil_li = DCsoil_li_met + DCsoil_li_cel + DCsoil_li_lig
         DNsoil_li = DNsoil_li_met + DCsoil_li_cel / rCNcel &
                                   + DCsoil_li_lig / rCNlig
      
   !Surface and soil litter totals:
      IClitter = ICsurf_li + ICsoil_li 
      INlitter = INsurf_li + INsoil_li 
      DClitter = DCsurf_li + DCsoil_li 
      DNlitter = DNsurf_li + DNsoil_li 
   
   
   !Charcoal pool in soil, Char (kg C m-2).
      !Inputs (kg C m-2 day-1):
         IChar = ICtree_fire_Char + ICsurf_li_fire_Char
      !Outputs (kg C m-2 day-1): (none so far)
         OChar = zero
      !Differential equation (kg C m-2 day-1):
         DChar = soilvr * ( IChar - OChar )
          Char = INTEG( DChar, Char0 )
   
   
   !Soluble C (carbon substrate) in soil, Csol (kg C m-2).
      !Inputs (kg C m-2 day-1):
         !1. ICsurf_li_Csol, ICsoil_li_Csol, from the surface and soil litter
             !metabolic and cellulose pools.  See above.
         !2. ICfi_Csol (OCSfi_ex), root exudation of carbohydrate.  See above.
         !3. ICbioD_Csol, from dying microbial biomass.  See below.
         !4. ICuSOM_Csol, ICpSOM_Csol, ICsSOM_Csol, from decomposition of
             !the three (u, p, s) SOM pools.  See below.

         ICsol = ICsurf_li_Csol + ICsoil_li_Csol &
                 + ICfi_Csol + ICbioD_Csol + ICuSOM_Csol &
                 + ICpSOM_Csol + ICsSOM_Csol
   
      !Outputs (kg C m-2 day-1):
         !1. OCsol_bioG, required for soil microbial biomass growth.
         !2. OCsol_lch, leaching.
             OCsol_lch = kleach * Csol
             !See Water submodel section below for kleach.
         !3. OCsolR, a respiratory loss to the environment (This is
             !additional to the growth respiration component of OCsol_bioG
             !above (I'm not sure if this term is needed. It was put in to
             !stop Csol fluctuating too wildly. But maybe it is ok for Csol
             !to fluctuate wildly).
                      kCsolR = kCsolR20 * fTWsoil
             OCsolR = kCsolR * Csol

         OCsol = OCsol_bioG + OCsol_lch + OCsolR

      !Differential equation (kg C m-2 day-1):
         DCsol = soilvr * ( ICsol - OCsol )
          Csol = INTEG( DCsol, Csol0 )
   
   
   
   !Ammonium N, Namm pool (kg N m-2).
      !Inputs (kg N m-2 day-1):
         !1. INfi_Namm (ONSfi_ex), exudation of N by plant roots. See above.
         !2. INfix_Namm, N fixation by soil microbial biomass:
                          kNfix_bio = kNfix_bio20 * fTWsoil
             INfix_Namm = kNfix_bio * Cbio &
                          / (  ( 1 + KCsol_Nfix / Csol ) &
                             * ( 1 + Neff_bio / JNeff_bio_Nfix )  )
                          !proportional to biomass Cbio, Michaelis-Menten
                          !dependence on Csol, inhibited by soil 
                          !mineral N, Neff_bio.
         !3. INfert_Namm, fertilizer applications of ammonium N. 
            !The RSW functions below are referred to as UnitPulse functions in 
            !the book (Section 2.8.1).
            !The ACSL RSW (Real SWitch) function is defined as
            ! y = RSW( logical_expression, x1, x2).
                     !If logical_expression is true, y = x1.
                     !If logical_expression is false, y = x2.
             zNfert1_Nmin = &
                RSW( ( t .GE. tfert1 .AND . t .LT. tfert1plus1 ), one, zero )
             zNfert2_Nmin = &
                RSW( ( t .GE. tfert2 .AND . t .LT. tfert2plus1 ), one, zero )
             zNfert3_Nmin = &
                RSW( ( t .GE. tfert3 .AND . t .LT. tfert3plus1 ), one, zero )
             zNfert4_Nmin = &
                RSW( ( t .GE. tfert4 .AND . t .LT. tfert4plus1 ), one, zero )
             zNfert_Nmin = zNfert1_Nmin + zNfert2_Nmin + zNfert3_Nmin + &
                           zNfert4_Nmin !For output only.
             INfert_Namm1 = INfert1_Namm * zNfert1_Nmin + &
                            INfert2_Namm * zNfert2_Nmin + &
                            INfert3_Namm * zNfert3_Nmin + &
                            INfert4_Namm * zNfert4_Nmin
             INfert_Namm = s_fert * INfert_Namm1
                Constant s_fert = 0.0 !No fertilizer application by default.
                Constant INfert1_Namm = 0.05 !kg Namm N m-2 
                                             != 500 kg Namm N ha-1.
                Constant INfert2_Namm = 0.0, &
                         INfert3_Namm = 0.0, INfert4_Namm = 0.0  !kg N m-2.
                   !Single applications of 0.0 kg N m-2 ammonium
                   !fertilizer at times tfert2 to 4.
                Constant tfert1 = 5595, tfert2 = 1.0e20, tfert3 = 1.0e20, &
                    tfert4 = 1.0e20  !day.
                   !5595 !day. 15 * 365 = 5475.  5475 + 120 = 5595.
                         !Time of fertilizer application. 1 May in
                         !16th year.  5595 / 365 = 15 remainder 120 day.
                   !tfert2-4: set at 3 x e16 years.
             !the next 5 lines have been moved down from the Initial section
                    tfert1plus1 = tfert1 + one  ;  tfert2plus1 = tfert2 + one
                    tfert3plus1 = tfert3 + one  ;  tfert4plus1 = tfert4 + one
                    yfert1 = tfert1 / c365      ;  yfert2 = tfert2 / c365
                    yfert3 = tfert3 / c365      ;  yfert4 = tfert4 / c365
                    INTEGER iyfert1             ;  iyfert1 = tfert1 / c365 

         !4. INenv_Namm, ammonium N deposition from the atmosphere. See above.
         !5. INsurf_li_Namm, INsoil_li_Namm, inputs from surface and soil
             !litter pools. See above.
         !6. INbio_Namm, input from microbial biomass death. See below.
         !7. INSOM_Namm, mineral flux from SOM:
                INSOM_Namm = INuSOM_Namm + INpSOM_Namm + INsSOM_Namm
                !where INuSOM_Namm, INpSOM_Namm, INsSOM_Namm, are inputs
                !from decomposition of the three SOM pools. See below.
   
      !Outputs (kg N m-2 day-1):
         !1. ONamm_imm is the total immobilizing flux, with:
             ONamm_imm = ONamm_surf_li_SOM + ONamm_soil_li_SOM &
                         + ONamm_uSOM_sSOM + ONamm_pSOM_sSOM
               !ONamm_surf_li_SOM, ONamm_soil_li_SOM, immobilizing flux of N
                  !as surface and soil litter lignin with a high C/N ratio
                  !is converted into SOM with a low C/N ratio.  See above.
               !ONamm_uSOM_sSOM, ONamm_pSOM_sSOM, these are calculated as
                  !immobilizing fluxes of N (i.e. > 0 if immobilizing).      
                  !Depending
                  !on the C/N ratios in the SOM pools, they may be < 0, giving
                  !a mineralizing N flux which is input into the Namm and Nnit
                  !pools.  Normally, mineralizing N fluxes are input to the
                  !Namm pool alone. See below.
         !2. ONamm_bioG, required for soil microbial biomass growth. See below.
         !3. ONamm_nit, nitrification:
                ONamm_nit = knit * Cbio * Namm
                               knit = knit20 * fTWsoil
                !Nitrification losses:
                   !Assume that a fraction fnitrif of the nitrification
                      !ONamm_nit flux (above) is lost to the environment.
                      !Output to environment is:
                      ONamm_nitrif_env =  fnitrif * ONamm_nit   
                   !Input to Nnit nitrate pool is:
                      INamm_Nnit =  ONamm_nit - ONamm_nitrif_env
         !4. ONamm_vol, volatilization:
             ONamm_vol = kvol * Namm
                         kvol = kvol20 * fTWsoil
         !5. uNamm, uptake of ammonium N by roots and associated mycorrhiza.
             !This is calculated in plant submodel section above.

                 INlitter_Namm = INsurf_li_Namm + INsoil_li_Namm

                 INamm = INenv_Namm + INfert_Namm + INfi_Namm + INfix_Namm &
                         + INlitter_Namm &
                         + INbio_Namm + INSOM_Namm + INtree_fire_Namm &
                         + INsurf_li_fire_Namm 
                 ONamm = ONamm_imm + ONamm_bioG &
                         + ONamm_nit + ONamm_vol + ONamm_rt 

      !Differential equation (kg N m-2 day-1):
         DNamm = soilvr * ( INamm - ONamm )
          Namm = INTEG( DNamm, Namm0 )
   
   
   
   !Nitrate N, Nnit pool (kg N m-2)

      !Inputs (kg N m-2 day-1):
         !1. INfert_Nnit, fertilizer applications of nitrate N.
             INfert_Nnit1 = INfert1_Nnit * zNfert1_Nmin + &
                            INfert2_Nnit * zNfert2_Nmin + &
                            INfert3_Nnit * zNfert3_Nmin + &
                            INfert4_Nnit * zNfert4_Nmin
             INfert_Nnit = s_fert * INfert_Nnit1
               !Constant s_fert = 0.0 !No fertilizer application by default.
                Constant INfert1_Nnit = 0.0, INfert2_Nnit = 0.0, &
                         INfert3_Nnit = 0.0, INfert4_Nnit = 0.0  !kg N m-2.
                   !Single applications of 0.0 kg N m-2 nitrate
                   !fertilizer at times tfert1 to 4.
                !Constant tfert1 = 1.0e20, tfert2 = 1.0e20, tfert3 = 1.0e20,
                !   tfert4 = 1.0e20  !day.  Set above at 3 x e16 years.
         !2. INenv_Nnit, nitrate N deposition from the atmosphere (see above)
         !3. INamm_Nnit, nitrification flux from Namm into Nnit pool.
             !Calculated in Namm section above.
   
      !Outputs (kg N m-2 day-1):
         !1. ONnit_imm is the total immobilizing flux, with
             ONnit_imm = ONnit_surf_li_SOM + ONnit_soil_li_SOM &
                         + ONnit_uSOM_sSOM + ONnit_pSOM_sSOM
                !ONnit_surf_li_SOM, ONnit_soil_li_SOM, immobilizing flux of N
                   !as surface and soil litter lignin with a high C/N ratio
                   !is converted into SOM with a low C/N ratio. See above.
                !ONnit_uSOM_sSOM, ONnit_pSOM_sSOM, these are calculated as
                   !immobilizing fluxes of N (i.e. + if immobilizing).       
                   !Depending
                   !on the C/N ratios in the SOM pools, they may be -, giving
                   !a mineralizing N flux which is input into the Namm and Nnit
                   !pools.  Normally, mineralizing N fluxes are input to the
                   !Namm pool alone. See below.
         !2. ONnit_bioG, uptake by soil microbial biomass for growth.
            !See below.
         !3. uNnit, uptake of nitrate N by plant roots and mycorrhiza,
             !calculated in plant submodel section above.
         !4. ONnit_denit, output to denitrification:
             ONnit_denit = kdenit * Cbio * Nnit
                           kdenit = kdenit20 * fTWsoil * fdenitW
                                   !kdenit20, denitrification rate constant
                                   !at 20 C.
                              !kdenit20 = 0.01 (kg biomass C m-2)-1 day-1.
                              !fTsoil = soil temperature function.
                              !fWsoil = soil water function.
                              fdenitW = ( thetasoil / thetasoil_max) &
                                        ** qdenit   !qdenit = 20.
                                 !Denitrification is only active when soil is
                                 !anaerobic, and is quickly switched off when
                                 !soil water content thetasoil is below field
                                 !capacity thetasoil_max.  Maybe this should 
                                 !also depend on soil type/porosity.
          !5. ONnit_lch, leaching:
              ONnit_lch = kleach * Nnit
              !See Water submodel section below for kleach.
   
      !Differential equation (kg N m-2 day-1):
         DNnit = soilvr * ( INnit - ONnit )
          Nnit = INTEG( DNnit, Nnit0 )
                 INnit = INamm_Nnit + INenv_Nnit + INfert_Nnit
                 ONnit = ONnit_imm + ONnit_bioG &
                                   + ONnit_rt + ONnit_denit + ONnit_lch

      !Gross, net mineralization and immobilization   
      !Total gross mineralizing N flux from SOM only is INSOM_Namm (above).
      !Total gross immobilizing N flux is:
         ONmin_imm = ONamm_imm + ONnit_imm
      !Net mineralization:
         !Total gross SOM mineralization less total gross immobilization 
         !(not sure what this means):
            netSOM_minflux = INSOM_Namm - ONmin_imm         !kg N m-2 day-1.
   
   !Soil microbial biomass pool, Cbio (kg C m-2)
      !The biomass pool has a constant C/N ratio, rCNbio.  
   
      !Input from growth (kg C m-2 day-1):
         !Gross growth rate of microbial biomass:
            Gbio = ( Cbio **  qbio ) * kbioG !Failure caused if Cbio < 0,
                                         !accompanied by Namm, Nnit going < 0.
                                         !A solution is to halve maxt.
               kbioG = kbioG20 * fTWsoil * fCNbio * fbiomax
                        fCNbio = one / &
                                  ( ( one + KCbioG / Csol ) &
                                  * ( one + KNbioG / Neff_bio ) )
                           !Bisubstrate Michaelis-Menten dependence on C, N.
                           !N substrate is used from Namm and Nnit pools.
                           !Effective N substrate concentration is:
                           Neff_bio = Namm + cNbio * Nnit  !kg ammonium N m-2.
                        fbiomax = MAX( zero, zfbiomax ) 
                           zfbiomax = one - Cbio / ( fSOMbio * CSOM )
                           !The MAX is to stop fbiomax going negative
                           !if the initial value of Cbio is very high.
                           !A ceiling value is imposed on Cbio,
                           !equal to a fraction fSOMbio of the C in soil
                           !organic matter CSOM. fSOMbio = 0.05
            !C requirement for microbial biomass growth (kg C m-2 day-1):
               OCsol_bioG = Gbio / Ybio
                             !Ybio is the C yield of biomass growth.
            !Biomass growth respiration (kg C respired m-2 day-1):
               RbioG = ( one - Ybio ) * OCsol_bioG
            !N requirement for microbial biomass growth (kg N m-2 day-1):
               ONmin_bioG = Gbio / rCNbio
            !This is taken from the Namm and Nnit pools according to fractions:
               fNamm_bio = Namm / Neff_bio
               fNnit_bio = one - fNamm_bio
               !giving output fluxes from Namm and Nnit of:
                  ONamm_bioG = fNamm_bio * ONmin_bioG
                  ONnit_bioG = fNnit_bio * ONmin_bioG
   !CALL LOGD(.TRUE.)
   
      !Output to death (kg C m-2 day-1):
         !Death rate of microbial biomass:
            Dbio = kbioD * Cbio     
                    kbioD = kbioD20 * fTWsoil * fbiomin
                    fbiomin = MAX( zero, ( one - Cbiomin / Cbio ) )
                 !The MAX term stops fbiomin going negative if the
                 !initial value of Cbio is very small.
                 !fbiomin is to stop the microbial biomass being wiped out;
                 !Cbio cannot fall below a value of Cbiomin.
                 !Cbiomin = 0.001 kg C in microbial biomass m-2.
            !There are C and N output fluxes associated with biomass death:
               OCbio = Dbio;  ONbio = OCbio / rCNbio  !kg C, N m-2 day-1.
            !A fraction of the C flux is respired (kg C respired m-2 day-1): 
               RbioD = fCbioDR * OCbio
            !A fraction is returned to the Csol (soluble C) pool:
               ICbioD_Csol = fCbioD_Csol * OCbio
            !N associated with these two C fluxes is returned to Namm pool:
               INbioD_Namm = ( RbioD + ICbioD_Csol ) / rCNbio
            !leaving a N flux towards SOM of
               ONbio_SOM = ONbio - INbioD_Namm    
            !The remaining C flux of:
               ICbio_SOM = OCbio - RbioD - ICbioD_Csol 
               !enters the unprotected and protected SOM pools according to
               !clay content:
                  ICbio_uSOM = ICbio_SOM * fCbioD_uSOM
                  ICbio_pSOM = ICbio_SOM * fCbioD_pSOM
                  !These fractions are calculated in the initial section.
            !To produce this uSOM and pSOM with the specified C/N ratios
               !requires a N flux of
                  INbio_SOM = ICbio_uSOM / rCNuSOMn &
                               + ICbio_pSOM / rCNpSOMn
               !This is (generally) less than the N flux of ONbio_SOM
               !provided by the dying biomass, giving a flux into Namm of
                  INbioD_SOM_Namm = ONbio_SOM - INbio_SOM
   
            !Total N flux from microbial biomass into Namm is
               INbio_Namm = INbioD_Namm + INbioD_SOM_Namm 
   
      !Differential equation (kg C m-2 day-1):
         DCbio = ( soilvr + s_bio_alone ) * ( Gbio - Dbio ) 
                                            !Growth - death.
          Cbio = INTEG( DCbio, Cbio0 )
                  Constant s_bio_alone = 0
                     !To examine the growth of the biomass alone, with
                     !everything constant, set soilvr = 0, which keeps
                     !the substrate Namm, Nnit and Csol constant at
                     !their initial values. Also set s_bio_alone = 1.
                     !Set s_diurnal = s_seasonal = 0, Tairmaxmnz = Tairminmnz 
                     ! = Tsoilmnz = 20, which keeps temperature at 20 deg C.
                     !s_water = 0 switches off any water limitation.
   
   
   !Unprotected SOM, CuSOM, NuSOM (kg C, N m-2).
      !New material entering this pool has a C/N ratio rCNuSOMn depending on
      !soil mineral N Nmin, and given by:
         rCNuSOMn = rCNuSOMmax - ( rCNuSOMmax - rCNuSOMmin ) * &
                                  Nmin / ( Nmin + KrCNuSOM )
      
      !Inputs (kg C,N m-2 day-1):
         !ICbio_uSOM, input from biomass death, calculated under biomass
            !outputs.
         !ICsoil_li_uSOM, ICsurf_li_uSOM, inputs from soil and surface lignin
            !pools, are calculated in soil, surface litter outputs.
         !INuSOM, input of N to NuSOM:
            INuSOM = ICuSOM / rCNuSOMn  !rCNuSOMn is calculated above.
   
      !Outputs (kg C, N m-2 day-1):
         !OCuSOM_min to mineralization:
            OCuSOM_min = kuSOM_min * CuSOM
                         kuSOM_min = kuSOM_min20 * fTWsoil &
                                                 * m_kmin
         !OCuSOM_sSOM to stabilized SOM, sSOM:
            OCuSOM_sSOM = kuSOM_sSOM * CuSOM
                          kuSOM_sSOM = kuSOM_sSOM20 * fTWsoil
            !Both these outputs of C are partially respired, with fluxes
               !of C to respiration of (kg C respired m-2 day-1):
                  RuSOM_min =  fCuSOM_minR * OCuSOM_min
                  RuSOM_sSOM =  fCuSOM_sSOMR * OCuSOM_sSOM
            !Fluxes of C into the soluble C and sSOM pools are:
               ICuSOM_Csol = OCuSOM_min - RuSOM_min
               ICuSOM_sSOM = OCuSOM_sSOM - RuSOM_sSOM
         !Associated with the two C fluxes (to min and to sSOM) is a N flux:
            ONuSOM = OCuSOM / rCNuSOM
               !where the C/N ratio in uSOM is:
                  rCNuSOM = CuSOM / NuSOM
            !Flux of N to Namm is:
               INuSOM_Namm = ( OCuSOM_min + RuSOM_sSOM ) / rCNuSOM
   
         !Accompanying the C flux of ICuSOM_sSOM is a N flux of:
            ONuSOM_sSOM = ICuSOM_sSOM / rCNuSOM
               !To provide the N required for the C/N ratio
               !in new sSOM requires a total N flux of:
                  ReqNuSOM_sSOM = ICuSOM_sSOM / rCNsSOMn
         !This requirement is partially met by release of N from uSOM
         !of ONuSOM_sSOM. The rest is taken from the Namm and Nnit pools
         !at a rate (this may be positive or negative):
            ONmin_uSOM_sSOM = ReqNuSOM_sSOM - ONuSOM_sSOM
            !This is divided between Namm and Nnit pools in the same ratio
            !in which microbial biomass take Namm and Nnit:
               ONamm_uSOM_sSOM = fNamm_bio * ONmin_uSOM_sSOM
               ONnit_uSOM_sSOM = fNnit_bio * ONmin_uSOM_sSOM
            !Note: this is written as an immobilizing flux, taking N from
            !Namm and Nnit pools.  Depending on the C/N ratios in the SOM
            !pools, it may be negative, giving a mineralizing N flux,
            !which is input into Namm and Nnit pools.  Normally a
            !mineralizing N flux is put into the Namm pool alone.
   
      !Differential equation (kg C, N m-2 day-1):
         DCuSOM = soilvr * ( ICuSOM - OCuSOM )
          CuSOM = INTEG( DCuSOM, CuSOM0 )
                  ICuSOM = ICbio_uSOM + ICsoil_li_uSOM + ICsurf_li_uSOM 
                  OCuSOM = OCuSOM_min + OCuSOM_sSOM
         DNuSOM = soilvr * ( INuSOM - ONuSOM )
          NuSOM = INTEG( DNuSOM, NuSOM0 )

   !Protected SOM, CpSOM, NpSOM (kg C, N m-2).
      !New material entering this pool has a C/N ratio, rCNpSOMn, given by:
         rCNpSOMn = rCNpSOMmax - ( rCNpSOMmax - rCNpSOMmin ) * &
                    Nmin / ( Nmin + KrCNpSOM )
   
      !Inputs (kg C, N m-2 day-1):
         !ICbio_pSOM is input from biomass death.  See biomass outputs (above).
         !ICsoil_li_pSOM, ICsurf_li_pSOM are calculated in surface,
            !soil litter outputs above.
         !INpSOM is the total N input:
            INpSOM = ICpSOM / rCNpSOMn  !See above for rCNpSOMn.
   
      !Outputs (kg C, N m-2 day-1):
         !OCpSOM_min to mineralization:
             OCpSOM_min = kpSOM_min * CpSOM
                          kpSOM_min = kpSOM_min20 * fTWsoil &
                                                 * m_kmin * m_kmin_fire
         !OCpSOM_sSOM to stabilized SOM, sSOM:
             OCpSOM_sSOM = kpSOM_sSOM * CpSOM
                           kpSOM_sSOM = kpSOM_sSOM20 * fTWsoil
            !Both these outputs of C are partially respired, with fluxes
               !of C to respiration of (kg C respired m-2 day-1):
                  RpSOM_min =  fCpSOM_minR * OCpSOM_min
                  RpSOM_sSOM =  fCpSOM_sSOMR * OCpSOM_sSOM 
            !Fluxes of C into the soluble C and sSOM pools are:
               ICpSOM_Csol = OCpSOM_min - RpSOM_min
               ICpSOM_sSOM = OCpSOM_sSOM - RpSOM_sSOM
         !Associated with the two C fluxes (to min and to sSOM) is a N flux:
            ONpSOM = OCpSOM / rCNpSOM
               !where the C/N ratio in pSOM is:
                  rCNpSOM = CpSOM / NpSOM
            !Flux of N to Namm is:
               INpSOM_Namm = ( OCpSOM_min + RpSOM_sSOM ) / rCNpSOM
   
         !Accompanying the C flux of ICpSOM_sSOM is an N flux of:
            ONpSOM_sSOM = ICpSOM_sSOM / rCNpSOM
               !To provide the N needed for the C/N ratio (depends on Nmin)
               !in new sSOM requires a total N flux of:
                  ReqNpSOM_sSOM = ICpSOM_sSOM / rCNsSOMn
         !This requirement is partially met by release of N from pSOM
         !of ONpSOM_sSOM. The rest is taken from the Namm and Nnit pools
         !at a rate (this may be positive or negative):
            ONmin_pSOM_sSOM = ReqNpSOM_sSOM - ONpSOM_sSOM
            !This is divided between Namm and Nnit pools in the same ratio
            !in which microbial biomass take Namm and Nnit:
               ONamm_pSOM_sSOM = fNamm_bio * ONmin_pSOM_sSOM
               ONnit_pSOM_sSOM = fNnit_bio * ONmin_pSOM_sSOM
            !Note: this is written as an immobilizing flux, taking N from
            !Namm and Nnit pools.  Depending on the C/N ratios in the SOM
            !pools, it may be negative, giving a mineralizing N flux,
            !which is input into Namm and Nnit pools.  Normally a
            !mineralizing N flux is put into the Namm pool alone.
   
      !Differential equations (kg C, N m-2 day-1):
         DCpSOM = soilvr * ( ICpSOM - OCpSOM )
          CpSOM = INTEG( DCpSOM, CpSOM0 )
                  ICpSOM = ICbio_pSOM + ICsoil_li_pSOM + ICsurf_li_pSOM
                  OCpSOM = OCpSOM_min + OCpSOM_sSOM
   
         DNpSOM = soilvr * ( INpSOM - ONpSOM )
          NpSOM = INTEG( DNpSOM, NpSOM0 )
           
      
   !Stabilized SOM, CsSOM, NsSOM (kg C, N m-2).
      !New material entering this pool has a C/N ratio, rCNsSOMn, given by:
         rCNsSOMn = rCNsSOMmax - ( rCNsSOMmax - rCNsSOMmin ) * &
                    Nmin / ( Nmin + KrCNsSOM )
   
      !Inputs (kg C, N m-2 day-1):
         !ICuSOM_sSOM is calculated as an output of the uSOM pool.
         !ICpSOM_sSOM is calculated as an output of the pSOM pool.
         !INpSOM is the total N input:
            INsSOM = ICsSOM / rCNsSOMn  !See above for rCNsSOMn.
   
      !Outputs (kg C, N m-2 day-1):
         !C output to mineralization:
            OCsSOM_min = ksSOM_min * CsSOM
                         ksSOM_min = ksSOM_min20 * fTWsoil &
                                                 * m_kmin * m_kmin_fire
         !This output of C is partially respired, with flux
         !of C to respiration of:
            RsSOM_min =  fCsSOM_minR * OCsSOM_min
         !The flux of C into the soluble C pool is:
            ICsSOM_Csol = OCsSOM_min - RsSOM_min
         !C/N ratio in sSOM pool is:
            rCNsSOM = CsSOM / NsSOM
         !Flux of N from sSOM to Namm is:
            ONsSOM_Namm = OCsSOM_min / rCNsSOM 
            INsSOM_Namm = ONsSOM_Namm
   
   
      !Differential equations (kg C, N m-2 day-1):
         DCsSOM = soilvr * ( ICsSOM - OCsSOM_min )
          CsSOM = INTEG( DCsSOM, CsSOM0 )
                  ICsSOM = ICuSOM_sSOM + ICpSOM_sSOM
         DNsSOM = soilvr * ( INsSOM - ONsSOM_Namm )
          NsSOM = INTEG( DNsSOM, NsSOM0 )
   

   !Totals for soil and litter submodel
      !Total SOM (not a state variable):
      !C content of SOM:
          CSOM =  CuSOM +  CpSOM +  CsSOM   !kg C m-2.
                  CSOMe4 = c10000 * CSOM    !kg C ha-1. Output only.
         DCSOM = DCuSOM + DCpSOM + DCsSOM   !kg C m-2 day-1.
      !N content of SOM:
          NSOM =  NuSOM + NpSOM + NsSOM     !kg N m-2.
                  NSOMe4 = c10000 * NSOM    !kg N ha-1. Output only.
         DNSOM = DNuSOM + DNpSOM + DNsSOM   !kg N m-2 day-1.
      !C/N ratio of SOM:
         rCNSOM = CSOM / NSOM  !kg C / kg N.
   
      !Total surface litter C, N,  soil litter C, N:
         ! Csurf_li,  Nsurf_li,     Csoil_li,  Nsoil_li (kg C, N m-2).
         !DCsurf_li, DNsurf_li,    DCsoil_li, DNsoil_li (kg C, N m-2 day-1).
            !These are calculated in the Surface and Soil litter sections.
         !Total litter C and N (kg C, N m-2):
            Clitter = Csurf_li +  Csoil_li
            Nlitter = Nsurf_li +  Nsoil_li
            IF ( Nlitter .NE. zero ) THEN
               rCNlitter = Clitter / Nlitter
            ELSE
               rCNlitter = clarge
            ENDIF
   
      !Total mineral N in soil, Nmin:
          Nmin =  Namm +  Nnit    !kg N m-2.
                  Nmine3 = c1000 * Nmin !g N m-2.
         DNmin = DNamm + DNnit    !kg N m-2 day-1.
   
      !Soil C and N (including litter):
         CliSOM =  Clitter + CSOM                            !kg C m-2.
         Csoil =   Clitter + Char + Csol +  Cbio +  CSOM     !kg C m-2.
        DCsoil =  DClitter + DChar + DCsol + DCbio + DCSOM   !kg C m-2 day-1.
         NliSOM =  Nlitter + NSOM                            !kg N m-2.
         Nsoil =   Nlitter + Nmin +  Cbio / rCNbio +  NSOM   !kg N m-2.
        DNsoil =  DNlitter + DNmin + DCbio / rCNbio + DNSOM  !kg N m-2 day-1.
   
      !Inputs of C and N into soil including litter (kg C, N m-2 day-1):
         !Plant to soil:
            ICtree_soil = IClitter + ICfi_Csol + ICtree_fire_Char
           !INtree_fire_Namm   See above.
            INtree_soil = INlitter + INfi_Namm + INtree_fire_Namm
         !Environment (and management) to soil:
            !ICenv_so = 0  No C input from environment to soil.
            INfert_Nmin = INfert_Namm + INfert_Nnit
            INenv_Nmin = INenv_Namm + INenv_Nnit
            INenv_soil = INfix_Namm + INfert_Nmin + INenv_Nmin
      !Total inputs to soil:
         ICsoil = ICtree_soil
         INsoil = INtree_soil + INenv_soil
   
      !Outputs of C and N from soil including litter (kg C, N m-2 day-1):
         !Soil to plant:
            !OCso_pl = 0  No C uptake by root.
            !ONsoil_fi.     Total N uptake by fine roots.
      !Outputs of C, N from Soil and Litter submodel to environment
           !(kg C, N m-2 day-1):
              !Soil and litter respiration: 
              Rsoil = Rsurf_li + Rsoil_li + OCsolR + RbioG &
                               + RbioD + RuSOM_min + RuSOM_sSOM &
                               + RpSOM_min + RpSOM_sSOM + RsSOM_min 
           OCsoil_env = Rsoil + OCsol_lch + OCsurf_li_fire_atm
           ONsoil_env = ONamm_vol + ONamm_nitrif_env + ONnit_lch &
                                  + ONnit_denit + ONsurf_li_fire_atm
                    !volatilization, nitrification, leaching, denitrification.
      !Total outputs from soil:
         OCsoil = OCsoil_env                 !kg C m-2 day-1.
         ONsoil = ONsoil_fi + ONsoil_env     !kg N m-2 day-1.
   
      !C check:
         DCsoil_chk = ICsoil - OCsoil
        !DCsoil should be equal to DCsoil_chk.
      !N check:
         DNsoil_chk = INsoil - ONsoil
        !DNsoil should be equal to DNsoil_chk.
      !Water check:
        !IWsoil, OWsoil are the input and output fluxes.
        !DWsoil
         DWsoil_chk = IWsoil - OWsoil  !This should be equal to DWsoil.
      ! All 6 ok under self-thinning.
!End of SOIL AND LITTER SUBMODEL



!WATER SUBMODEL
   !If s_water (water switch) = 0, then the water model has no effect on
      !the tree and soil submodels.
      !Note that leaching (ONnit_lch) continues, unless leaching is turned off,
         !by setting the switch s_leach = 0.0. 
      !Note however that the tree variables (e.g. leaf area
      !index, root density) still affect the water dynamics
      !and the water submodel still runs, with the tree water state
      !variables, Wi, i = le, br, st, co, fi, and Wsoil changing.
      !The default value of s_water is:
      Constant s_water = 1
   
   !If watervr = 0 (default value is 1), then the Wi and Wsoil stay
      !at their initial values.   
       Constant watervr = 1


   !The water submodel requires the following variables 
   !from the tree/stand growth submodel:
      !gcan          m s-1 (m2 ground)-1.               Canopy conductance.
      !hcan          m.                                   Height of canopy.
      !LAI           m2 leaf (m2 ground)-1.                Leaf area index.
      !For i = le, br, st, co, fi,  foliage, branches, stem, coarse roots,
      !fine roots:
         !MCSi,      kg C substrate stem-1.
         !MNSi,      kg N substrate stem-1.
         !MSitot     kg storage (C & N substrates) dry matter stem-1.
         !MXi,       kg structural DM stem-1. 
      !nstems        number of stems m-2.                    Stand density.
      !rort          kg root structural DM (m3 soil)-1.       Root density.  

   
   !TABLES of temperature-dependent parameters of Penman-Monteith
      !equation and other expressions. See Thornley and Johnson, 
      !1990, page 408.
      !The data values at temperature = -5 deg C was inserted by JHMT
      !by extrapolation.
            
      !Density (ro) of Saturated Water Vapour (kg water m-3) at temperature T:
      Table roSatWVap_Table, 1, 10 /&
      -5,       0,       5,       10,      15,      20,      25, &
               30,      35,       40, &
       3.7e-3,  4.9e-3,  6.8e-3,  9.4e-3,  12.8e-3, 17.3e-3, 23.1e-3, &
               30.4e-3, 39.7e-3, 51.2e-3 /
            
      !Saturated Water Vapour Pressure (Pa) at temperature T:
      Table SatVapP_Table, 1, 12 /&
      -10,     -5, &
                0,       5,       10,      15,      20,      25, &
               30,      35,       40,      45, &
       286,     421, &
                611,     872,      1227,    1704,    2337,    3167, &
               4243,    5624,     7378,    9586 /
      
      !DroSatWVapDT = d(roSatWVap)/dT at temperature T (kg m-3 K-1):
         !See below for roSatWVap.
      Table DroSatWVapDT_Table , 1, 10 /&
       -5,     0,       5,       10,      15,      20,      25,      &
              30,      35,       40, &
      0.24e-3, 0.33e-3, 0.45e-3, 0.60e-3, 0.78e-3, 1.01e-3, 1.30e-3, &
               1.65e-3, 2.07e-3, 2.57e-3 /
               
      !Latent heat of vapourization of water at temperature T (J kg-1):
      Table LatentHeat_Table, 1, 10 /&
       -5,      0,      5,     10,     15,     20,     25,     &
               30,     35,     40, &
       2.51e6, 2.50e6, 2.49e6, 2.48e6, 2.47e6, 2.45e6, 2.44e6, &
               2.43e6, 2.42e6, 2.41e6 /
      
      !Psychrometric parameter at temperature T (kg m-3 K-1):
      Table gammapsych_Table, 1, 10 /&
      -5,        0,        5,        10,       15,       20, &
                25,       30,        35,       40, &
       0.527e-3, 0.521e-3, 0.515e-3, 0.509e-3, 0.503e-3, 0.495e-3, &
                 0.488e-3, 0.482e-3, 0.478e-3, 0.474e-3 /
   
      !Density (ro) of dry air at temperature T (kg m-3) (not currently used):
      Table rodryair_Table, 1, 10 /&
      -5,       0,       5,       10,      15,      20,      25, &
               30,      35,       40, &
       1.31,    1.29,    1.27,    1.25,    1.23,    1.20,    1.18, &
                1.16,    1.15,    1.13 /
   
      !Single surface radiation resistance at temperature T (m-1 s):
      Table rrad1_Table, 1, 10 /&
      -5,       0,       5,       10,      15,      20,      25, &
               30,      35,       40, &
     303,     282,     263,     245,     229,     212,     198, &
              185,     175,     164 /
   
      !Specific heat of dry air at constant pressure at 20 deg C (it varies
         !little with temperature over the temperatures considered here).
         !Constant Cpdryair20 = 1010 !J kg-1 K-1.  Not used.

      !Look up s, LatentHeat, gammapsych, roSatWVap and
         !the two-surface radiation resistance rrad2 in tables:
         DroSatWVapDT = DroSatWVapDT_Table ( Tair ) !kg m-3 K-1. 
               !DroSatWVapDT = d(roSatWVap)/dT at temperature T.
         LatentHeat = LatentHeat_Table ( Tair )           !J (kg water)-1.
         gammapsych = gammapsych_Table ( Tair ) !kg m-3 K-1.
                                 !Psychrometric parameter at temperature T.
         roSatWVap = roSatWVap_Table ( Tair )                !kg water m-3.
                    !Density (ro) of Saturated Water Vapour at Tair.
         rrad2 = half * rrad1_table ( Tair ) !m-1 s. For 2 surfaces, acting 
            !in parallel, we halve the single-surface radiation resistance.
         grad2 = one / rrad2 !m s-1.  Radiation conductance.
      !Saturated vapour pressure of water vapour at temperature Tair:
         SatVapP = roSatWVap * RgasTairK / rmmW                 !Pa.
            Constant rmmW = 18.015 !Relative molecular mass of water, H2O.

!Soil water content, Wsoil (kg water m-2). 
   !Input to the soil:
      IWsoil = rain + IWth_Wsoil + IWbud_prune_Wsoil &
                    + IWle_prune_Wsoil + IWfi_prune_Wsoil &
                    + IWle_lf_Wsoil + IWfi_fire_Wsoil   !kg water m-2 day-1.
   !Initial output of water from soil (without drainage):
         OWsoil0 = OWso_fi + OWrain_int + OWso_atm      !kg water m-2 day-1.
   !Initial net input to the soil:
         IWsoilnet = IWsoil - OWsoil0                   !kg water m-2 day-1.
   
      !Either:
         IF (thetasoil .LT. thetasoil_max) THEN
             !Soil is below field capacity (FC):
                DWsoil = watervr * IWsoilnet !is the rate at which Wsoil 
                                             !increases, or decreases if 
                OWso_drain = 0               !IWsoilnet is negative, and there
                                             !is no drainage.
      !Or:
         ELSE    !Soil is at, or marginally above FC:
            IF (IWsoilnet .LT. zero) THEN
                 !but the initial net flux into the soil water pool
                 !is negative:
                  DWsoil = watervr * IWsoilnet !is the rate at which Wsoil 
                                               !decreases as
                  OWso_drain = 0               !IWsoilnet is negative, and
                                               !there is no drainage.
            ELSE !Soil is at, or marginally above FC, and the initial net 
                 !flux into the soil water pool is positive:
                  DWsoil = 0                           !kg water m-2 day-1.
                  OWso_drain = IWsoilnet               !kg water m-2 day-1.
            ENDIF
         ENDIF


   !Now the actual output from the soil is:
      OWsoil = OWsoil0 + OWso_drain 

   !Integration statement:
      Wsoil = INTEG( DWsoil,  Wsoil0 )     !kg water m-2.
          !Wsoil0 is calculated from thetasoil_max (the maximum value 
          !of soil water capacity) in the Initial section.

   !Input:
      !Rainfall in kg water m-2 day-1, rain.
!CALL LOGD(.TRUE.)
   !Outputs: 
      !1, OWso_fi, water flow from soil to fine roots and mycorrhiza
               !Resistance between soil and surface of fine roots is
                  rWso_fisurf = m_wresistances * &
                                kso_fisurf * rort / ( gsoilW * MXfi_gnd )
                                                          !m4 kg-1 d/s s-1.
                                Constant m_wresistances = 1
                               !Multiplier of water resistances.
               !Resistance between fine roots surface and the fine roots
                  !internally is
                   rWfisurf_fi = m_wresistances * &
                                 kfisurf_fi * ( MXfi_gnd + KMXfi_gnd ) / &
                                 ( rort * MXfi_gnd )     !m4 kg-1 d/s s-1. 
               !rWso_fi, resistance between the soil and fine roots and
                     !mycorrhiza internally is obtained by adding these:
                  rWso_fi = rWso_fisurf + rWfisurf_fi   !m4 kg-1 d/s s-1. 
               !Quantities used here are
                  !rort = density of root and mycorrhizal
                     !structural dry mass.  !kg structural DM m-3 soil.
                   !MXfi_gnd = root and mycorrhizal structural
                     !dry mass per unit ground area.        kg XDM m-2.
                   Constant kso_fisurf = 100000  !was 80 m2.
                      !Soil to root surface resistance parameter.
                      !This is the value used in the Hurley Pasture
                      !Model.  See eqns 15.11b and 15.12d of
                      !Thornley and Johnson 1990.  But compare to
                      !p. 544 of Johnson, M. T and R PC and E paper
                      !vol 14, 531-44, 1991; who use kso_fisurf = 5.
                      !Ian J could not tell me why.
                   !gsoilW                                    kg m-3 s/d s.
                      !Hydraulic conductivity of soil (variable),
                      !calculated below.
                   Constant kfisurf_fi = 5.0                        !m d-1.
                      !Root surface to fine roots and mycorrhiza
                      !resistance parameter. 
                   Constant KMXfi_gnd = 1            !kg structural DM m-2.
                      !Root surface to fine roots and mycorrhiza
                      !resistance parameter.
       OWso_fiz = ( psisoil - psifi ) / rWso_fi        !kg water m-2 day-1.
                    !psisoil, psifi = soil, and fine roots and mycorrhiza
                    !water potentials [(J (kg water)-1].
                    !See below for psisoil.
                    !See Fine roots and Mycorrhiza section for psifi.
       !OWso_fi = half * ( OWso_fiz + ABS( OWso_fiz ) )  !kg water m-2 day-1.
                   !This ensures that the water flux from the soil to fine
                   !roots and and mycorrhiza is positive.
        OWso_fi = OWso_fiz  !I think the above statement can making psile
                            !blow up.
       IWtree = OWso_fi  !kg water m-2 day-1.  Put into standard notation.
                   !Input of water to tree.
   
      !2, OWrain_int, flux of water from foliage to atmosphere due to rainfall
           !interception and direct evaporation from leaves
           !(kg water m-2 day-1): 
               !Fraction of rain intercepted:
                  frain_int =  one_exp_kcanLAI
               !Fraction of intercepted rain that then evaporates:           
                  !is frain_int_evap which can be assigned different
                  !empirical values in each month:
                     frain_int_evapz = frain_int_evap( imonth )
                   ARRAY frain_int_evap(12)
                   Constant frain_int_evap = &
                             0.2, 0.3, 0.4,  0.6, 0.7, 0.8, &
                             0.8, 0.7, 0.6,  0.4, 0.3, 0.2
                   !Fraction of rainfall intercepted by foliage which
                   !evaporates in months 1 (Jan) - 12 (Dec).
               !Fraction of rain evaporating from canopy, frain_evap_can, is
                  frain_evap_can = frain_int * frain_int_evapz
                  ! = (fraction intercepted) * 
                  !   (fraction of intercepted fraction that evaporates).
        OWrain_int = rain * frain_evap_can 
  
     !3, OWso_atm, flux of water from soil to atmosphere by direct evaporation
        !from the soil surface:
         Constant OWso_atm = 0.0                   !kg water m-2 day-1.
           !Put this to zero for a reasonable 1st approximation. There is 
           !much litter in forests.
!Next bit is made non-operative.
!       OWso_atm = fsodry * FWsad0 
!            FWsad0 = FWradso + FWvdgso 
!                     fsodry = ( thetasoil / thetasoil_maxp ) ** qsode
                    !Increasing soil dryness reduces direct
                    !evaporation from the soil.
!                     Constant qsode = 2       !Dimensionless
           !Radiation-driven term:
!            FWradso =  DroSatWVapDT * jNetRdyabso / &
!                     ( LatentHeat * ( DroSatWVapDT + gammapsych ) )
           !Vapour-density gradient driven term:
!            FWvdgso =  half * ( FWvdgsoz + ABS( FWvdgsoz ) )  
!            FWvdgsoz = c86400 &
!                        * LatentHeat * gammapsych * gBoundaryLayerso * &
!                       ( roSatWVap - roWvap_atm ) &
!                       / ( LatentHeat * ( DroSatWVapDT + gammapsych ) )
           
           !Boundary-layer conductance to soil surface:
!            gBoundaryLayerso = cgBoundaryLayerso * gBoundaryLayer
!              Constant cgBoundaryLayerso = 0.5 !A multiplier.
   
           !Net radiation absorbed by soil: 
!              jNetRdyabso = jNetRsc * fNRabso  !J m-2 day-1.
   
           !Fraction of net radiation absorbed by soil:
!              fNRabso = ( one - ref_soil ) * exp( - kcanLAI )  
!                 Constant ref_soil = 0.05 !Reflectivity of soil.
   


!Soil attributes
   !Drainage rate:
      drain = OWso_drain / roW                                    !m day-1.
   !Leaching rate:
      kleach = s_leach * drain / thetasoil_max                    !day-1.
                        !drain = drainage (m day-1).
                        !We use maximum soil relative water content,
                        !thetasoil_max, because drainage only occurs
                        !when soil is at field capacity. This assumes that
                        !Nnit (kg m-2) is dissolved in a depth of water of
                        !thetasoil_max (m).  This is the amount of water
                        !in 1 m3 of soil at field capacity.
               Constant s_leach = 1 !to switch leaching off, set s_leach = 0.

   !Soil relative water content:
      thetasoil = Wsoil / ( roW * dsoil )           !m3 water (m3 soil)-1.

   !Soil water potential [J (kg water)-1]:
      psisoil = psisoilmax * ( thetasoil_max / thetasoil ) ** qpsi_soW
       Constant psisoilmax = - 10 !J kg-1, equivalent to 10 kPa suction.
                                  !Water potential of soil at field capacity.

       Constant qpsi_soW = 5      !A dimensionless parameter of the soil 
                                  !water characteristic.

   !Soil hydraulic conductivity:
      gsoilW = gsoilWmax * ( thetasoil / thetasoil_max ) ** qgsoilW 
         Constant gsoilWmax = 10000.0                     !kg m-3 s/d s.
           !Maximum value of soil hydraulic conductivity characteristic
           !occurring when thetasoil (soil water content) = thetasoil_max
           ! (maximum value of thetasoil).  The usual units of shc are
           !kg m-3 s (see Thornley, 1998, Grassland Dynamics, CABI. p 124),
           !relate to mass of water (kg) moved per unit time (s) per unit 
           !area (m2) per unit water potential gradient ([J kg-1 m-1]-1).
           !This needs multiplying by the number of s in 1 day, to give
           !the amout of water moved per day.
         Constant qgsoilW = 8 !Dimensionless.
           !It is usual to put qgsoilW = qpsi_soW + qpsi_soW + 3 = 13.
           !We have tried this, but this is far too strong a
           !dependence on thetasoil, since we have approximated the soil
           !by a single horizon, and soil heterogeneity decreases the
           !effective value of qgsoilW (with respect to what it would be
           !in a homogeneous soil.

   !Soil water activity:
      aWsoil1 = exp ( rmmW * psisoil / ( c1000 * Rgas * TsoilK ) )
      aWsoil = MIN( aWsoil1, one )  !Problems may ensue when psisoil > 0.

              !Constant rmmW = 18.015    !Dimensionless. 
                  !Relative molecular mass of water, H2O.
                  !Also equals molar mass of water 18 g (SI g mole)-1,
                  !or 18 kg (kg mole)-1.
               Constant Rgas = 8.31441  ! J K-1 (mol)-1. Gas constant.
                  !The mole is an (SI) g mole = a "gram molecule".
                  !See The Royal Society 1975
               Constant Vmol_stp = 0.0224136 ! m3 (g mole)-1,
                  ! equivalent to 22.4136 ! (decimetre)**3 (g mole)-1
                  !               22.4136 ! Litre (g mole)-1,
                  ! as 1 Litre = 1000 cm**3
               Constant Vmol_STPlitre = 22.4136 ! Litres (g mole)-1,


!Fine root and mycorrhiza water pool, Wfi (kg water stem-1).

   !Input:
       IWso_fi = OWso_fi / nstems   !kg water stem-1 day-1.
                !OWso_fi, flux of water from soil to fine roots and
                !mycorrhiza, in units of kg water m-2 day-1,
                !is calculated in the Soil Water section above.
   
   !Output, OWfi_Wle (kg water stem-1 day-1), is the flux of water from
               !fine roots (fi) to foliage (le):
      IF ( MXle .GT. c1E_14 ) THEN
         OWfi_Wle = s_leaf * ( psifi - psile ) / rWfi_st_le  
                        !s_leaf is a switch
                        !in case no leaves are present.
         OWfi_Wle_gnd = OWfi_Wle * nstems               !kg water m-2 day-1.
      ELSE
         OWfi_Wle = zero
         OWfi_Wle_gnd = zero
      ENDIF
         IWfi_Wle = OWfi_Wle !For consistency of notation.

   !Output to self-thinning:
      OWfi_sn = FGRnstems_sn * Wfi

   !Differential equation:
               IWfi = IWso_fi
               OWfi = OWfi_Wle + OWfi_sn + OWfi_bud + OWfi_prune + OWfi_fire
       DWfi =  watervr * ( IWfi - OWfi )
        Wfi =  INTEG( DWfi, Wfi0 )
            DWfimaxt = DWfi * maxt !For debugging. Not used elsewhere.
   
   !Osmotic potential:
        rMSfiWfi = MSfi / Wfi !Ratio of 
            !Total fine roots and mycorrhiza substrate dry matter
            !MSfi = ( MCSfi * rmmCS12 + MNSfi * rmmNS14 ) 
            !Wfi (kg fine roots water stem-1)


        psiOfi = - c1000 * Rgas * TsoilK * fSos_ac * rMSfiWfi / rmm_osm
                   Constant fSos_ac = 1  !Dimensionless. Fraction of tree
                            !substrate material which is osmotically active.
                   Constant rmm_osm = 40 !Dimensionless. Mean relative
                            !molecular mass of osmoticum.
         !Substrate C transport resistance between coarse roots (co) 
            !and fine roots and mycorrhiza (fi):
            !rCcofi = rCco + rCfi  !stem day (kg XDM)-1.

   
   !Pressure potential: 
                                  z1psfP = cpsiPr * Wfi / MXfitot
                         z2psfP = z1psfP - 1.0
      psiPfi = epsilon * z2psfP / roW
               Constant epsilon = 0.5e6 !Pa. Cell Young's modulus.
               Constant cpsiPr = 0.2  !kg tree structure (kg water)-1.
                        !Constant in tree pressure potential characteristic.
   
   !Gravitational potential, psiGfi:
      !Height of fine roots and mycorrhiza is:
                         hfi = rfi_hcan * hcan  !m.
      psiGfi = gravity * hfi
            Constant rfi_hcan = - 0.2 !m m-1.
               !Ratio of fine root height to canopy height.
            !Constant gravity = 9.81 !m s-2.  Acceleration due to gravity.
   
   !Total water potential:
      psifi = psiOfi + psiPfi + psiGfi   
   
   !Water activity, aWfi:
      aWfi1 = EXP ( rmmW * psifi / ( c1000 * Rgas * TsoilK ) )
      aWfi = MIN( aWfi1, one )  !Problems may ensue when psifi > 0.
   
!Stem.
   !Resistance to water (W) transport from fine roots (fi) via stem (st), 
   !to the foliage (le), is
   !Resistance, rWfi_st_le [ J (kg water)-1 {(kg water stem-1) day-1}-1]
   ! = e.g.                  voltage per      unit current.
      MXfiqW = MXfim ** qroWfi          !(kg XDM stem-1)**qroW.
      MXstqW = MXstm ** qroWst          !(kg XDM stem-1)**qroW.
      MXleqW = MXle  ** qroWle          !(kg XDM stem-1)**qroW.
         Constant qroWfi = 1.0  !Geometric scaling factors of conductance
         Constant qroWst = 1.0  !to mass.
         Constant qroWle = 1.0

      !Inverses, proportional to resistances.
         iMXfiqW = one / MXfiqW !Small mass, low conductance, high resistance.
         iMXstqW = one / MXstqW
         IF ( s_leaf .EQ. one ) THEN
               iMXleqW = one / MXleqW
         ELSE
               iMXleqW = clarge
         ENDIF                   !(kg XDM stem-1)**-qroW.

      !Resistances  [J (kg water)-1] day (kg water stem-1)-1:
         rWfi = m_wresistances * roWfi20 * iMXfiqW
         rWst = m_wresistances * roWst20 * iMXstqW
         rWle = m_wresistances * roWle20 * iMXleqW
      !Water transport resistivities associated with fine roots, stem, 
         !and leaves, le.  Not sure about the dimensions of these.
         Constant roWfi20 = 10.0   ![J (kg water)-1] day (kg water stem-1)-1
         Constant roWst20 = 10.0   !(kg water-conducting XDM stem-1)**qroW.
         Constant roWle20 = 10.0   !roW??20 is a resistivity constant.
         !Water transport resistances do not depend on temperature or water
         !content.

      !Add up the resistances:
         IF ( s_deciduous .EQ. zero ) THEN
            rWfi_st_le = rWst    ![J (kg water)-1] day (kg water stem-1)-1.
         ELSE
!            rWfi_st_le = rWfi + rWst + rWle
            rWfi_st_le = rWfi + rWst
!            rWfi_st_le = rWst 
         ENDIF
         rWfi_st_le_gnd = rWfi_st_le / nstems   
                              !J (kg water)-1 (kg water)-1 m2 day
                              ! = m4 kg-1 (d/s) s-1.
                              !This is per unit of ground area, and now can
                              !be compared directly with the soil to root
                              !resistances (see rWso_fi).  


!Foliage (leaf) water pool, Wle (kg water stem-1).
   
   !Differential equation:
               IWle = IWfi_Wle + IWbud_Wle              !kg W stem-1 day-1.
               OWle = OWle_atm + OWle_sn + OWle_prune + OWle_lf + OWle_fire
                      !Note: we have no water flux with leaf litter:
                      !OWle_li = s_Wle_li * rWXlec * OXle4_li
                      !Constant s_Wle_li = 0 
                      !We tried this, but it makes no difference.

       DWle =  watervr * ( IWle - OWle ) 
      
        Wlez =  INTEG( DWle, Wle0 )
        Wle = ABS ( Wlez ) !Sometimes, at leaf fall, Wlez may become 
                           !small and negative, about - 1.0E19.
   
   !Input:
      !OWfi_Wle (kg water stem-1 day-1);
            !the flux of water from the fine roots to the stem
            !is calculated in above.

   !Output to self-thinning (kg water stem-1 day-1):
      OWle_sn = FGRnstems_sn * Wle  !?? switch off if s_leaf = 0.

   !Output, OWle_atm (kg water stem-1 d-1):
       OWle_atm = OWle_atm_gnd / nstems
                 !OWle_atm_gnd is the flux of water due to transpiration
                    !from the foliage (le) to the atmosphere (atm) in
                    !kg water m-2 day-1.
                               !See next statement for OWle_atm_gnd = ...
                               !OWle_atm_gnd1 * ( s_diurnal * light_on &
                               !16/10/06. Deleted above "* light-on" term.
                               !This resulted in
                               !OWle_atm_gnd NE OWle_rad_gnd + OWle_vdg_gnd
                               !at night. Surely it makes sense for
                               !OWle_vdg_gnd is be > 0 at night, although at
                               !a reduced rate because the stomates are
                               !closed. Making this change will increase
                               !transpiration.
                 OWle_atm_gnd = s_leaf * OWle_atm_gnd1 * &
                     ( s_diurnal + one_s_diurnal * daylength ) 
                !This equation corrects the transpired flux, OWle_atm_gnd1,
                    !for s_diurnal = 0 (no diurnal variation) or
                        !s_diurnal = 1 (with diurnal variation);
                    !light_on = 1 during the light period,
                    !light_on = 0 during the  dark period,
                    !daylength = daylength (day),
                    !e.g. 8-h day has daylength = 1/3 d.
       OWle_atm_gnd1 = OWle_rad_gnd + OWle_vdg_gnd  !kg water m-2 day-1.
                       !Radiation + vapour-density-gradient driven terms.

   
           !If the stomatal conductance is maximum, gcanmax, then
               OWle_atm_gnd_pot1 = OWle_rad_gnd_pot + OWle_vdg_gnd_pot
               OWle_atm_gnd_pot = OWle_atm_gnd_pot1 &
                                  * ( s_diurnal * light_on &
                                      + one_s_diurnal * daylength )
           !Potential transpiration is calculated for information only.
         
   !The terms, OWle_rad_gnd and OWle_vdg_gnd, for foliage water loss are now 
   !calculated using the Penman-Monteith equation.
   
   !(1)  OWle_rad_gnd (kg water m-2 day-1)
      !Calculate the boundary layer conductance, gBoundaryLayer (m s-1):
          Constant kvonK = 0.4   !Von Karman constant
          zetaga = 0.026 * hcan  !Roughness parameter for heat and vapour
                                 !exchange. Campbell, 1977.  
          zetam =  0.076 * hcan  !Roughness parameter for turbulent
                                 !momentum transport. Jarvis, 1976.
          zpd =    0.78  * hcan  !Zero plane displacement. Jarvis, 1976.
             !These numbers are a bit different for grassland.
             lnarg5 = ( href + zetaga - zpd ) / zetaga 
             zlnarg6 = LOG ( ( href + zetam  - zpd ) / zetam )
             dengBoundaryLayer = ( LOG ( lnarg5 ) * zlnarg6 )
             IF ( dengBoundaryLayer .GT. zero ) &
       gBoundaryLayer = kvonK * kvonK * wind / dengBoundaryLayer    !m s-1.
   
      !Calculate also the windspeed at the top of the canopy, 
          !taken as hstem, for use when calculating evaporation
          !from rainfall intercepted by the canopy, OWrain_int:  Not used.
             ! lnarg_hstem = ( hstem + zetam - zpd ) / zetam
             ! wind_hstem = wind * LOG( lnarg_hstem ) / zlnarg6

   
      !Total radiation absorbed by the crop canopy, jNetRabs_can, is:
         jNetRabs_can = jNetRsc * fPARabs_canTblack * c86400   !J m-2 day-1.
            !This expression assumes that all the radiation reflected by
            !leaves escapes from the canopy, and is obtained by
            !integrating Ileaf, the radiation flux density incident on a
            !leaf from LAI = 0 to LAI, that is
            !integrate ( 1 - crleaf - chileaf ) * Ileaf * dLAI 
            !See T and J, p. 204, eqn (8.7c).  It is also assumed that the
            !leaf reflectance and transmittance are the same for total
            !radiation as for visible radiation.

      !Density of water vapour in the atmosphere:
         roWvap_atm = RH * roSatWVap              !kg water m-3.
         roWvap_atme3 = c1000 * roWvap_atm        !g water m-3. Output only.
      !Vapour pressure of water in atmosphere:
         VapP_RH = roWvap_atm * RgasTairK / rmmW                 !Pa.
      !Vapour pressure deficit:
         IF ( VapP .GT. clarge ) THEN
              VPD = SatVapP - VapP_RH                            !Pa.
         ELSE
              VPD = SatVapP - VapP                               !Pa.
         ENDIF

            IF ( gcan .GT. zero ) THEN !leaves are present.
                   denPenman = LatentHeat * ( DroSatWVapDT & 
                               + gammapsych * ( rBoundaryLayer + rcan ) * &
                                              ( gBoundaryLayer + grad2 ) )
               IF ( denPenman .GT. zero ) &
                  OWle_rad_gnd = s_leaf * DroSatWVapDT * jNetRabs_can &
                                 / denPenman
               !If the stomatal resistance is minimum, rcanmin, then
                  denPenman_pot = LatentHeat * ( DroSatWVapDT &
                      + gammapsych * ( rBoundaryLayer + rcanmin ) * &
                                     ( gBoundaryLayer + grad2 ) )
               IF ( denPenman_pot .GT. zero ) &
                   OWle_rad_gnd_pot = DroSatWVapDT * jNetRabs_can &
                                      / denPenman_pot

   
   !(2)  OWle_vdg_gnd (kg water m-2 day-1)

                  !The atmospheric water vapour density is:  
                         delWVap = roSatWVap - roWvap_atm 
                      zOWle_vdg_gnd_num = c86400 * LatentHeat &
                        * gammapsych * ( gBoundaryLayer + grad2 ) &
                        * delWVap 
            IF ( denPenman .GT. zero ) &
               OWle_vdg_gnd = s_leaf * zOWle_vdg_gnd_num / denPenman 
                 !If the stomatal conductance is maximum, gcanmax, then
                     IF ( denPenman_pot .GT. zero ) &
                     OWle_vdg_gnd_pot = zOWle_vdg_gnd_num / denPenman_pot 
            ELSE  !there are no leaves (gcan .LE. 0).
              OWle_rad_gnd = zero 
              OWle_rad_gnd_pot = zero
              OWle_vdg_gnd = zero
              OWle_vdg_gnd_pot = zero
            ENDIF
   





















   
   !Finally (in the Foliage Water section),
      !evaluate canopy temperature, Tcanopy, 
      !saturated vapour density, roSatWVap (at canopy temperature, Tcanopy),
      !and saturated vapour pressure at Tcanopy.
      IF ( denPenman .GT. zero ) & 
       Tcanopy = Tair + ( ( jNetRabs_can / c86400 ) &
                          * ( rBoundaryLayer + rcan ) &
                         - LatentHeat * ( roSatWVap - roWvap_atm ) &
                        ) / denPenman
       roSatWVapTcanopy = roSatWVap_Table ( Tcanopy )
       SatVapPTcanopy = roSatWVapTcanopy * RgasTairK / rmmW         !Pa.

   !Neither Tcanopy nor roSatWVapcanopy are used elsewhere in the program;
   !they are simply calculated for information.
   
   
   !Osmotic potential, psiOle [J (kg water)-1]:
      !It is assumed that the total substrate dry mass MSle is dissolved in
      !mass of water Wle.
         IF ( Wle .GT. c1E_14 ) THEN
              rMSleWle = MSle / Wle
              psiOle = - c1000 * Rgas * fSos_ac * TairK * rMSleWle / rmm_osm
         ELSE
              psiOle = zero
         ENDIF

   !Pressure potential, psiPle [J (kg water)-1]:
      !It is assumed that the mass of water Wle is contained in the total
      !foliage (le) structural DM, MXle.
          z1psileP = cpsiPr * rWXle  !rWXle = Wle / MXle.
                  !cpsiPr = 0.2, rWXlec = 12 (if MXle is very small), 
                  !z1psileP = 1, Wle / MXle.
          z2psileP = z1psileP - one
       psiPle = epsilon * z2psileP / roW 
   
   !Gravitational potential:
        psiGle = gravity * hcan 
   
   !Total water potential:
        psile = psiOle + psiPle + psiGle 
   
   
   !Relative water content, thetale: 
         !Calculate Wle_psi0, mass of water which would be present at zero
         !water potential psile = 0 (Thornley, 1998, eqn 6.5e, page 128):
         RgasTairK = c1000 * Rgas * TairK !J MOL-1. 
         IF ( MXle .GT. c1E_14 ) THEN
           !The significant arguments for the calculation of Wle_psile0 are:
              !MXle, psiGle, hcan, MSle
           z1leW = epsilon * cpsiPr / ( roW * MXle ) 
                           !epsilon, cspiPR, roW, gravity, fSos_ac, rmm_osm 
                           !are constants.
           z2leW = psiGle - epsilon / roW
           z3leW = - RgasTairK * fSos_ac * MSle / rmm_osm
                         b24acl = z2leW * z2leW - 4 * z1leW * z3leW
                 IF ( b24acl .GE. zero ) THEN 
                      sqrtb24acl = SQRT( b24acl )
                 ELSE !for debugging to file debug.out
                      sqrtb24acl = zero
                    IF ( debugout ) THEN 
                       !write ( 70, 1006 ) !Header: written above.
                       !1006..format ( 1x, 1x, 'year    ', 't', 
                       write ( 70, 1005 ) year, t, hour, MXle, &
                                          b24acl, z1leW, z2leW, z3leW
                       1005..format (1x, f8.3, 1x, f10.2, &
                                         1x, f5.2, 1x, 1pe10.3, 1p4e10.3 )
                       debugout = .FALSE. !Only write this output once.
                       CLOSE ( UNIT = 70 )
                    ENDIF
                 ENDIF
               IF ( z1leW .GT. zero ) &
                  Wle_psi0 = ( -z2leW + sqrtb24acl ) / ( z1leW + z1leW )
            IF ( Wle_psi0 .GT. zero ) thetale = Wle / Wle_psi0
         ELSE
            thetale = one
         ENDIF !IF ( MXle .GT. c1E_14 ) THEN block.

   !Water activity, aWle:
        aWle1 = EXP( rmmW * psile / RgasTairK )
        aWle = MIN( aWle1, one )  !Problems may ensue when psile > 0.
   
!CALL LOGD(.TRUE.)
!Water accounting.
   !Tree.
      !Mass of water in tree:
         Wtree_stem = Wbud + Wle + Wfi                      !kg water stem-1.
         Wtree = nstems * Wtree_stem                        !kg water m-2.
   
      !Rate of change of mass of water in tree:
         DWtree_stem = DWbud + DWle + DWfi          !kg water stem-1 day-1.
            DWtreez1 = nstems * DWtree_stem         !kg water m-2 day-1.
            DWtreez2 = Dnstems * Wtree_stem         !kg water m-2 day-1.
         DWtree = DWtreez1 + DWtreez2               !kg water m-2 day-1.
   
      !Check tree water accounting:
         !Input of water to tree:
            !IWtree = OWso_fi  !kg water m-2 day-1.  Calculated above.
         !Output of water from tree:
            OWtree = OWle_atm_gnd + OWtree_th + OWbud_prune_gnd &
                                  + OWle_prune_gnd + OWfi_prune_gnd &
                                  + OWle_lf_gnd + OWtree_fire_atm &
                                  + OWfi_fire_gnd   !kg water m-2 day-1.
         DWtree_chk = IWtree - OWtree  !Input - output of water to tree.
           !OK under self-thinning.

      !Testing:
         DWtreesum = DWle_gnd + DWfi_gnd + DWbud_gnd
         DWtreesum_chk =   IWle_gnd - OWle_gnd &
                        + IWfi_gnd - OWfi_gnd &
                        + IWbud_gnd - OWbud_gnd
              !OK under self-thinning.

   !System.
      !Mass of water in system (kg water m-2):
         Wsys = Wsoil + Wtree + Wptd + Wprd
   
      !Water fluxes into/out of the system are (kg water m-2 day-1):
         IWsys = rain
         OWsys = OWrain_int + OWle_atm_gnd + OWtree_fire_atm &
                            + OWso_atm + OWso_drain &
                            + OWprthd + OWprrod
   
      !Rate of change of water in the system is (kg water m-2 day-1):
         DWsys = DWtree + DWsoil + DWptd + DWprd
   
                !Note: we omit any movement of water with tree water with
                      !stem birth or death due to self-thinning.
                      !But, water is lost when the plantation is thinned.
   
   !Check water accounting:
      DWsys_chk = IWsys - OWsys   !DWsys should equal DWsys_chk
           !OK under self-thinning.
!End of WATER SUBMODEL 

!CALL LOGD(.TRUE.)


!APHID SUBMODEL
!From the aphid submodel state variables and parameters, compute
   !Total alate instars 
      alai = ala1 + ala2 + ala3 + ala4         !numbers (stem)-1.
   !Total alate aphids 
      ala = alai + alaa                          !numbers (stem)-1.
   !Total apterous instars
      apti = apt1 + apt2 + apt3 + apt4         !numbers (stem)-1.
   !Total apterous aphids
      apt = apti + apta                          !numbers (stem)-1.
   !Total aphids
      aph = ala + apt                             !numbers (stem)-1.
   !Total adult aphids
      Axxa = apta + alaa                          !numbers (stem)-1.     
   aph_gnd = nstems * aph                         !numbers (m2 gnd)-1
            !nstems = no of stems (m2 gnd)-1.

   !Rate of change of these aphid number variables.
      Dalai = Dala1 + Dala2 + Dala3 + Dala4    !numbers (stem)-1 d-1.
      Dapti = Dapt1 + Dapt2 + Dapt3 + Dapt4    !numbers (stem)-1 d-1.
      Dala = Dalai + Dalaa                       !numbers (stem)-1 d-1.
      Dapt = Dapti + Dapta                       !numbers (stem)-1 d-1.
      Daph = Dala + Dapt                          !numbers (stem)-1 d-1.
   !Can we apply a check to Daph by adding total fecundity, Oaxxa_axx1, and
   !substracting mortality, Oaph_mort, and emigration, Oalaa_emi, to give
              Oaph_sn = FGRnstems_sn * aph !Self-thinning term.
   !Pruning output of aphids (numbers stem-1 d-1)
      Oaph_prune = Oala1_prune + Oala2_prune + Oala3_prune + Oala4_prune &
                 + Oapt1_prune + Oapt2_prune + Oapt3_prune + Oapt4_prune &
                 + Oalaa_prune + Oapta_prune

      Daph_chk = Oaxxa_axx1 - Oaph_mort - Oalaa_emi - Oaph_sn - Oaph_prune
                     !OK with pruning.
                     !OK under self-thinning.
         !For output purposes only:
            !aph_mort = Oaph_mort  !Aphids stem-1 d-1. Mortality.
            Oaph_fec =  Oaxxa_axx1 !Aphids stem-1 d-1. Fecundity.
   !Fractional growth rate in aphid numbers per stem:
      IF ( aph .GT. zero ) THEN 
           FGRaph = Daph / aph 
      ELSE 
           FGRaph = clarge                  !a large number: 7.7777d+17
      ENDIF

   !Fractional growth rate in aphid C (kg aphid C per stem):
      IF ( Caph .GT. zero ) THEN 
           FGRCaph = DCaph / Caph 
      ELSE 
           FGRCaph = clarge                  !a large number: 7.7777d+17
      ENDIF

   !Fractional growth rate in aphid N (kg aphid N per stem):
      IF ( Naph .GT. zero ) THEN 
           FGRNaph = DNaph / Naph 
      ELSE 
           FGRNaph = clarge                  !a large number: 7.7777d+17
      ENDIF
 
   !Aphid density, roaph [aphids (m2 leaf area)-1].
      !Assume that aphids are distributed uniformly over the surface area
      !of the foliage (leaves).
      !The spruce aphid does not colonize the new leaves.  We assume that
      !it only colonizes and feeds on leaf age categories 2 to 4.
      IF ( cc4aphid ) THEN  !Constant plant conditions for aphid growth.
         Aleaf_aph = ccAleaf_aph              !m2.
                     Constant ccAleaf_aph = 0.09 !m2.
      ELSE
         Aleaf_aph = Aleaf2 + Aleaf3 + Aleaf4               !m2 stem-1.
      ENDIF  !At t = 0, Aleaf = 0.012 (4 * 0.003) and Aleaf_aph = 0.009.
          !Default cc4aphid = .false.

!CALL LOGD(.TRUE.)

      IF ( Aleaf_aph .NE. zero ) THEN 
         roaph =   aph / Aleaf_aph !# (m2 colonized leaf area)-1 =
         apt_Aleaf = apt / Aleaf_aph !# stem-1/(m2 stem-1).
         ala_Aleaf = ala / Aleaf_aph
         aph_Aleaf = aph / Aleaf_aph
      ELSE
         roaph = zero
         apt_Aleaf = zero
         ala_Aleaf = zero
         aph_Aleaf = zero
      ENDIF

   !Total carbon, nitrogen in the aphids:
      Cala = ala1 * MCala1 + ala2 * MCala2 + ala3 * MCala3 &
           + ala4 * MCala4 + alaa * MCalaa                 !kg C stem-1.
      Nala = ala1 * MNala1 + ala2 * MNala2 + ala3 * MNala3 &
           + ala4 * MNala4 + alaa * MNalaa                 !kg N stem-1.
      Capt = apt1 * MCapt1 + apt2 * MCapt2 + apt3 * MCapt3 &
           + apt4 * MCapt4 + apta * MCapta                 !kg C stem-1.
      Napt = apt1 * MNapt1 + apt2 * MNapt2 + apt3 * MNapt3 &
           + apt4 * MNapt4 + apta * MNapta                 !kg N stem-1.
      Caph = Cala + Capt; Naph = Nala + Napt                 !kg C, N stem-1.
      Caph_m2 = nstems * Caph;  Naph_m2 = nstems * Naph      !kg C, N m-2.

!CALL LOGD(.TRUE.)
!Apterous (wingless) aphids
!**************************

   !Adult apterous aphids, apta (aphid number stem-1).
      !Input, Iapta (aphids stem-1 day-1)
         !There is just one input from apt4 pool, Oapt4_a
            Iapt4_apta = Oapt4_a
            Iapta = Iapt4_apta                    !Put into standard notation.
         !Oapt4_a is calculated under the apt4 pool below.
         !Input Iapta brings with it C and N fluxes of
            !should this say "requires fluxes of"?
            ICapt4_a = Iapta * MCapta           !kg C stem-1 day-1.
            INapt4_a = Iapta * MNapta           !kg N stem-1 day-1.

      !Outputs
         !Litter.
         !Any flux of aphids to the surface litter with the foliage litter
         !flux is ignored  (If it is decided to include such a flux, it will
         !be driven by OAleaf4_li (m2 stem-1 day-1)):
            IF ( Aleaf_aph .NE. zero ) THEN
                 zAleaf4_aph = OAleaf4_li / Aleaf_aph  !day-1.
            ELSE
                 zAleaf4_aph = zero
            ENDIF
            Oapta_li = apta * zAleaf4_aph        !Aphids stem-1 day-1.
         !This flux is calculated here but is not used. The aphids may have
         !quit the leaves before they fall off.

         !1. Mortality, apta output to, Oapta_mort (aphids stem-1 d-1)
             !We assume that there is a temperature-dependent mortality rate,
             !and a nutrition-dependent mortality rate. They are calculated
             !independently, added together, but the sum is restricted to a
             !ceiling, the maximum mortality rate, kaph_mort_max.
             !The same mortality rate applies to all aphid categories.

             !Temperature-dependent mortality, kaph_Tmort (d-1).
                !See \models\TempFns.csl, .cmd; and \forest\TempFns.cmd.
                        f1Tmort = ( kaph_Tmort_opt + &
                                     (kaph_Tmort_0 - kaph_Tmort_opt) & 
                                    * ( Tair - Taph_mort_opt ) **2 &
                           / ( Taph_mort_0 - Taph_mort_opt ) **2 ) !d-1.
                        f2Tmort = ( one + caph_mort_skew * &
                                     ( Tair - Taph_mort_opt ) &
                                  / ( Taph_mort_opt - Taph_mort_0 ) ) !Skew
                                  !factor, no units.
                   kaph_Tmort = f1Tmort * f2Tmort
                     Constant kaph_Tmort_0 = 0.04 !day-1. 
                                         !Gives the mortality rate
                                         !at the reference temperature, 
                                         !Taph_mort_0.
                     Constant kaph_Tmort_opt = 0.0 !day-1. 
                                         !Gives the mortality rate
                                         !at the optimum growth temperature.
                     Constant Taph_mort_0  = 0, Taph_mort_opt = 15 !C.
                     Constant caph_mort_skew = 0.2 !Dimensionless.
                                   !Determines how skewed the
                                   !parabola is about the optimum temperature.
                              caph_mor_sk = caph_mort_skew !For ouput only.
               !Nutrition-dependent mortality, kaph_Nmort (d-1): 
                          NphloemNmortq = Nphloem ** qaph_Nmort
                          Constant qaph_Nmort = 2.0 !Dimensionless constant.
                     faph_mort_N = KNaph_mortq / &
                                   ( KNaph_mortq + NphloemNmortq )
                  kaph_Nmort = kaph_Nmortmax * faph_mort_N  !d-1.
                         Constant KNaph_mort = 1         !kg N m-3.
                                                   !Equivalent to Nsh = 0.001.
                         Constant kaph_Nmortmax = 0.1 !day-1. Maximum
                                  !mortality rate if there is no food.
   
               kaph_mort1 = kaph_mort_min + kaph_Tmort + kaph_Nmort !d-1.
                            Constant kaph_mort_min = 0.0 !d-1.
                               !The minimum mortality rate. Changed from 0.02
                               ! 13/07/18, after plotting the components of 
                               ! kaph_mort1 and seeing what at big effect
                               ! a value of 0.02 has on mortality.
                               !Therefore, ?, not necessary to use the
                               ! m_kaph_mort multiplier in the next statement.
                               !Run gomortality in aphid.cmd.
   
               kaph_mort = m_kaph_mort * MIN( kaph_mort1, kaph_mort_max ) !d-1.
                  Constant kaph_mort_max = 0.08 !d-1. Max value of kaph_mort.
                !Note: kaph_mort_max is less than kaph_Nmortmax above.
                  Constant m_kaph_mort = 1.0 !Multiplier of kaph_mort.
                        kaph_mort_m = kaph_mort_max !For print output only.
                         !May fail if m_kaph_mort is small, eg 0.05.
                         !If = 0.07, aph population grows slowly.
           !Now back to apterous adult aphid mortality:
            Oapta_mortz = kaph_mort * apta  !Apterous aphids stem-1 day-1.
               Oapta_mort = s_aphid * Oapta_mortz

               !There are associated C and N fluxes:
                  OCapta_mort = Oapta_mort * MCapta     !kg C stem-1 day-1.
                  ONapta_mort = Oapta_mort * MNapta     !kg N stem-1 day-1.

         !2. Thinning.
             !Thinning does not affect aphid numbers per stem.

         !3. Self-thinning.
            !Trees which die due to self-thinning are assumed to have no
            !foliage, and therefore no aphids die from this cause.
            !However, a positive birth rate (FBRnstems) of trees (of
            !assumed zero size) may give a positive stem number/( m2 ground)
            !growth rate (FGR).
            !As the aphid numbers/m2 ground do not change, then
            !the aphid numbers/stem must decrease when stem numbers increase. 
            !Consider:
            !   d(nQ)/dt = 0, Q dn/dt + n dQ/dt = 0, dQ/dt = IQ - OQ.
            !   If (say), IQ = 0, then OQ = (1/n dn/dt) Q
               Oapta_snz = FGRnstems_sn * apta     !aphids stem-1 day-1.
                  Oapta_sn = s_aphid * Oapta_snz
               !There are associated C and N fluxes:
                  OCapta_sn = Oapta_sn * MCapta     !kg C stem-1 day-1.
                  ONapta_sn = Oapta_sn * MNapta     !kg N stem-1 day-1.

         !4. Pruning.
             Oapta_prunez = kle_prune * apta    !aphids stem-1 day-1.
                Oapta_prune = s_aphid * Oapta_prunez
             OCapta_prune = Oapta_prune * MCapta  !kg C stem-1 day-1.
             ONapta_prune = Oapta_prune * MNapta  !kg N stem-1 day-1.

         !Total outputs.
             Oapta = Oapta_mort + Oapta_sn + Oapta_prune !aphids stem-1 day-1.
                  !to mortality, self-thinning, pruning, no emigration. 
                  !cf Oalaa.
         !Fractional outputs
               IF ( Oapta .GT. zero ) THEN
                fOapta_mort =  Oapta_mort /  Oapta
                fOapta_sn =    Oapta_sn /    Oapta
                fOapta_prune = Oapta_prune / Oapta
                   fOapta_prun = fOapta_prune !For print ouput only.
               ELSE           
                fOapta_mort =  zero
                fOapta_sn =    zero
                fOapta_prune = zero
                   fOapta_prun = fOapta_prune !For print ouput only.
               ENDIF

!CALL LOGD(.TRUE.)
   
      !Differential equation (apterous adult aphids stem-1 day-1)
           Daptaz = Iapta - Oapta !apterous adult aphids stem-1 day-1.
            Dapta = aphidvr * Daptaz
            apta = INTEG( Dapta, apta0 )       !apterous aphids stem-1.
   
              !Rate of change of C, N in the apta pool is:
                 DCapta = Dapta * MCapta             !kg C stem-1 day-1.
                 DNapta = Dapta * MNapta             !kg N stem-1 day-1.
   
      !Processing (fecundity)
            !Adult wingless (apterous) aphids (apta) give birth to nymphs.
            !The rate or fecundity is influenced by temperature and Nphloem.
   
            !1. Temperature.  fTaph_fec is calculated below. It is
              !essentially the standard biological temperature response
              !function, fTsh, but with different parameters for aphid 
              !fecundity.

         !Note - we use Tair when calculating fTaph_fec.
         IF ( (Tair .LE. T0aph_fec) .OR. ( Tair .GE. T0paph_fec ) ) THEN
               fTaph_fec = c1E_10
         ELSE
               fTaph_fec = ( ( Tair - T0aph_fec ) ** qfT1aph_fec * &
                              ( T0paph_fec - Tair ) ** qfT2aph_fec &
                           ) * zfTaph_fec
         ENDIF
               !zfTaph_fec is calculated above in Initial for efficiency.
        !               zfTaph_fec = one / &
        !             ( ( Trefaph_fec - T0aph_fec ) ** qfT1aph_fec &
        !                * ( T0paph_fec - Trefaph_fec ) ** qfT2aph_fec &
        !             )


            !2. N substrate concentration in phloem, Nphloem.  
               !Aphid has a maximum volume intake of phloem sap at 20 deg C:
                  Constant vapta_max20 = 2.0E-7 !m3 aphid-1 day-1
                                !2.0E-7 * 10**6 cm3 = 0.2 ml day-1.
                  !Actual volume intake at ambient temperature (assume same T
                     !function applies to intake and fecundity):
                  vapta_maxz = fTaph_fec * vapta_max20   !m3 aphid-1 day-1.
                     vapta_max = s_aphid * vapta_maxz !0, if aphids off.
               !This gives a maximum phloem-volume-limited N intake of
                  INphloem_vapta_max = vapta_max * Nphloem !0 is aphids off.
                                                       !kg N aphid-1 day-1.
                     INphloem_vapta_maxz = vapta_maxz * Nphloem !Not used.
                     INvapta_max = INphloem_vapta_max !not used. 4 output only.
                     INvapa_mxe8 = INvapta_max * 1.0e8 !ditto 
                     INvapa_mxe7 = INvapta_max * c1e7  !ditto

              !This may exceed the N requirement = maximum amount of N which
                  !can be processed (p) of (at 20 deg C):
                  Constant INpapta_max20 = 2.0E-6       !kg N aphid-1 day-1.
                  !Actual amount which can be processed is
                  INpapta_maxz = fTaph_fec * INpapta_max20
                  INpapta_max = s_aphid * INpapta_maxz  !kg N aphid-1 day-1.
                     INpapa_mxe7 = INpapta_max * c1e7 
                     !For output only. 11 chars. c1e7 = 1.0e7.

               !Therefore actual amount of N ingested is the least of the
                  !volume-intake-limited or the processing-limited values:
                  INphloem_apta_aphid = m_apta_fec * &
                     MIN( INphloem_vapta_max, INpapta_max )
                                                         !kg N aphid-1 day-1.
      !The minimum is the volume-limited rate (INpapta_max is far larger: 8x).
                     Constant m_apta_fec = 1 !A dimensionless multiplier
                                             !of apterous aphid fecundity.
                  LOGICAL phloemv_lim  !Phloem-volume limited:
                          phloemv_lim = INphloem_vapta_max .LE. INpapta_max

               !Actual volume of phloem sap ingested is (m3 aphid-1 d-1).
                  IF ( Nphloem .NE. zero ) THEN
                     vphloem_apta = INphloem_apta_aphid / Nphloem  
                  ELSE
                     vphloem_apta = clarge  !7.7777e17.
                  ENDIF
                     vapta = vphloem_apta !For output only m3 aphid-1 d-1.
                     vapta1e8 = vapta * c1e8 !For output only.

               !N intake is (kg N substrate stem-1 day-1):
                  INphloem_apta = apta * INphloem_apta_aphid
                     
               !C intake is
                  ICphloem_apta_aphid = vphloem_apta * Cphloem 
                         !kg C aphid-1 d-1.
                  ICphloem_apta = apta * ICphloem_apta_aphid
                     !kg C (substrate) stem-1 day-1.
!CALL LOGD(.TRUE.)
            !N ingested is assumed completely converted to wingless (apt) and
               !winged (ala) nymphs, in pools apt1 and ala1.
               !Calculate the fractions of the offspring of apterous adults
               !going to the two forms. This is affected by
                  !1. Temperature, Tair (higher T, more alates)
                        Tairqapt = Tair ** qTapt
                        Constant qTapt = 2                     !Dimensionless.
                        Constant KTapt = 10                    !degrees C.
                        !KTaptq = KTapt ** qTapt etc, see Initial section.
                        fTapta_ala1 = Tairqapt / ( Tairqapt + KTaptq )
                  !2. Aphid (total) density, roaph
                        ![aphids (m2 leaf area)-1].
                        !Higher density, more alates (winged).
                        roaphaptq = roaph ** qroapt
                        Constant qroapt = 2            !Dimensionless.
                        Constant Kroaphapt = 1000.0 ! from 10000
                                                !aphids (m2 leaf area)-1.
                                                !aphids at a 3 cm separation.
                                                !33 aphids per m.
                                                !1000 aphids per m^2.
                         !Query: total aphid density roaph peaks each year 
                            !at c. 800. 
                         !Therefore roaphaptq peaks at c. 3600.

                        froapta_ala1 = roaphaptq / &
                                ( roaphaptq + Kroaphaptq ) 
                           froapta_al1 = froapta_ala1 !For output only.
                        !For Kroaphaptq = Kroaphapt ** qroapt
                           !etc, see Initial section. Search up:
                                     !"Apterous:alate ratio in offspring."
                  !3. Nutritional status, Nphloem.
                        !High Nphloem, few alates (winged), fNapta_ala1
                        !Nphloem = 0, fNapta_ala1 = 1, all alates.
                        Nqapt = Nphloem ** qNapt
                        Constant qNapt = 2         !Dimensionless.
                        Constant KNapt = 4 !changed 18/05/18. 
                                  !Was 1   !kg N m-3.  ? make larger.
                                  !e.g. alates run short of N more quickly.
                                                   !Equivalent to Nsh = 0.01.
                        fNapta_ala1 = one / ( one + Nqapt / KNaptq )
                        !For KNaptq = KNapt ** qNapt etc, see Initial section.
   
                  !Combining these 3 factors to give the fraction of the
                     !offspring of apterous adults:
                     fapta_ala1 = fTapta_ala1 * froapta_ala1 * fNapta_ala1
                  !The fraction of offspring of apterous adults which are 
                     !apterous (wingless) is:
                     fapta_apt1 = one - fapta_ala1
   
               !N ingested by apterous females, INphloem_apta, is converted
               !into 1st instar nymphs (ala and apt) at the rate of
                  Oapta_axx1 = INphloem_apta / &
                                ( fapta_apt1 * MNapt1 + fapta_ala1 * MNala1 ) 
                                                         !aphids stem-1 day-1.
                  denOapta_axx1 = fapta_apt1 * MNapt1 + fapta_ala1 * MNala1 
                                 !denominator of Oapta_axx1.
               !Fractional fecundity of apterous adult aphids is: 
                  IF ( apta .EQ. zero ) THEN 
                       ffecapta = csmall
                  ELSE
                       ffecapta = Oapta_axx1 / apta  !d-1.
                  ENDIF

               !These are input to the apt1 and ala1 pools at rates
                  Oapta_apt1 = fapta_apt1 * Oapta_axx1  !aphids stem-1 y-1.
                     Iapta_apt1 = Oapta_apt1
                  Oapta_ala1 = fapta_ala1 * Oapta_axx1  !aphids stem-1 d-1.
                     Iapta_ala1 = Oapta_ala1
               !There are N fluxes from apta associated with this aphid flux:
                  ONapta_apt1 = Iapta_apt1 * MNapt1
                  ONapta_ala1 = Iapta_ala1 * MNala1
                  ONapta_axx1 = ONapta_apt1 + ONapta_ala1   !kg N stem-1 day-1.
   
               !Carbon fluxes, to respiration, offspring and honeydew
                  !Carbon intake is ICphloem_apta (kg C stem-1 day-1).
                  !Assume a fraction of this is respired:
                     Rapta = fCaph_resp * ICphloem_apta !kg C stem-1 day-1.
                                Constant fCaph_resp = 0.5
                     OCapta_env = Rapta   !Put into standard notation.
                  !Some is used for offspring (axx1 denotes apt1 and ala1):
                     OCapta_apt1 = Iapta_apt1 * MCapt1
                     OCapta_ala1 = Iapta_ala1 * MCala1
                     OCapta_axx1 = OCapta_apt1 + OCapta_ala1
                        !kg C stem-1 day-1.
                  !The rest is honeydew:
                     OCapta_hon = ICphloem_apta - OCapta_env &
                                                      - OCapta_axx1
                           !kg C stem-1 d-1.  Rapta = OCapta_env
!CALL LOGD(.TRUE.)

      !Development rates
         !depend on temperature, mostly, and nutrition, Nphloem, slightly.
         !1. Temperature. fTaph_dev, the temperature response function 
             ! for aphid development.
         !Note - we use Tair when calculating fTaph_dev.
         IF ( (Tair .LE. T0aph_dev) .OR. ( Tair .GE. T0paph_dev ) ) THEN
               fTaph_dev = c1E_10
         ELSE
               fTaph_dev = m_fTaph_dev * &
                          ( ( Tair - T0aph_dev ) ** qfT1aph_dev * &
                            ( T0paph_dev - Tair ) ** qfT2aph_dev &
                          ) * zfTaph_dev
         ENDIF                             !p denotes prime.
               !zfTaph_dev is calculated above in Initial for efficiency.
        
         !2. Nutrition. fNaph_dev.  The effect is small, a 10% decrease in
                                    !development rate if Nphloem = 0.
                Constant fNaph_dev_min = 0.9 !Dimensionless fraction.
                IF ( Nphloem .NE. zero ) THEN
                   fNaph_dev = fNaph_dev_min + one_fNaph_dev_min * &
                               ( one / ( one + KNaph_dev / Nphloem ) )
                ELSE
                   fNaph_dev = zero
                ENDIF
                Constant KNaph_dev = 1         !kg N m-3.
                                               !Equivalent to Nsh = 0.001.
         !one_fNaph_dev_min = one - fNaph_dev_min See Initial section.

         !Combined effects of T and N are
            fTNaph_devz = fTaph_dev * fNaph_dev
            fTNaph_dev = fTNaph_devz ** qaph_dev 
                                 Constant qaph_dev = 1
            fTNaph_devX5 = fTNaph_dev ** 0.5
            fTNaph_devx25 = fTNaph_dev ** 0.25

         !Rate constants are (day-1)
            kapt1_2 = kapt1_220 * fTNaph_dev
            kapt2_3 = kapt2_320 * fTNaph_dev
            kapt3_4 = kapt3_420 * fTNaph_dev
            kapt4_a = kapt4_a20 * fTNaph_dev
            Constant kapt1_220 = 0.2222222    !d-1. 1/4.5 d
            Constant kapt2_320 = 0.25         !d-1. 1/4 d
            Constant kapt3_420 = 0.2857142857 !d-1. 1/3.5 d
            Constant kapt4_a20 = 0.3333333    !d-1. 1/3 d 
                    !Why are these different from kala1_220 etc?  Which are
                    !15% smaller.

            !Survival aside: not used by the main program.
                  densurvival = kapt1_2 + kaph_mort
               IF ( densurvival  .GT. zero ) THEN !den = denominator
                  survival = kapt1_2 / densurvival
               ELSE 
                  survival = csmall 
               ENDIF

               IF ( kapt1_2 .GT. zero ) THEN
                  rmort_dev = kaph_mort / kapt1_2 
               ELSE 
                  rmort_dev = csmall 
               ENDIF

            !Apterous aphid development times at 20 oC:
               tauapt1_220 = one / kapt1_220; tauapt2_320 = one / kapt2_320 !d
               tauapt3_420 = one / kapt3_420; tauapt4_a20 = one / kapt4_a20 !d
               tauapt1_a20 = tauapt1_220 + tauapt2_320 + tauapt3_420 &
                                         + tauapt4_a20              !d.
                  !These add up to 4.5 + 4 + 3.5 + 3 = 15 d. The overall
                  !development time. See Dixon, 1998, Table 6.1, page 109.
                  !It is assumed that alates develope 15% more slowly.
               !This block could be moved into the initial section.
   !Juvenile apterous (wingless) aphids, 4 instars, apt1-4.
   
      !Inputs, Iapti (aphids stem-1 day-1)
            !Iapta_apt1 and Ialaa_apt1 are outputs from the apta and
            !ala pools.
            Iapt1_2 = Oapt1_2  !See below.
            Iapt2_3 = Oapt2_3
            Iapt3_4 = Oapt3_4
         !Put inputs into standard notation:
            Iapt1 = Iapta_apt1 + Ialaa_apt1
            Iapt2 = Iapt1_2
            Iapt3 = Iapt2_3
            Iapt4 = Iapt3_4
   
      !Outputs.
         !Outputs to litter are calculated but not used.  The aphids may
         !quit the leaves before they fall 
                Oapt1_li = apt1 * zAleaf4_aph      !Aphid stem-1 day-1.
                Oapt2_li = apt2 * zAleaf4_aph      !Aphid stem-1 day-1.
                Oapt3_li = apt3 * zAleaf4_aph      !Aphid stem-1 day-1.
                Oapt4_li = apt4 * zAleaf4_aph      !Aphid stem-1 day-1.

         !1. Development.
                Oapt1_2z = apt1 * kapt1_2          !Aphids stem-1 day-1.
                   Oapt1_2 = s_aphid * Oapt1_2z
                Oapt2_3z = apt2 * kapt2_3
                   Oapt2_3 = s_aphid * Oapt2_3z
                Oapt3_4z = apt3 * kapt3_4
                   Oapt3_4 = s_aphid * Oapt3_4z
                Oapt4_az = apt4 * kapt4_a
                   Oapt4_a = s_aphid * Oapt4_az

         !2. Mortality.
             !Assume the same constant, kaph_mort (see above), applies to 
             !all 4 instars:
                Oapt1_mortz = kaph_mort * apt1 !Apterous aphids stem-1 day-1.
                   Oapt1_mort = s_aphid * Oapt1_mortz
                Oapt2_mortz = kaph_mort * apt2
                   Oapt2_mort = s_aphid * Oapt2_mortz
                Oapt3_mortz = kaph_mort * apt3
                   Oapt3_mort = s_aphid * Oapt3_mortz
                Oapt4_mortz = kaph_mort * apt4
                   Oapt4_mort = s_aphid * Oapt4_mortz

             !Mortality of all 4 instars:
                    Oapti_mort = Oapt1_mort + Oapt2_mort + Oapt3_mort + &
                                Oapt4_mort        !aphids stem-1 day-1.
             !Add on mortality of apterous adults 
                         !(to give total apterous mortality:
                    Oapt_mort = Oapti_mort + Oapta_mort !See above.
                    !No emigration of apterous aphids.

         !Thinning.
             !Thinning does not affect aphid numbers per stem.

         !3. Self-thinning.
               Oapt1_snz = FGRnstems_sn * apt1 !Apterous aphids stem-1 day-1.
                  Oapt1_sn = s_aphid * Oapt1_snz
               Oapt2_snz = FGRnstems_sn * apt2
                  Oapt2_sn = s_aphid * Oapt2_snz
               Oapt3_snz = FGRnstems_sn * apt3
                  Oapt3_sn = s_aphid * Oapt3_snz
               Oapt4_snz = FGRnstems_sn * apt4
                  Oapt4_sn = s_aphid * Oapt4_snz

         !4. Pruning. Apterous aphids stem-1 day-1.
               Oapt1_prunez = kle_prune * apt1
                  Oapt1_prune = s_aphid * Oapt1_prunez
               Oapt2_prunez = kle_prune * apt2
                  Oapt2_prune = s_aphid * Oapt2_prunez
               Oapt3_prunez = kle_prune * apt3
                  Oapt3_prune = s_aphid * Oapt3_prunez
               Oapt4_prunez = kle_prune * apt4
                  Oapt4_prune = s_aphid * Oapt4_prunez
!CALL LOGD(.TRUE.)
   
         !Total outputs (aphids stem-1 day-1):
            Oapt1 = Oapt1_2 + Oapt1_mort + Oapt1_sn + Oapt1_prune
            Oapt2 = Oapt2_3 + Oapt2_mort + Oapt2_sn + Oapt2_prune
            Oapt3 = Oapt3_4 + Oapt3_mort + Oapt3_sn + Oapt3_prune
            Oapt4 = Oapt4_a + Oapt4_mort + Oapt4_sn + Oapt4_prune
   
         !Differential equations (aphids stem-1 day-1):
            Dapt1z = Iapt1 - Oapt1
            Dapt2z = Iapt2 - Oapt2
            Dapt3z = Iapt3 - Oapt3
            Dapt4z = Iapt4 - Oapt4
         !
            Dapt1 = aphidvr * Dapt1z
            Dapt2 = aphidvr * Dapt2z
            Dapt3 = aphidvr * Dapt3z
            Dapt4 = aphidvr * Dapt4z

         !Integrals:
            apt1 = INTEG( Dapt1, apt10 )  !Apterous aphid numbers stem-1.
            apt2 = INTEG( Dapt2, apt20 )
            apt3 = INTEG( Dapt3, apt30 )
            apt4 = INTEG( Dapt4, apt40 )

             !Rates of change of C, N in the four apt pools:
                 DCapt1 = Dapt1 * MCapt1               !kg C stem-1 day-1.
                 DNapt1 = Dapt1 * MNapt1               !kg N stem-1 day-1.
                 DCapt2 = Dapt2 * MCapt2               !kg C stem-1 day-1.
                 DNapt2 = Dapt2 * MNapt2               !kg N stem-1 day-1.
                 DCapt3 = Dapt3 * MCapt3               !kg C stem-1 day-1.
                 DNapt3 = Dapt3 * MNapt3               !kg N stem-1 day-1.
                 DCapt4 = Dapt4 * MCapt4               !kg C stem-1 day-1.
                 DNapt4 = Dapt4 * MNapt4               !kg N stem-1 day-1.
   
              !Rate of change of C, N in all apt1-4 pools is:
                 DCapti = DCapt1 + DCapt2 + DCapt3 + DCapt4
                                                        !kg C stem-1 day-1.
                 DNapti = DNapt1 + DNapt2 + DNapt3 + DNapt4
                                                        !kg N stem-1 day-1.
   
   
         !C, N fluxes associated with pools apt1-4:
    
            !Inputs of C, N from offspring from adult apta, alaa pools:
               ICapta_apt1 = Iapta_apt1 * MCapt1           !kg C stem-1 day-1.
               INapta_apt1 = Iapta_apt1 * MNapt1           !kg N stem-1 day-1.
               ICalaa_apt1 = Ialaa_apt1 * MCapt1           !kg C stem-1 day-1.
               INalaa_apt1 = Ialaa_apt1 * MNapt1           !kg N stem-1 day-1.
               ICaxxa_apt1 = ICapta_apt1 + ICalaa_apt1     !kg C stem-1 day-1.
               INaxxa_apt1 = INapta_apt1 + INalaa_apt1     !kg N stem-1 day-1.
!CALL LOGD(.TRUE.)
            !Inputs of N, C from phloem:
                 !Assume N required from phloem is the amount required to
                 !increase the N component of mass of the aphids which 
                 !enter the next pool:
                     INphloem_apt1 = Oapt1_2 * delMNapt2_1 !kg N stem-1 day-1.
                     INphloem_apt2 = Oapt2_3 * delMNapt3_2 
                     INphloem_apt3 = Oapt3_4 * delMNapt4_3
                     INphloem_apt4 = Oapt4_a * delMNapta_4
                 !Total N intake from phloem:
                     INphloem_apti = INphloem_apt1 + &
                                     INphloem_apt2 + INphloem_apt3 + &
                                     INphloem_apt4        !kg N stem-1 day-1.
                 !C flux accompanying this N flux is:
                     ICphloem_apti = rCNphloem * INphloem_apti
                                                          !kg C stem-1 day-1.
            !Outputs of C, N.
                 !The C flux from the phloem, ICphloem_apti, is used for
                 !respiration, increase in instar mass, and honeydew.
                 !Respiration. Assume a fraction of the C flux from
                 !the phloem is respired:
                     Rapti = fCaph_resp * ICphloem_apti !kg C stem-1 day-1.
                                !Constant fCaph_resp = 0.5
                     OCapti_env = Rapti           !Put into standard notation.
                 !Increase in instar mass (development = dev).
                     ICphloem_apt1 = Oapt1_2 * delMCapt2_1
                        !kg C stem-1 day-1.
                     ICphloem_apt2 = Oapt2_3 * delMCapt3_2 
                     ICphloem_apt3 = Oapt3_4 * delMCapt4_3
                     ICphloem_apt4 = Oapt4_a * delMCapta_4
                 !C intake required for instar development:
                     OCphloem_apti = ICphloem_apt1 + &
                                         ICphloem_apt2 + &
                                         ICphloem_apt3 + &
                                         ICphloem_apt4 !kg C stem-1 day-1.
                  !The rest is honeydew (external transfer):
                     OCapti_hon = ICphloem_apti - OCapti_env &
                                                - OCphloem_apti
                                                         !kg C stem-1 day-1.
            !Output of C, N from apt4 to apt:
               OCapt4_a = Oapt4_a * MCapta                  !kg C stem-1 day-1.
               ONapt4_a = Oapt4_a * MNapta                  !kg N stem-1 day-1.
   
            !Mortality.
                OCapt1_mort = Oapt1_mort * MCapt1       !kg C stem-1 day-1.
                ONapt1_mort = Oapt1_mort * MNapt1       !kg N stem-1 day-1.
                OCapt2_mort = Oapt2_mort * MCapt2       !kg C stem-1 day-1.
                ONapt2_mort = Oapt2_mort * MNapt2       !kg N stem-1 day-1.
                OCapt3_mort = Oapt3_mort * MCapt3       !kg C stem-1 day-1.
                ONapt3_mort = Oapt3_mort * MNapt3       !kg N stem-1 day-1.
                OCapt4_mort = Oapt4_mort * MCapt4       !kg C stem-1 day-1.
                ONapt4_mort = Oapt4_mort * MNapt4       !kg N stem-1 day-1.
                OCapti_mort = OCapt1_mort + OCapt2_mort + &
                              OCapt3_mort + OCapt4_mort !kg C stem-1 day-1.
                ONapti_mort = ONapt1_mort + ONapt2_mort + &
                              ONapt3_mort + ONapt4_mort !kg N stem-1 day-1.

            !Thinning.
               !Thinning does not affect aphid numbers per stem.   

            !Self-thinning.
                OCapt1_sn = Oapt1_sn * MCapt1          !kg C stem-1 day-1.
                ONapt1_sn = Oapt1_sn * MNapt1          !kg N stem-1 day-1.
                OCapt2_sn = Oapt2_sn * MCapt2          !kg C stem-1 day-1.
                ONapt2_sn = Oapt2_sn * MNapt2          !kg N stem-1 day-1.
                OCapt3_sn = Oapt3_sn * MCapt3          !kg C stem-1 day-1.
                ONapt3_sn = Oapt3_sn * MNapt3          !kg N stem-1 day-1.
                OCapt4_sn = Oapt4_sn * MCapt4          !kg C stem-1 day-1.
                ONapt4_sn = Oapt4_sn * MNapt4          !kg N stem-1 day-1.
                OCapti_sn = OCapt1_sn + OCapt2_sn + &
                              OCapt3_sn + OCapt4_sn    !kg C stem-1 day-1.
                ONapti_sn = ONapt1_sn + ONapt2_sn + &
                              ONapt3_sn + ONapt4_sn    !kg N stem-1 day-1.
   
            !Pruning.
                OCapt1_prune = Oapt1_prune * MCapt1       !kg C stem-1 day-1.
                ONapt1_prune = Oapt1_prune * MNapt1       !kg N stem-1 day-1.
                OCapt2_prune = Oapt2_prune * MCapt2       !kg C stem-1 day-1.
                ONapt2_prune = Oapt2_prune * MNapt2       !kg N stem-1 day-1.
                OCapt3_prune = Oapt3_prune * MCapt3       !kg C stem-1 day-1.
                ONapt3_prune = Oapt3_prune * MNapt3       !kg N stem-1 day-1.
                OCapt4_prune = Oapt4_prune * MCapt4       !kg C stem-1 day-1.
                ONapt4_prune = Oapt4_prune * MNapt4       !kg N stem-1 day-1.
                OCapti_prune = OCapt1_prune + OCapt2_prune + &
                              OCapt3_prune + OCapt4_prune !kg C stem-1 day-1.
                ONapti_prune = ONapt1_prune + ONapt2_prune + &
                              ONapt3_prune + ONapt4_prune !kg N stem-1 day-1.
   

      !C and N checks for the apterous aphids.   
      !C and N checks for the apta (apterous adult) pool:
         !C inputs
            ICapta = ICapt4_a + ICphloem_apta        !kg C stem-1 day-1.
               !where ICapt4_a = Iapta * MCapta     !kg C stem-1 day-1.
               !Why is this not           MCapt4?  And  
                !ICphloem_apta = apta * ICphloem_apta_aphid 
                                             !kg C (substrate) stem-1 day-1.
                !ICphloem_apta_aphid = vphloem_apta * Cphloem  
                                   !kg C aphid-1 d-1.

                                             

         !C outputs
            OCapta = OCapta_env + OCapta_axx1 + OCapta_hon + OCapta_mort &
                                + OCapta_sn   + OCapta_prune
         DCapta_chk = ICapta - OCapta
         !Compare this with DCapta.  !OK, 08/01/19.
         !N inputs
            INapta = INapt4_a + INphloem_apta        !kg N stem-1 day-1.
         !N outputs
            ONapta = ONapta_axx1 + ONapta_mort &
                                 + ONapta_sn + ONapta_prune 
         DNapta_chk = INapta - ONapta
         !Compare this with DNapta. ok, 08/01/2019
   
      !C and N checks for the 4 apti pools
         !C inputs
            ICapti = ICaxxa_apt1 + ICphloem_apti       !kg C stem-1 day-1.
         !C outputs
            OCapti = OCapt4_a + OCapti_env + OCapti_hon + OCapti_mort &
                              + OCapti_sn  + OCapti_prune
   
         DCapti_chk = ICapti - OCapti
         !Compare this with DCapti.  !OK, 08/01/19.
   
         !N inputs
            INapti = INaxxa_apt1 + INphloem_apti        !kg N stem-1 day-1.
         !N outputs
            ONapti = ONapt4_a + ONapti_mort &
                              + ONapti_sn  + ONapti_prune
         DNapti_chk = INapti - ONapti
         !Compare this with DNapti. ok 08/01/19.
   
      !C and N checks for all apterous aphids, apt
         !C inputs
            ICphloem_apt = ICphloem_apta + ICphloem_apti
            ICapt = ICphloem_apt + ICalaa_apt1        !kg C stem-1 day-1.
         !C outputs
            OCapt_env = OCapta_env + OCapti_env
            OCapt_hon = OCapta_hon + OCapti_hon
            OCapt_mort = OCapta_mort + OCapti_mort
            OCapt_sn = OCapta_sn + OCapti_sn
            OCapt_prune = OCapta_prune + OCapti_prune
            OCapt = OCapt_env + OCapt_hon &
                                + OCapt_mort + OCapta_ala1 &
                                + OCapt_sn   + OCapt_prune
   
         DCapt_chk = ICapt - OCapt
         !Compare this with DCapt:
            DCapt = DCapta + DCapti !ok 08/01/19.
   
         !N inputs
            INphloem_apt = INphloem_apta + INphloem_apti
            INapt = INphloem_apt + INalaa_apt1        !kg N stem-1 day-1.
         !N outputs
            ONapt_mort = ONapta_mort + ONapti_mort
            ONapt_sn = ONapta_sn + ONapti_sn
            ONapt_prune = ONapta_prune + ONapti_prune
            ONapt = ONapta_ala1 + ONapt_mort &
                                 + ONapt_sn + ONapt_prune
         DNapt_chk = INapt - ONapt
         !Compare this with DNapt (ok 08/01/19):
            DNapt = DNapta + DNapti
   

!Alate (winged) aphids
!*********************

   !Adult alate aphids, alaa.
      !Input, Ialaa (aphids stem-1 day-1)
         !There are potentially two inputs:
            !1. from ala4 pool, Oala4_a
               Iala4_alaa = Oala4_a
            !2. from immigration, Iimm_alaa
               Constant Iimm_alaa = 0 !aphids stem-1 day-1.
               !For the moment, we put immigration equal to zero.
               Ialaa = Iala4_alaa + Iimm_alaa
         !Oala4_a is calculated under the ala4 pool below.
         !Inputs bring C and N fluxes of
            !These inputs require C and N fluxes of
            ICala4_a = Iala4_alaa * MCalaa           !kg C stem-1 day-1,
            INala4_a = Iala4_alaa * MNalaa           !kg N stem-1 day-1,
               !from within the system, and
            ICimm_alaa = Iimm_alaa * MCalaa       !kg C stem-1 day-1,
            INimm_alaa = Iimm_alaa * MNalaa       !kg N stem-1 day-1,
            ICimm_alaa_m2 = nstems * ICimm_alaa   !kg C m-2 d-1.
            INimm_alaa_m2 = nstems * INimm_alaa   !kg N m-2 d-1.
               !from outside the system.

      !Outputs
         !1. Mortality, Oalaa_mort (aphids stem-1 day-1)
             !Mortality rates are assumed the same for apterous and alate
             !aphids, and are calculated above under the outputs from
             !the apta pool.  Search <Mortality, Oapta_mort>.
            Oalaa_mortz = kaph_mort * alaa    !Alate aphids stem-1 day-1.
            Oalaa_mort = s_aphid * Oalaa_mortz
               !There are associated C and N fluxes:
                  OCalaa_mort = Oalaa_mort * MCalaa       !kg C stem-1 day-1.
                  ONalaa_mort = Oalaa_mort * MNalaa       !kg N stem-1 day-1.

         !2. Thinning.
             !Thinning does not affect aphid numbers per stem.
   
         !3. Self-thinning.
             Oalaa_snz = FGRnstems_sn * alaa           !aphids stem-1 day-1.
                Oalaa_sn = s_aphid * Oalaa_snz
             OCalaa_sn = Oalaa_sn * MCalaa                !kg C stem-1 day-1.
             ONalaa_sn = Oalaa_sn * MNalaa                !kg N stem-1 day-1.
            
         !4. Pruning.
             Oalaa_prunez = kle_prune * alaa         !aphids stem-1 day-1.
                Oalaa_prune = s_aphid * Oalaa_prunez
             OCalaa_prune = Oalaa_prune * MCalaa         !kg C stem-1 day-1.
             ONalaa_prune = Oalaa_prune * MNalaa         !kg N stem-1 day-1.
   
         !5. Emigration.
             !Use a temperature-dependent rate constant, switched off
               !at low aphid densities so that immigrants do not immediately
               !depart.
               !Assume fTaph_emi = fTsh, the standard biological
               !temperature response function (= 1 at 20 deg C):
                  fTaph_emi = fTsh
                Constant kalaa_emi20 = 1            !day-1.
                kalaa_emi = kalaa_emi20 * fTaph_emi * froapta_ala1 !day-1.
                Oalaa_emiz = kalaa_emi * alaa      !aphids stem-1 day-1.
                Oalaa_emi = s_aphid * Oalaa_emiz   !aphids stem-1 day-1.
                OCalaa_emi = Oalaa_emi * MCalaa    !kg C stem-1 day-1.
                ONalaa_emi = Oalaa_emi * MNalaa    !kg N stem-1 day-1.
                Oalaa_emi_m2 =  nstems * Oalaa_emi  !aphids m-2 day-1.
                OCalaa_emi_m2 = nstems * OCalaa_emi !kg C m-2 day-1.
                ONalaa_emi_m2 = nstems * ONalaa_emi !kg N m-2 day-1.

         !Total outputs
                Oalaa = Oalaa_mort + Oalaa_sn + Oalaa_prune + Oalaa_emi
                     !to mortality, self-thinning, pruning, emigration.
         !Fractional outputs are
               IF ( Oalaa .GT. zero ) THEN
                fOalaa_mort =  Oalaa_mort /  Oalaa
                fOalaa_sn =    Oalaa_sn /    Oalaa
                fOalaa_prune = Oalaa_prune / Oalaa
                   fOalaa_prun = fOalaa_prune !For print output only.
                fOalaa_emi =   Oalaa_emi   / Oalaa
                fOalaa_mortemi = Oalaa_mortemi / Oalaa
                   fOalaa_moem = fOalaa_mortemi !For print output only.
               ELSE           
                fOalaa_mort =  csmall
                fOalaa_sn =    csmall
                fOalaa_prune = csmall
                   fOalaa_prun = fOalaa_prune !For print output only.
                fOalaa_emi =   csmall
                fOalaa_mortemi = csmall 
                   fOalaa_moem = csmall !For print output only.
               ENDIF
     
      !Differential equation (alate aphids stem-1 day-1)
           Dalaaz = Ialaa - Oalaa        !alate aphids stem-1 day-1.
            Dalaa = aphidvr * Dalaaz
            alaa = INTEG( Dalaa, alaa0 )    !alate aphids stem-1.
   
              !Rate of change of C, N in the alaa pool is:
                 DCalaa = Dalaa * MCalaa            !kg C stem-1 day-1.
                 DNalaa = Dalaa * MNalaa            !kg N stem-1 day-1.
   
      !Processing (fecundity)
            !Adult winged (alate) aphids (alaa) give birth to nymphs.
            !The rate or fecundity is influenced by
   
            !1. Temperature.  Same response is assumes as for apterous
               !aphids.  See above.

            !2. N substrate concentration in phloem, Nphloem.  
               !Aphid has a maximum volume intake of phloem sap at 20 deg C:
                  Constant valaa_max20 = 2.0E-7 !m3 aphid-1 day-1
                                !2.0E-7 * 10**6 cm3 = 0.2 ml day-1.
                  !Actual volume intake at ambient temperature (assume same T
                     !function applies to intake and fecundity):
                  valaa_maxz = fTaph_fec * valaa_max20  !m3 aphid-1 day-1.
                     valaa_max = s_aphid * valaa_maxz
               !This gives a phloem-volume-limited N intake of
                  INphloem_valaa_max = valaa_max * Nphloem 
                                                      !(kg N aphid-1 day-1).
                       INvalaa_max = INphloem_valaa_max !For output only.

               !This may exceed the N requirement = maximum amount of N which
                  !can be processed of (at 20 deg C):
                  Constant INpalaa_max20 = 2.0E-6  !kg N aphid-1 day-1.
                  !Actual amount which can be processed is
                  INpalaa_maxz = fTaph_fec * INpalaa_max20
                  INpalaa_max = s_aphid * INpalaa_maxz   !kg N aphid-1 day-1.
               !Therefore actual amount of N ingested is the least of the
               !volume-intake-limited (VIL) or the processing-limited values:
                  INphloem_alaa_aphid = m_alaa_fec * &
                     MIN( INphloem_valaa_max, INpalaa_max )
                                                         !kg N aphid-1 day-1.
                     Constant m_alaa_fec = 1 !A dimensionless multiplier
                                             !of alate aphid fecundity.

               !Actual volume of phloem sap ingested is
                  IF ( Nphloem .NE. zero ) THEN
                     valaa = INphloem_alaa_aphid / Nphloem  !m3 aphid-1 day-1.
                  ELSE
                     valaa = clarge !A large number: 7.7777e17.
                  ENDIF
                     vphloem_alaa = valaa !For output only.

               !N intake is (kg N stem-1 day-1):
                  INphloem_alaa = alaa * INphloem_alaa_aphid
   
               !C intake is
                  ICphloem_alaa_aphid = valaa * Cphloem  !kg C aphid-1 day-1.
                  ICphloem_alaa = alaa * ICphloem_alaa_aphid
                      !kg C stem-1 day-1.
   
            !N ingested is assumed completely converted to wingless (apt) and
               !winged (ala) first-instar nymphs, in pools apt1 and ala1.
               !Calculate the fractions
               !of the offspring going to the two forms. This is affected by
               ! 1 Temperature; 2 aphid density; 3 Nutritional status, Nphloem.
                  !1. Temperature, Tair (higher T, more alates)
                        Tairqala = Tair ** qTala
                        Constant qTala = 2                !Dimensionless.
                        Constant KTala = 10               !degrees C.
                        !KTalaq = KTala ** qTala etc, see Initial section.
                        fTalaa_ala1 = Tairqala / ( Tairqala + KTalaq )
                  !2. Aphid (total) density, roaph
                        ![aphids (m2 leaf area)-1].
                        !Higher density, more alates (winged).
                        roaphalaq = roaph ** qroala
                        Constant qroala = 2        !Dimensionless.
                        Constant Kroaphala = 1000.0!aphids (m2 leaf area)-1.
                                                !See comments under
                                                !"Kroaphapt = 1000.0 "
                        froalaa_ala1 = roaphalaq / &
                                ( roaphalaq + Kroaphalaq )
                           froalaa_al1 = froapta_ala1 !For output only.
                        !For Kroaphalaq = Kroaphala ** qroala
                           !etc, see Initial section.
                  !3. Nutritional status, Nphloem.
                        !High Nphloem, few alates (winged), fNalaa_ala1 --> 0.
                        !Nphloem = 0, fNapt = 0, all alates.
                        Nqala = Nphloem ** qNala
                        Constant qNala = 2  !Dimensionless.
                        Constant KNala = 4  !kg N m-3.  Was 1. 
                                            !See "KNapt = " above.
                                            !Equivalent to Nsh = 0.01.
                        fNalaa_ala1 = one / ( one + Nqala / KNalaq )
                        !For KNalaq = KNala ** qNala etc, see Initial section.
   
                  !Combining these 3 factors:
                     falaa_ala1 = fTalaa_ala1 * froalaa_ala1 * fNalaa_ala1
                  !The fraction of offspring which are apterous (wingless) is:
                     falaa_apt1 = one - falaa_ala1
   
               !N ingested by alate females = INphloem_alaa
               !(kg N stem-1 day-1), is converted into 1st instar nymphs at
               !the rate of (aphids stem-1 d-1)
                  Oalaa_axx1 = INphloem_alaa / &
                                ( falaa_apt1 * MNapt1 + falaa_ala1 * MNala1 ) 
                                                          !aphids stem-1 day-1.
               !Fractional fecundity of alate adult aphids is: 
                  IF ( alaa .EQ. zero ) THEN 
                       ffecalaa = csmall
                  ELSE
                       ffecalaa = Oalaa_axx1 / alaa  !d-1.
                  ENDIF

               !These are input to the apt1 and ala1 pools at rates
                  Oalaa_apt1 = falaa_apt1 * Oalaa_axx1   !aphids stem-1 d-1.
                     Ialaa_apt1 = Oalaa_apt1
                  Oalaa_ala1 = falaa_ala1 * Oalaa_axx1 !aphids stem-1 d-1.
                     Ialaa_ala1 = Oalaa_ala1

               !There is an N flux from alaa associated with this aphid flux:
                  ONalaa_apt1 = Ialaa_apt1 * MNapt1
                  ONalaa_ala1 = Ialaa_ala1 * MNala1
                  ONalaa_axx1 = ONalaa_apt1 + ONalaa_ala1  !kg N stem-1 day-1.

               !Total fecundity of alate and apterous adults is:
                    Oaxxa_axx1 = Oalaa_axx1 + Oapta_axx1 !aphids stem-1 d-1.
                         !The offspring of both alate and apterous adults are
                         !1st instar = nymphs. See statements "Oalaa_axx1 = " 
                         !and "Oapta_axx1 = " above. 
               !Fractional fecundity is: 
                  IF ( axxa .EQ. zero ) THEN !axxa = apta + alaa aphids/stem
                       ffecaxxa = csmall
                  ELSE
                       ffecaxxa = Oaxxa_axx1 / axxa  !d-1.
                  ENDIF


               !Carbon fluxes, to respiration, offspring and honeydew
                  !Carbon intake is ICphloem_alaa (kg C stem-1 day-1).
                  !Assume a fraction of this is respired:
                     Ralaa = fCaph_resp * ICphloem_alaa !kg C stem-1 day-1.
                                !Constant fCaph_resp = 0.5
                     OCalaa_env = Ralaa   !Put into standard notation.
                  !Some is used for offspring (axx1 denotes apt1 and ala1):
                     OCalaa_apt1 = Ialaa_apt1 * MCapt1
                     OCalaa_ala1 = Ialaa_ala1 * MCala1
                     OCalaa_axx1 = OCalaa_apt1 + OCalaa_ala1
                        !kg C stem-1 day-1.
                  !The rest is honeydew:
                     OCalaa_hon = ICphloem_alaa - OCalaa_env &
                                                      - OCalaa_axx1
                                                        !kg C stem-1 day-1.

      !Development rates
         !depend on temperature (principally) and nutrition (Nphloem).
         !They are assumed the same for apterous and alate aphids,
         !and are calculated above. Search <!Development rates>.
         !Combined effects of T and N are
            !fTNaph_dev = fTaph_dev * fNaph_dev
   
         !Rate constants are (day-1)
            kala1_2 = kala1_220 * fTNaph_dev
            kala2_3 = kala2_320 * fTNaph_dev
            kala3_4 = kala3_420 * fTNaph_dev
            kala4_a = kala4_a20 * fTNaph_dev
            Constant kala1_220 = 0.188888889, kala2_320 = 0.2125, &
                     kala3_420 = 0.242857, kala4_a20 = 0.2833333    !d-1.

               !Alate aphid development times at 20 oC:
               tauala1_220 = one / kala1_220; tauala2_320 = one / kala2_320 !d
               tauala3_420 = one / kala3_420; tauala4_a20 = one / kala4_a20 !d
               !Overall alate development time is
               tauala1_a20 = tauala1_220 + tauala2_320 + tauala3_420 &
                           + tauala4_a20 ! = 5.294 + 4.706 + 4.1176 + 3.529 
               ! = 17.64 d. See Dixon 1998, p 109, Table 6.1.
               !This block could be moved into the initial section.


   !Juvenile alate (winged) aphids, 4 instars, ala1-4.
   
      !Inputs, Ialai (aphids stem-1 day-1)
            !Iapta_ala1 and Ialaa_ala1 are outputs from the apta and
            !alaa pools.
            Iala1_2 = Oala1_2  !See below.
            Iala2_3 = Oala2_3
            Iala3_4 = Oala3_4
         !Put inputs into standard notation:
            Iala1 = Iapta_ala1 + Ialaa_ala1
            Iala2 = Iala1_2
            Iala3 = Iala2_3
            Iala4 = Iala3_4
   
      !Outputs.
         !1. Development.
               Oala1_2z = ala1 * kala1_2        !Alate aphids stem-1 day-1.
                  Oala1_2 = s_aphid * Oala1_2z
               Oala2_3z = ala2 * kala2_3
                  Oala2_3 = s_aphid * Oala2_3z
               Oala3_4z = ala3 * kala3_4
                  Oala3_4 = s_aphid * Oala3_4z
               Oala4_az = ala4 * kala4_a
                  Oala4_a = s_aphid * Oala4_az

         !2. Mortality.
             !Assume the same constant, kaph_mort (see above), applies to 
             !all 4 instars (also apterous = alate mortality):
                Oala1_mortz = kaph_mort * ala1 !Alate aphids stem-1 day-1.
                    Oala1_mort = s_aphid * Oala1_mortz
                Oala2_mortz = kaph_mort * ala2
                    Oala2_mort = s_aphid * Oala2_mortz
                Oala3_mortz = kaph_mort * ala3
                    Oala3_mort = s_aphid * Oala3_mortz
                Oala4_mortz = kaph_mort * ala4
                    Oala4_mort = s_aphid * Oala4_mortz

             !Mortality of all 4 instars:
                    Oalai_mort = Oala1_mort + Oala2_mort + Oala3_mort + &
                                Oala4_mort        !aphids stem-1 day-1.
             !Add on mortality of alate adults:
                    Oala_mort = Oalai_mort + Oalaa_mort !See above.
             !Now add on emigration of adult alates:
                    Oaph_mortemi = Oaph_mort + Oalaa_emi !aphids stem-1 d-1
                !Note: see above statement for total op from alate adults:
                    !Oalaa = Oalaa_mort + Oalaa_sn + Oalaa_prune + Oalaa_emi
                          !to mortality, self-thinning, pruning, emigration.
                    !But I think our statement for Oala_mortemi is ok.

               !Total aphid mortality:
                    Oaph_mort = Oapt_mort + Oala_mort !aphids stem-1 d-1.

               !Total adult alate mortality + emigration: 
                    Oalaa_mortemi = Oalaa_mort + Oalaa_emi !aphids stem-1 d-1.
                      !Oalaa_mort = kaph_mort * alaa 
               IF ( aph .EQ. zero ) THEN !Fractional mortality + emigration
                                         !rate of aphids:
                    fmort = csmall; fmortemi = csmall   !d-1.
               ELSE  !aphids are present.
                  !Fractional death rate of aphids (instantaneous value):
                     fmort = Oaph_mort / aph               !d-1.
                  !Fractional mortality + emigration rate of aphids:
                     fmortemi = Oaph_mortemi / aph         !d-1.
               ENDIF

               IF ( alaa .EQ. zero ) THEN !Fractional emigration
                                           !rate of adult alates:
                    femi = csmall; !d-1.
               ELSE
                  !Fractional emigration rate of adult alates:
                      femi = Oalaa_emi / alaa         !d-1.
               ENDIF


         !2. Thinning.
             !Thinning does not affect aphid numbers per stem.

         !3. Self-thinning.
               Oala1_snz = FGRnstems_sn * ala1 !Alate aphids stem-1 day-1.
                  Oala1_sn = s_aphid * Oala1_snz
               Oala2_snz = FGRnstems_sn * ala2
                  Oala2_sn = s_aphid * Oala2_snz
               Oala3_snz = FGRnstems_sn * ala3
                  Oala3_sn = s_aphid * Oala3_snz
               Oala4_snz = FGRnstems_sn * ala4
                  Oala4_sn = s_aphid * Oala4_snz

         !4. Pruning. Alate aphids stem-1 day-1.
               Oala1_prunez = kle_prune * ala1
                  Oala1_prune = s_aphid * Oala1_prunez
               Oala2_prunez = kle_prune * ala2
                  Oala2_prune = s_aphid * Oala2_prunez
               Oala3_prunez = kle_prune * ala3
                  Oala3_prune = s_aphid * Oala3_prunez
               Oala4_prunez = kle_prune * ala4
                  Oala4_prune = s_aphid * Oala4_prunez

         !Total outputs (aphids stem-1 day-1):
            Oala1 = Oala1_2 + Oala1_mort + Oala1_sn + Oala1_prune
            Oala2 = Oala2_3 + Oala2_mort + Oala2_sn + Oala2_prune
            Oala3 = Oala3_4 + Oala3_mort + Oala3_sn + Oala3_prune
            Oala4 = Oala4_a + Oala4_mort + Oala4_sn + Oala4_prune
   
         !Differential equations (aphids stem-1 day-1):
            Dala1z = Iala1 - Oala1
            Dala2z = Iala2 - Oala2
            Dala3z = Iala3 - Oala3
            Dala4z = Iala4 - Oala4
         !
            Dala1 = aphidvr * Dala1z
            Dala2 = aphidvr * Dala2z
            Dala3 = aphidvr * Dala3z
            Dala4 = aphidvr * Dala4z

         !Integrals:
            ala1 = INTEG( Dala1, ala10 )  !alate aphids stem-1.
            ala2 = INTEG( Dala2, ala20 )
            ala3 = INTEG( Dala3, ala30 )
            ala4 = INTEG( Dala4, ala40 )
   
              !Rate of change of C, N in the ala1-4 pools is:
                 DCalai = Dala1 * MCala1 + Dala2 * MCala2 + &
                          Dala3 * MCala3 + Dala4 * MCala4
                             !kg C stem-1 day-1.
                 DNalai = Dala1 * MNala1 + Dala2 * MNala2 + &
                          Dala3 * MNala3 + Dala4 * MNala4
                             !kg N stem-1 day-1.
   
   
         !C, N fluxes associated with pools ala1-4.
             !Rates of change of C, N in the four ala pools:
                 DCala1 = Dala1 * MCala1               !kg C stem-1 day-1.
                 DNala1 = Dala1 * MNala1               !kg N stem-1 day-1.
                 DCala2 = Dala2 * MCala2               !kg C stem-1 day-1.
                 DNala2 = Dala2 * MNala2               !kg N stem-1 day-1.
                 DCala3 = Dala3 * MCala3               !kg C stem-1 day-1.
                 DNala3 = Dala3 * MNala3               !kg N stem-1 day-1.
                 DCala4 = Dala4 * MCala4               !kg C stem-1 day-1.
                 DNala4 = Dala4 * MNala4               !kg N stem-1 day-1.

            !Inputs of C, N from offspring from adult apta, alaa pools:
               ICapta_ala1 = Iapta_ala1 * MCala1        !kg C stem-1 day-1.
               INapta_ala1 = Iapta_ala1 * MNala1        !kg N stem-1 day-1.
               ICalaa_ala1 = Ialaa_ala1 * MCala1        !kg C stem-1 day-1.
               INalaa_ala1 = Ialaa_ala1 * MNala1        !kg N stem-1 day-1.
               ICaxxa_ala1 = ICapta_ala1 + ICalaa_ala1  !kg C stem-1 day-1.
               INaxxa_ala1 = INapta_ala1 + INalaa_ala1  !kg N stem-1 day-1.

            !Inputs of N, C from phloem:
                 !Assume N required from phloem is the amount required to
                 !increase the N component of mass of the aphids which 
                 !enter the next pool:
                     INphloem_ala1 = Oala1_2 * delMNala2_1 !kg N stem-1 day-1.
                     INphloem_ala2 = Oala2_3 * delMNala3_2 
                     INphloem_ala3 = Oala3_4 * delMNala4_3
                     INphloem_ala4 = Oala4_a * delMNalaa_4
                     !Total N intake from phloem:
                     INphloem_alai = INphloem_ala1 + &
                                     INphloem_ala2 + &
                                     INphloem_ala3 + &
                                     INphloem_ala4         !kg N stem-1 day-1.
                 !C flux accompanying this N flux is:
                     ICphloem_alai = rCNphloem * INphloem_alai
                        !kg C stem-1 day-1.
                                                               
            !Outputs of C, N.
                 !The C flux from the phloem, ICphloem_alai, is used for
                 !respiration, increase in instar mass, and honeydew.
                 !Respiration. Assume a fraction of this is respired:
                     Ralai = fCaph_resp * ICphloem_alai !kg C stem-1 day-1.
                                !Constant fCaph_resp = 0.5
                     OCalai_env = Ralai           !Put into standard notation.
                 !Increase in instar mass (development = dev).  This is an
                     !internal transfer.
                     ICphloem_ala1 = Oala1_2 * delMCala2_1
                        !kg C stem-1 day-1.
                     ICphloem_ala2 = Oala2_3 * delMCala3_2 
                     ICphloem_ala3 = Oala3_4 * delMCala4_3
                     ICphloem_ala4 = Oala4_a * delMCalaa_4
                     !C intake required for instar development:
                     OCphloem_alai = ICphloem_ala1 + &
                                         ICphloem_ala2 + &
                                         ICphloem_ala3 + &
                                         ICphloem_ala4 !kg C stem-1 day-1.
                  !The rest is honeydew (external transfer):
                     OCalai_hon = ICphloem_alai - OCalai_env &
                                                - OCphloem_alai
                                                           !kg C stem-1 day-1.
            !Output of C, N ala4 to ala:   
               OCala4_a = Oala4_a * MCalaa                 !kg C stem-1 day-1.
               ONala4_a = Oala4_a * MNalaa                 !kg N stem-1 day-1.
   
            !Mortality.
                OCala1_mort = Oala1_mort * MCala1       !kg C stem-1 day-1.
                ONala1_mort = Oala1_mort * MNala1       !kg N stem-1 day-1.
                OCala2_mort = Oala2_mort * MCala2       !kg C stem-1 day-1.
                ONala2_mort = Oala2_mort * MNala2       !kg N stem-1 day-1.
                OCala3_mort = Oala3_mort * MCala3       !kg C stem-1 day-1.
                ONala3_mort = Oala3_mort * MNala3       !kg N stem-1 day-1.
                OCala4_mort = Oala4_mort * MCala4       !kg C stem-1 day-1.
                ONala4_mort = Oala4_mort * MNala4       !kg N stem-1 day-1.
                OCalai_mort = OCala1_mort + OCala2_mort + &
                              OCala3_mort + OCala4_mort !kg C stem-1 day-1.
                ONalai_mort = ONala1_mort + ONala2_mort + &
                              ONala3_mort + ONala4_mort !kg N stem-1 day-1.
   
            !Self-thinning.
                OCala1_sn = Oala1_sn * MCala1          !kg C stem-1 day-1.
                ONala1_sn = Oala1_sn * MNala1          !kg N stem-1 day-1.
                OCala2_sn = Oala2_sn * MCala2          !kg C stem-1 day-1.
                ONala2_sn = Oala2_sn * MNala2          !kg N stem-1 day-1.
                OCala3_sn = Oala3_sn * MCala3          !kg C stem-1 day-1.
                ONala3_sn = Oala3_sn * MNala3          !kg N stem-1 day-1.
                OCala4_sn = Oala4_sn * MCala4          !kg C stem-1 day-1.
                ONala4_sn = Oala4_sn * MNala4          !kg N stem-1 day-1.
                OCalai_sn = OCala1_sn + OCala2_sn + &
                              OCala3_sn + OCala4_sn    !kg C stem-1 day-1.
                ONalai_sn = ONala1_sn + ONala2_sn + &
                              ONala3_sn + ONala4_sn    !kg N stem-1 day-1.
   
            !Pruning.
                OCala1_prune = Oala1_prune * MCala1       !kg C stem-1 day-1.
                ONala1_prune = Oala1_prune * MNala1       !kg N stem-1 day-1.
                OCala2_prune = Oala2_prune * MCala2       !kg C stem-1 day-1.
                ONala2_prune = Oala2_prune * MNala2       !kg N stem-1 day-1.
                OCala3_prune = Oala3_prune * MCala3       !kg C stem-1 day-1.
                ONala3_prune = Oala3_prune * MNala3       !kg N stem-1 day-1.
                OCala4_prune = Oala4_prune * MCala4       !kg C stem-1 day-1.
                ONala4_prune = Oala4_prune * MNala4       !kg N stem-1 day-1.
                OCalai_prune = OCala1_prune + OCala2_prune + &
                              OCala3_prune + OCala4_prune !kg C stem-1 day-1.
                ONalai_prune = ONala1_prune + ONala2_prune + &
                              ONala3_prune + ONala4_prune !kg N stem-1 day-1.


      !C and N checks for alaa pool.  kg C, N stem-1 day-1.
         !C inputs
            ICalaa = ICala4_a + ICphloem_alaa + ICimm_alaa
         !C outputs
            OCalaa = OCalaa_env + OCalaa_axx1 + OCalaa_hon + OCalaa_mort &
                                + OCalaa_sn   + OCalaa_prune  + OCalaa_emi
         DCalaa_chk = ICalaa - OCalaa
         !Compare this with DCalaa.
   
         !N inputs
            INalaa = INala4_a + INphloem_alaa + INimm_alaa !kg N stem-1 day-1.
         !N outputs
            ONalaa = ONalaa_axx1 + ONalaa_mort &
                                 + ONalaa_sn + ONalaa_prune + ONalaa_emi
         DNalaa_chk = INalaa - ONalaa
         !Compare this with DNalaa.

      !C and N checks for the 4 alai pools.  kg C, N stem-1 day-1.
         !C inputs
            ICalai = ICaxxa_ala1 + ICphloem_alai
         !C outputs
            OCalai = OCala4_a + OCalai_env + OCalai_hon + OCalai_mort &
                              + OCalai_sn  + OCalai_prune
         DCalai_chk = ICalai - OCalai
         !Compare this with DCalai.
   
         !N inputs
            INalai = INaxxa_ala1 + INphloem_alai
         !N outputs
            ONalai = ONala4_a + ONalai_mort &
                              + ONalai_sn  + ONalai_prune
         DNalai_chk = INalai - ONalai
         !Compare this with DNalai.

      !C and N checks for all alate aphids, ala.  kg C, N stem-1 day-1.
         !C inputs
            ICphloem_ala = ICphloem_alaa + ICphloem_alai
            ICala = ICphloem_ala + ICimm_alaa + ICapta_ala1
               !kg C stem-1 day-1.
         !C outputs
            OCala_env = OCalaa_env + OCalai_env
            OCala_hon = OCalaa_hon + OCalai_hon
            OCala_mort = OCalaa_mort + OCalai_mort
            OCala_sn = OCalaa_sn + OCalai_sn
            OCala_prune = OCalaa_prune + OCalai_prune
            OCala = OCala_env + OCala_hon &
                                + OCala_mort + OCalaa_apt1 &
                                + OCala_sn   + OCala_prune + OCalaa_emi
         DCala_chk = ICala - OCala
         !Compare this with DCala:
            DCala = DCalaa + DCalai

         !N inputs (kg N stem-1 day-1)
            INphloem_ala = INphloem_alaa + INphloem_alai
            INala = INphloem_ala + INimm_alaa + INapta_ala1
                      !kg N stem-1 day-1.
         !N outputs
            ONala_mort = ONalaa_mort + ONalai_mort
            ONala_sn = ONalaa_sn + ONalai_sn
            ONala_prune = ONalaa_prune + ONalai_prune
            ONala = ONalaa_apt1 + ONala_mort &
                                 + ONala_sn + ONala_prune + ONalaa_emi
         DNala_chk = INala - ONala
         !Compare this with DNala:
            DNala = DNalaa + DNalai


      !C and N checks for all aphids (kg C, N stem-1 day-1):
      !*****************************
         !C inputs
            ICphloem_aph = ICphloem_apt + ICphloem_ala !kg C stem-1 d-1.
            ICphloem_aph_m2 = nstems * ICphloem_aph !kg C m-2 ground d-1.

            IF ( cc4aphid ) THEN    !Constant conditions for aphid growth.
               OCSle_aph = 0.0      !Do not remove C from phloem.
            ELSE
               OCSle_aph = ICphloem_aph  !This appears as an output from the
                                         !foliage (le) C substrate (CS) pool.
            ENDIF
               !Default: cc4aphid = .false.

            ICaph = ICphloem_aph + ICimm_alaa  !kg C stem-1 day-1.
            ICaph_m2 = nstems * ICaph          !kg C m-2 day-1.

         !C outputs (kg C stem-1 day-1).
              OCaph_env = OCapt_env + OCala_env    !A system output.
                 !This is all respiration, CO2, 
                     OCaph_CO2 = OCaph_env !For output only.
                 !Respiration from aphids: 
                        Raph = Ralaa + Ralai + Rapta + Rapti
                        Raph_chk = OCaph_env  !Checked ok.
                 OCaph_env_m2 = nstems * OCaph_env !kg m-2 gnd d-1.
                 OCaph_CO2_m2 = OCaph_env_m2 !Output only.
              OCaph_hon = OCapt_hon + OCala_hon    !Surface litter input.
                 OCaph_hon_m2 = nstems * OCaph_hon !kc C m-2 d-1.
              OCaph_mort = OCapt_mort + OCala_mort !Surface litter input.
              OCaph_sn = OCapt_sn + OCala_sn       !Accounting term.
              OCaph_prune = OCapt_prune + OCala_prune 
                 OCaph_prune_m2 = nstems * OCaph_prune !kc C m-2 d-1.
              OCaph1 = OCaph_env + OCaph_hon + OCaph_mort &
                                + OCaph_prune +  OCalaa_emi
              OCaph = OCaph1 + OCaph_sn              !kg C stem-1 d-1.
              OCaph_mort_m2 = nstems * OCaph_mort !kg C m-2 day-1. Surface 
                                      !litter C input from aphid mortality.
              OCaph_m2 = nstems * OCaph1 + Onstems_th * Caph !kg C m-2 day-1.

         DCaph_chk = ICaph - OCaph          !kg C stem-1 day-1.
         DCaph_m2_chk = ICaph_m2 - OCaph_m2 !kg C m-2 day-1.

         !Compare this with DCaph:
            DCaph = DCala + DCapt                    !kg C stem-1 day-1.
            DCaph_m2 = nstems * DCaph + Dnstems * Caph !kg C m-2 day-1.
                   !?? Should this be Onstems_th, rather than Dnstems.

         !N inputs (kg N stem-1 day-1)
            INphloem_aph = INphloem_apt + INphloem_ala
            INphloem_aph_m2 = nstems * INphloem_aph !kg N m-2 ground d-1.
            ONSle_aph = INphloem_aph  !This is an output from the
                                      !foliage (le) N substrate (NS) pool.

            IF ( cc4aphid ) THEN    !Constant conditions for aphid growth.
               ONSle_aph = 0.0      !Do not remove N from phloem.
            ELSE
               ONSle_aph = INphloem_aph  !This appears as an output from the
            ENDIF                        !foliage (le) N substrate (NS) pool.
               !default cc4aphid = .false.

            INaph = INphloem_aph + INimm_alaa    !kg N stem-1 day-1.
            INaph_m2 = nstems * INaph            !kg N m-2 day-1.

!   PROCEDURAL
!      ilogd = i9
!      IF ( calllogd ) CALL LOGD( .true. ) !1
          ! If calllogd = .true. then output occurs.
!   END

         !N outputs (kg N stem-1 day-1)
            ONaph_mort = ONapt_mort + ONala_mort
            ONaph_sn = ONapt_sn + ONala_sn
            ONaph_prune = ONapt_prune + ONala_prune
               ONaph_prune_m2 = nstems * ONaph_prune !kg N m-2 d-1.
            ONaph1 = ONaph_mort + ONaph_prune + ONalaa_emi
            ONaph = ONaph1 + ONaph_sn      !kg N stem-1 day-1.
            ONaph_mort_m2 = nstems * ONaph_mort !kg N m-2 day-1. Surface 
                                    !litter N input from aphid mortality.
            ONaph_m2 = nstems * ONaph1 + Onstems_th * Naph  !kg N m-2 day-1.

         DNaph_chk = INaph - ONaph
         DNaph_m2_chk = INaph_m2 - ONaph_m2 !kg N m-2 day-1.
         !Compare this with DNaph:
            DNaph = DNapt + DNala
            DNaph_m2 = nstems * DNaph + Dnstems * Naph !kg N m-2 day-1.

         !Some ancillary output relations for the aphid submodel.
            !Honeydew is assigned directly to the soil surface metabolic
               !litter pool, Csurf_li_met.  Therefore
                 ICaph_surf_li_met = OCaph_hon_m2  !kg C m-2 day-1.

            !Mortality, pruning and thinning. C flux in the dead or dying
               !aphids is assigned
               !fractionally to the surface litter cellulose and lignin
               !pools, Csurf_li_cel and Csurf_li_lig (which have fixed
               !C:N ratios).  Excess N is assigned
               !to the metabolic surface litter pool, Nsurf_li_met.
                   OCaph_th_m2 = Onstems_th * Caph  !kg C m-2 d-1.
                ICaph_surf_li = OCaph_mort_m2 + OCaph_prune_m2 &
                                + OCaph_th_m2      !kg C m-2 d-1.
                   ONaph_th_m2 = Onstems_th * Naph  !kg N m-2 d-1.
                INaph_surf_li = ONaph_mort_m2 + ONaph_prune_m2 &
                                + ONaph_th_m2       !kg N m-2 d-1.

!End of APHID SUBMODEL



!PRODUCTS
   !Thinning products. (calculated in Tree Submodel Thinning section)
   !Inputs (fluxes are total C, N, W) (kg C, N, water m-2 day-1):
      !(We also put pruning products into the thinning products pools)
                 ICprune_prod = OCXbr_prune_prod + OCXst_prune_prod
                 ICpru_prod = ICprune_prod !For output only.
                 INprune_prod = ONXbr_prune_prod + ONXst_prune_prod
       ICprthd = ICth_pr + ICprune_prod !Whether or not these pool are
       INprthd = INth_pr + INprune_prod !decayed is a separate option.
                                      !See kptdec below.
       IWprthd = OWth_pr !No input from pruning with present assumptions.

   
   !Outputs (kg C, N, water m-2 day-1):
       OCprthd = kptdec * Cptd
       ONprthd = kptdec * Nptd
       OWprthd = kptdec * Wptd
       Constant kptdec = 0.378e-3 !day-1.
               !This is the decay rate of thinning products. 
               !Equivalent to a half-life of 5 years.
               !kptdec = ln(2) /(365 * half-life in years).
   
   !Differential equations:
      !Non-decayed products of thinning - these are simple accumulators of
               !the products of thinning (pt), accumulated in Cpt, Npt, Wpt:
          DCpt = ICprthd                              !kg total C m-2 day-1.
           Cpt = INTEG( DCpt, Cpt0 )                  !kg C m-2.
                   Constant Cpt0 = 0.0                !kg C m-2.
          DNpt = INprthd                              !kg total N m-2 day-1.
           Npt = INTEG( DNpt, Npt0 )                  !kg N m-2.
                   Constant Npt0 = 0.0                !kg N m-2.
          DWpt = IWprthd                              !kg water m-2 day-1.
           Wpt = INTEG( DWpt, Wpt0 )                  !kg water m-2.
                   Constant Wpt0 = 0.0                !kg water m-2.
      
         !Structural dry mass (XDM) of non-decayed products of thinning (pt):
            !Ratio of branch structural DM to total branch carbon:
                 rbrX_Ctot = MXbr / MCbr               !kg XDM (kg total C)-1.
            !Ratio of stem structural DM to total stem carbon:
                 rstX_Ctot = MXst / MCst               !kg XDM (kg total C)-1.
            !Input of XDM due to thinning into the products of thinning pool:
                 IXthin_pt = ICbrth_pr * rbrX_Ctot + ICstth_pr * rstX_Ctot
                                                            !kg XDM m-2 day-1.
            !Input of XDM due to pruning (fluxes assumed free from 
            !substrates and meristem) into the same pt (products of
            !thinning) pool:
               IXprune_pt = OCXbr_prune_prod / fCbrX &
                            + OCXst_prune_prod / fCstX !kg XDM m-2 day-1.
               IVprune_pt = IXprune_pt / rostem        !m3 wood (m2 ground)-1
                                                       !day-1. From pruning.
              !Put this pruning flux on to an annual per ha basis:
               Vprune_hayr = IVprune_pt * c3650000     !m3 wood ha-1 year-1.
          IXpt = IXthin_pt + IXprune_pt                !kg XDM m-2 day-1.
          IVpt = IXpt / rostem                         !m3 wood (m2 ground)-1
                                                       !day-1.
          IVpt_hayr = c3650000 * IVpt                  !m3 wood ha-1 year-1.

          DXpt = IXpt
           Xpt = INTEG( DXpt, Xpt0 )                   !kg XDM m-2.
                   Constant Xpt0 = 0.0                 !kg XDM m-2.


      !Decaying products of thinning:
          DCptd = ICprthd - OCprthd                    !kg C m-2 day-1.
           Cptd = INTEG( DCptd, Cptd0 )                !kg C m-2.
          DNptd = INprthd - ONprthd                    !kg N m-2 day-1. 
           Nptd = INTEG( DNptd, Nptd0 )                !kg N m-2. 
          DWptd = IWprthd - OWprthd                    !kg water m-2 day-1.  
           Wptd = INTEG( DWptd, Wptd0 )                !kg water H20 m-2.  
      
   
   !Decaying rotation products.
      !Inputs - none; the state variables for the rotation product pools are
         !incremented in the terminal section.
      !Outputs:
          OCprrod = kprdec * Cprd                 !kg C m-2 day-1.
          ONprrod = kprdec * Nprd                 !kg N m-2 day-1.
          OWprrod = kprdec * Wprd                 !kg water m-2 day-1.
               Constant kprdec = 94.5e-6 !day-1.
               !Equivalent to a half-life of 20 years.
               !kprdec = ln(2) /(365 * half-life in years).
   
   !Differential equations:
       DCprd = - OCprrod                              !kg C m-2 day-1. 
        Cprd = INTEG( DCprd, Cprd0 )                  !kg C m-2. 
       DNprd = - ONprrod                              !kg N m-2 day-1. 
        Nprd = INTEG( DNprd, Nprd0 )                  !kg N m-2.

       DWprd = - OWprrod                              !kg water m-2 day-1.
        Wprd = INTEG( DWprd, Wprd0 )                  !kg water m-2.
   

   !Mass of C, N, W in products of thinning and rotation (decaying):
       Cptrd = Cptd + Cprd !kg C m-2.
       Nptrd = Nptd + Nprd !kg N m-2.
       Wptrd = Wptd + Wprd !kg W m-2.
   
   !Rate of change of C, N, W in products: 
       DCptrd = DCptd + DCprd !kg C m-2 day-1.
       DNptrd = DNptd + DNprd !kg N m-2 day-1.
       DWptrd = DWptd + DWprd !kg W m-2 day-1.
   
   !C, N, W inputs to the decaying product pools:
       !ICprthd
       !INprthd
       !IWprthd
   
   !Outputs:
       OCprd = OCprthd + OCprrod 
       ONprd = ONprthd + ONprrod 
       OWprd = OWprthd + OWprrod 
   
   !Check rates of changes:
       DCptrd_chk = ICprthd - OCprd 
       DNptrd_chk = INprthd - ONprd 
       DWptrd_chk = IWprthd - OWprd 
   
!End of PRODUCTS


!WHOLE-SYSTEM 
   !Whole-system (tree + litter + soil + products) checks:
   !Carbon input and output to system (kg C m-2 day-1):
      ICsys = Pcan + ICimm_alaa_m2
      OCsys = Rtree_gnd + OCle_IP_atm_gnd + OCtree_fire_atm &
                        + Rsoil + OCsol_lch + OCsurf_li_fire_atm &
                        + OCprthd + OCprrod &
                        + nstems * ( OCaph_env + OCalaa_emi )
   !Rate of increase in system C:
      DCsys = nstems * DMCtree + Dnstems * MCtree + DCsoil &
               + DCptd + DCprd + nstems * DCaph + Dnstems * Caph
   !This should be equal to:
      DCsys_chk = ICsys - OCsys
   
   !Nitrogen input and output to system (kg N m-2 day-1):
      INsys = INenv_soil + INimm_alaa_m2
      ONsys = ONSle_atm_gnd + ONtree_fire_atm + ONsoil_env &
                            + ONprthd + ONprrod &
                            + nstems * ONalaa_emi

      INsysmaxt = INsys * maxt  !For debugging purposes.
      ONsysmaxt = ONsys * maxt  !For debugging purposes.
   !Rate of increase in system N:
      DNsys = nstems * DMNtree + Dnstems * MNtree + DNsoil &
               + DNptd + DNprd + nstems * DNaph + Dnstems * Naph
      DNsysmaxt = DNsys * maxt  !For debugging purposes.
   
   !This should be equal to:
      DNsys_chk = INsys - ONsys
   
   !Whole system C and N (kg C m-2):
              Ctreesoil = Ctree + Csoil
              Ctreesoilptrd = Ctreesoil + Cptrd
              Ctreelitter = Ctree + Clitter
      Csys =  Ctree + Csoil + Cptrd + Caph_m2
              Ntreesoil = Ntree + Nsoil
              Ntreesoilptrd = Ntreesoil + Nptrd
              Ntreelitter = Ntree + Nlitter
      Nsys =  Ntree + Nsoil + Nptrd + Naph_m2   !kg N m-2.
 
     rCNsys = Csys / Nsys                       !kg C / kg N. C/N ratio.
     !Note that Csoil and Nsoil include the litter components.

   !For system water, see end of Water submodel section.
!END of WHOLE-SYSTEM 



!CAPTURE SOME QUANTITIES AT t = 0 HOURS.
   IF ( t .EQ. zero ) THEN !Values of variables at time 0 are captured:
      LAI_t0 = LAI
      nstems_t0 = nstems  !Stem no / m2.
      Aleaf_t0 = Aleaf
      Aleaf1_t0 = Aleaf1
      Aleaf2_t0 = Aleaf2
      Aleaf3_t0 = Aleaf3
      Aleaf4_t0 = Aleaf4
      nseeds_t0 = nseeds
      dormant_t0 = dormant; s_deciduous_t0 = s_deciduous
      Mtree_t0 = Mtree;             MXtree_t0 = MXtree;  MXst_t0 = MXst
      MCSle_t0 = MCSle; MNSle_t0 = MNSle; MNph_t0 = MNph; 
      MXle_t0 = MXle !Foliage strucural dry matter, kg XMN stem-1.
      MCSbr_t0 = MCSbr; MXbrm_t0 = MXbrm; MNSbr_t0 = MNSbr; MXbr_t0 = MXbr
      MCSst_t0 = MCSst; MCstorest_t0 = MCstorest; MXstm_t0 = MXstm
      MNSst_t0 = MNSst; MXst_t0 = MXst
      
      log10nstems_t0 = log10nstems
      log10Mtree_t0 = log10Mtree;   log10MXst_t0 = log10MXst
      log10MXtree_t0 = log10MXtree
      Char_t0 = Char
      Cst_t0 = Cst;  Cstorest_t0 = Cstorest                 ![C].
      Csys_t0 =  Csys;  Nsys_t0 = Nsys;  Wsys_t0 = Wsys   !kg C, N, W m-2.
      Ctree_t0 = Ctree; Ntree_t0 = Ntree; 
                                   Wtree_t0 = Wtree  !kg C, N, W m-2.
      Csoil_t0 = Csoil; Nsoil_t0 = Nsoil; Wsoil_t0 = Wsoil  !kg C, N, W m-2.
      !Wsoil is a state variable, whose initial value Wsoil0 is
         !calculated in the Initial Section assuming the soil is at field
         !capacity.  Wsoil0 is not reset at the end of a rotation (Search
         !down <Wsoil0>).

      Wfi_t0 = Wfi  !kg water / stem. State variable, amount of water in fine
            !roots and mycorrhizae.
      CSOM_t0 = CSOM;   NSOM_t0 = NSOM                      !kg C, N m-2.
      CpSOM_t0 = CpSOM;   NpSOM_t0 = NpSOM                  !kg C, N m-2.
      Cptrd_t0 = Cptrd; Nptrd_t0 = Nptrd; Wptrd_t0 = Wptrd  !kg C, N, W m-2.
      Nmin_t0 = Nmin
      !Aphid stuff.
      Aleaf_aph_t0 = Aleaf_aph
      Caph_m2_t0 = Caph_m2;            Naph_m2_t0 = Naph_m2 !kg C, N, m-2.
      aph_t0 = aph;             !Total aphid numbers per stem.
      roaph_t0 = roaph  !Total aphid numbers per m2 colonized foliage.
      Oalaa_emi_t0 = Oalaa_emi    !Alate adults emigrating at t = 0.
      Ialaa_apt1 = Ialaa_apt1
      Iapta_apt1 = Iapta_apt1
      Cphloem_t0 = Cphloem
      Nphloem_t0 = Nphloem
   ENDIF !( t .EQ. zero ) section.


!CAPTURE SOME QUANTITIES AT t = 365 days (1 year).
   !To avoid transients affecting some calculated average quantities.
   IF ( t .EQ. c365 ) THEN !Values of variables at t = 365 days are captured:
      LAI_y1 = LAI
      nstems_y1 = nstems
      nseeds_y1 = nseeds
      Mtree_y1 = Mtree;   MXtree_y1 = MXtree;   MXst_y1 = MXst
      log10nstems_y1 = log10nstems
      log10Mtree_y1 =  log10Mtree
      log10MXst_y1 =   log10MXst
      log10MXtree_y1 = log10MXtree
      log10Mtreesh_y1 = log10Mtreesh
      log10Mtreert_y1 = log10Mtreert
   ENDIF

!CAPTURE SOME QUANTITIES AT t = 670 days (about 22 months, month_r)
   !when aphids (aph) are at about their
   !first substantial peak (c. 10000 aphids per stem) in the Eskdale
   !monthly environment.
   IF ( t .EQ. c670 ) THEN !Values of variables at t = 670 days, months_r c
      !22 months
      Cphloem_t670 = Cphloem
      Nphloem_t670 = Nphloem
   ENDIF

!CAPTURE SOME QUANTITIES AT t = 730 d, 2 years
   IF ( t .EQ. c2yrs ) THEN !Values of variables at t = 730 
      LAI_y2 = LAI
      Cphloem_y2 = Cphloem
      Nphloem_y2 = Nphloem
   ENDIF

!CAPTURE SOME QUANTITIES AT t = 1095 d, 3 years
   IF ( t .EQ. c3yrs ) THEN !Values of variables at t = 1095 
      LAI_y3 = LAI
      Cphloem_y3 = Cphloem
      Nphloem_y3 = Nphloem
   ENDIF

!CAPTURE SOME QUANTITIES AT t = 1825 d, 5 years.
   IF ( yearbeg .AND. iyear .EQ. i5 ) THEN !Values of variables at 5 years.
      LAI_y5 = LAI
      LAIya_y5 = LAIya
      Pcanya_y5 = Pcanya
      Pnetya_y5 = Pnetya
      aphya_y5 = aphya
      nstems_y5 = nstems
      nstemsya_y5 = nstemsya
      nseeds_y5 = nseeds
      Mtree_y5 = Mtree;   MXtree_y5 = MXtree;   MXst_y5 = MXst
      log10nstems_y5 = log10nstems
      log10Mtree_y5 =  log10Mtree
      log10MXst_y5 =   log10MXst
      log10MXtree_y5 = log10MXtree
      log10Mtreesh_y5 = log10Mtreesh
      log10Mtreert_y5 = log10Mtreert
   ENDIF

!CAPTURE SOME QUANTITIES AT t = 7300 d, 20 years.
   IF ( yearbeg .AND. iyear .EQ. i20 ) THEN !Values of variables at 20 years.
      LAI_y20 = LAI
      LAIya_y20 = LAIya
      Pcanya_y20 = Pcanya
      Pnetya_y20 = Pnetya
      aphya_y20 = aphya
      nstems_y20 = nstems
      nstemsya_y20 = nstemsya
      nseeds_y20 = nseeds
      Mtree_y20 = Mtree;   MXtree_y20 = MXtree;   MXst_y20 = MXst
      log10nstems_y20 = log10nstems
      log10Mtree_y20 =  log10Mtree
      log10MXst_y20 =   log10MXst
      log10MXtree_y20 = log10MXtree
      log10Mtreesh_y20 = log10Mtreesh
      log10Mtreert_y20 = log10Mtreert
   ENDIF
 

!CAPTURE SOME QUANTITIES AT 0 HOURS EACH DAY:
   IF ( daybeg ) THEN
      !Check with
         hour_0h = hour  !Hour of day.  Should be 0.0.
      !Environment:
          Tair_0h = Tair; Tsh_0h = Tsh;  Tsoil_0h = Tsoil
      !Leaf area ratio_0h = foliage area / total tree mass:
         IF ( Mtree .GT. zero ) LAR_0h = Aleaf / Mtree !m2 (kg total DM)-1.
      !Specific leaf area_0h =  foliage area / total foliage mass:
         SLA_0h = SLA                    !m2 (kg total foliage DM)-1.

      LAIsun_0h =  ( one - EXP( - kcan * LAI )) / kcan !Sunlit LAI.
      LAIsha_0h = LAI - LAIsun_0h                      !Shaded LAI.

      !Bud mass:
         Mbud_0h = Mbud
       
      !Sum some of these quantities (the more slow moving):
         chk_dy_sum = chk_dy_sum + one !This should be tstop + 1,
            !assuming that the simulation stops when daybeg is true.
         LAR_0h_sum = LAR_0h_sum + LAR_0h
         SLA_0h_sum = SLA_0h_sum + SLA_0h
   ENDIF
 

!Extract some quantities at 12.00 hours every day:
      LOGICAL noon; noon = tdec .GT. t12h1 .AND. tdec .LT. t12h2 
      IF ( noon ) THEN
         hour_12h = hour       !This should be 12.00. 
         jPARsc_12h = jPARsc   !J PAR m-2 s-1.
                               !Light flux density incident on canopy.
         jPARscstep_12h = jPARscstep !Step function for instantaneous light
                               !light flux density on canopy, J (PAR) m-2 s-1
         jPARsc_sun_12h = jPARsc_sun !JPAR m-2 s-1. Direct-beam component
                               !of light flux density.
         jPARsc_dif_12h = jPARsc_dif !JPAR m-2 s-1. Diffuse component
                               !of light flux density. Same whether the sun
                               !is in or out.
         jPARsc_sunouttot_12h = jPARsc_sunouttot  !which gives total radiation
                               !(direct beam + diffuse) when sun is out.
                               !J par m-2 s-1
         Pmax_12h =   Pmax     !kg CO2 m-2 s-1.
                               !Maximum of the photosynthetic light response.
         PCO2sc_12h = PCO2sc   !kg CO2 m-2 s-1.
         Pcan_12h = Pcan       !kg C m-2 day-1. Canopy photosynthesis.
                               !Instantaneous canopy photosynthetic rate.
         LAI_12h = LAI         !Leaf area index, m2 leaf area per m2 ground
         DLAI_12h = DLAI       !D = d/dt of (Leaf area index), 
                                   !m2 leaf area m-2 ground d-1
         z1CE_12h = z1CE       !Quantities in s_Pcan = 3 procedure
         z2CE_12h = z2CE       ! ditto
         PCO2sc_CE_12h = PCO2sc_CE !ditto
         fsun_12h =   fsun     !If the sun is out, then this gives the
                               !fraction of daylight which is direct solar.
         m_sun_12h =  m_sun    !Multipliers for radiation when sun is out,
                               !to give total radiation (direct + diffuse) 
                               !from mean radiation, jPARsc.
         fT_Pmax_12h =     fT_Pmax !Dimensionless. Effect of temp. on Pmax.
         fT_12h_Pmax =     fT_Pmax_12h        
         fWph_12h =        fWph      !Dimensionless. Effect of water on Pmax.
         fWph_12h_Pmax =   fWph_12h
         Pmax20fCO2_12h =  Pmax20fCO2 !Pmax20 allowing for ambient CO2.
         gstom_12h =       gstom !m s-1. Stomatal conductance to water vapour.
         rstom_12h =       rstom !m-1 s. Stomatal resistance to water vapour.
         rstom_CO2_12h =   rstom_CO2 !m-1 s. Stomatal resistance to CO2.
         rsto_CO2_12h = rstom_CO2_12h  !For output only.
         rchl_12h =        rchl  !m-1 s. Stomatal resistance to CO2.
         rCO2_12h =        rCO2  !m-1 s. Total resistance (stomatal + 
                                       !carboxylation) to CO2.
         rcan_12h =        rcan  !m-1 s. Canopy resistance.
         rboundarylayer_12h = rboundarylayer !m-1 s. Boundary layer
                                             !resistance.
         CO2intvpm_12h = CO2intvpm !vpm. CO2 concn inside the stomate.
         fgstom_Pmax_12h = fgstom_Pmax     !Dimensionless. Effect of stomatal
         fgstom_12h_Pmax = fgstom_Pmax_12h !closure on Pmax.
         fgs_Pmax_12h =    fgstom_Pmax_12h !12 characters, for output only.
         fjPAR_Nph_12h =   fjPAR_Nph       !Effect of PAR on synthetic rate of
                                           !photosynthetic protein, Nph.
      !Water potentials [J (kg water)-1]:
         psile_12h = psile                 !Foliage.
         psifi_12h = psifi                 !Fine roots.
         psisoil_12h = psisoil             !Soil.

         thetale_12h = thetale             !Foliage relative water content.
         thetasoil_12h = thetasoil         !Soil relative water content.
         fthetale_gs_12h = fthetale_gs     !Function of thetale, 0 to 1.
         fTWle_12h = fTWle                 ! = fTsh * fWle
         fGbud_thetale_12h = fGbud_thetale !Effect of thetale on bud growth
                                           !and opening.
         OWle_rad_gnd_12h = OWle_rad_gnd   !Radiation-driven component of
            DroSatWVapDT_12h = DroSatWVapDT !transpiration. Factors of
            jNetRabs_can_12h = jNetRabs_can !equation.
               denPenman_12h = denPenman
         OWle_vdg_gnd_12h = OWle_vdg_gnd   !Vapour-density-gradient-driven
            zOWle_vdg_gnd_num_12h = zOWle_vdg_gnd_num !component of transp.
      ENDIF !of extraction of quantities at 12.00 hours.

!Extract some quantities at 15.00 hours every day:
      LOGICAL t15h; t15h = tdec .GT. t15h1 .AND. tdec .LT. t15h2 
      IF ( t15h ) THEN
         Pmax_15h = Pmax        !Pmax value of photosynthesis:light
                                !response curve (kg CO2 m-2 s-1).
         PCO2sc_15h = PCO2sc    !Instantaneous gross photosynthetic
                                !rate (kg CO2 m-2 s-1).
         PCO2sc5_15h = PCO2sc5  !Instantaneous gross photosynthetic
                                !rate (kg CO2 m-2 s-1).
         PCO2sc_shadeleaves5_15h = PCO2sc_shadeleaves5 !kg CO2 m-2 s-1. 
                                 !Shade leaves.

         PCO2sc_sunleaves5_15h = PCO2sc_sunleaves5 !kg CO2 m-2 s-1. Sun leaves.
         PCO2sc_ss5_15h = PCO2sc_ss5 !kg CO2 m-2 s-1. Sun and shade leaves.
        !PCO2sc_sunout5 = PCO2sc_sunleaves5 + PCO2sc_shadeleaves5
         PCO2sc_sunout5_15h = PCO2sc_sunout5 !When the sun is out, some leaves
            !are in direct sunshine, and others are in the shade.
         PCO2sc_nosun5_15h = PCO2sc_nosun5 !No sun
         alpha_15h = alpha      !Initial slope of alpha [kg CO2 (J PAR)-1].
         Pcan_15h = Pcan        !Gross photosynthetic rate (kg C m-2 day-1).
         Pcan_IP_15h = Pcan_IP  !Gross photosynthetic rate (kg C m-2 day-1),
                                !less isoprene emissions.
         OCle_IP_atm_gnd_15h = OCle_IP_atm_gnd  !kg C m-2 ground day-1.
                                !Isoprene emissions.
         IP_15h = OCle_IP_atm_gnd_15h !For a simpler notation.
         gstom_15h = gstom      !stomatal conductance, gstom, to water vapour.
                                !m s-1.
            gstome3_15h = c1000 * gstom_15h !mm s-1.
         gstom_thetale_15h = gstom_thetale !stomatal conductance, gstom, 
                                !calculated from foliage water content.
         gstom_vpd_15h = gstom_vpd !ditto calcuated from vapour pressure
             !difference. 
         rstom_15h = rstom      !m-1 s. Stomatal resistance, to water vapour.
         rstom_CO2_15h = rstom_CO2 !m-1 s. Stomatal resistance to CO2.
         rchl_15h =  rchl       !m-1 s. Stomatal resistance to CO2
         rCO2_15h =  rCO2       !m-1 s. Total resistance to CO2 (rstom + rchl).
         fgstom_Pmax_15h = fgstom_Pmax  !Dimensionless. Effect of stomatal
                                        !closure on Pmax.
              !fgstom_Pmax = rchl / rCO2
         Pmax_chl_15h = Pmax_chl !Effect of chlorophyll on Pmax.
         gcan_15h = gcan         !Canopy conductance (m s-1).
         gBoundaryLayer_15h = gBoundaryLayer 
                              !Boundary layer conductance (m s-1).
         gNamm_le_15h = gNamm_le !Total Namm conductance, foliage to
                                 !atmosphere (m s-1).
         ONSle_atm_gnd_15h = ONSle_atm_gnd
                                 !Foliage ammonia emission (can be + or -).
                                 !(kg NH3 N m-2 day-1).
         fWle_15h = fWle         !Water function, foliage.
         thetale_15h = thetale   !foliage relative water content, thetale.
         fthetale_gs_15h = fthetale_gs    !Function of thetale, 0 to 1.
         fTWle_15h = fTWle       ! = fTsh * fWle
         fGbud_thetale_15h = fGbud_thetale !Effect of thetale on bud growth
                                           !and opening.
         VPD_15h = VPD           !Pa. Vapour pressure deficit.

         psiPle_15h = psiPle     !foliage pressure potential, psiPle.
         OWle_atm_15h = OWle_atm !Evapotranspiration (kg water stem-1 day-1).
         OWle_atm_gnd_15h = OWle_atm_gnd  !Evapotranspiration 
                                          !(kg water m-2 day-1).
         OWle_atm_gnd_pot_15h = OWle_atm_gnd_pot 
                                 !Potential evapotranspiration if stomates   
                                 !open.
         fWph_15h = fWph         !Effect of water on photosynthesis, fWph.
         Wle_15h = Wle           !Foliage water. kg water stem-1.
         DWle_15h = DWle         !d/dt of foliage water. kg water stem-1 d-1.
         IWle_15h = IWle         !Input to foliage water. kg water stem-1 d-1.
         OWle_15h = OWle   !Output from foliage water. kg water stem-1 d-1.
         Wle_psi0_15h = Wle      !Foliage water at zero water potential.
         DWleda_15h = DWleda  !Daily average 
         Wfi_15h = Wfi           !Fine roots water. kg water stem-1.

      !Water potentials [J (kg water)-1]:
         psile_15h = psile       !Foliage.
         psifi_15h = psifi       !Fine roots.
         psisoil_15h = psisoil   !Soil.

         thetasoil_15h = thetasoil  !Soil relative water content.

      !Aphid fluxes and variables
         Oalaa_ala1_15h = Oalaa_ala1
         Oalaa_apt1_15h = Oalaa_apt1
         Oalaa_axx1_15h = Oalaa_axx1
         Oalaa_emi_15h = Oalaa_emi
         Oalaa_mort_15h = Oalaa_mort
         Oalaa_mortemi_15h = Oalaa_mortemi

         Oaph_fec_15h = Oaph_fec
         Oaph_mort_15h = Oaph_mort
         Oaph_mortemi_15h = Oaph_mortemi

         Oapta_ala1_15h = Oapta_ala1
         Oapta_apt1_15h = Oapta_apt1
         Oapta_axx1_15h = Oapta_axx1

         Oaxxa_axx1_15h = Oaxxa_axx1

         aph_15h = aph; alaa_15h = alaa; apta_15h = apta
         roaph_15h = roaph
         ffecalaa_15h = ffecalaa;   ffecapta_15h = ffecapta;  
         falaa_ala1_15h = falaa_ala1;   falaa_apt1_15h = falaa_apt1
         fapta_ala1_15h = fapta_ala1;   fapta_apt1_15h = fapta_apt1
         fTalaa_ala1_15h = fTalaa_ala1;   
         fTapta_ala1_15h = fTapta_ala1;   
         froalaa_ala1_15h = froalaa_ala1;   
         froapta_ala1_15h = froapta_ala1;   
         fNalaa_ala1_15h = fNalaa_ala1;   
         fNapta_ala1_15h = fNapta_ala1;   
         fOalaa_emi_15h = fOalaa_emi; fOalaa_mort_15h = fOalaa_mort; 
         fOalaa_mortemi_15h = fOalaa_mortemi
    ENDIF  !Calculation of daily 15.00 hour quantities.


!Extract some 1 July 15.00 hour quantities (1Jul15h):
   IF ( ( iJulian .EQ. j1Jul ) .AND. t15h ) THEN  !It is 1 July and 15 h.
      jPARsc_sun_1Jul15h = jPARsc_sun !Direct-beam radiation when sun is out.
      jPARsc_dif_1Jul15h = jPARsc_dif !Diffuse radiation when sun is in or out.
      s_leaf_1Jul15h = s_leaf       !Are leaves present?
      Pmax20_1Jul15h = Pmax20       !Light-, CO2-saturated photosynthetic
                                    !at 20 C. kg CO2 m-2 s-1.
      Pcan_1Jul15h = Pcan           !kg C m-2 ground day-1. Canopy
      Pcan_IP_1Jul15h = Pcan_IP     !photosynthesis (less isoprene emission).
      Pmax_1Jul15h = Pmax           !kg CO2 m-2 s-1. Asymptote of
                                    !leaf light response curve.
                !Pmax = Pmax_chl * fgstom_Pmax 
      Pmax_chl_1Jul15h = Pmax_chl   !kg CO2 m-2 s-1. This is the chloroplast
         !Pmax for saturating light and zero stomatal resistance. 
      fgstom_Pmax_1Jul15h = fgstom_Pmax !Fractional effect of stomatal
                                    !closure on Pmax.
               rCO2 = rstom_CO2 + rchl  !m-1 s. 
      Pcanda_1Jul15h = Pcanda       !kg C m-2 ground day-1. 
         !Daily average saved, presumably for the previous day (30Jun30).
      wind_1Jul15h = wind    !Wind speed, m s-1 at 50 m height.
      DMXle1da_1Jul15h = DMXle1da !Rate of change of XDM in first 
                         !foliage compartment.
      IXle1da_1Jul15h = IXle1da !Input of XDM to first foliage compartment.
      OXle1da_1Jul15h = OXle1da !Output of XDM from first foliage compartment.
                                !kg XDM d-1.           
      PCO2sc_ss5_1Jul15h = PCO2sc_ss5 !kg CO2 m-2 s-1. Sun and shade leaves.
        ! PCO2sc_ss5 = fbshrs * PCO2sc_sunout5 &
        !                  + ( one - fbshrs ) * PCO2sc_nosun5
      PCO2sc_sunout5_1Jul15h = PCO2sc_sunout5 !The sun is out. These leaves
           !receive direct sunshine and diffuse radiation.
      PCO2sc_nosun5_1Jul15h = PCO2sc_nosun5 !The sun in not out.
      PCO2sc_shadeleaves5_1Jul15h = PCO2sc_shadeleaves5
      PCO2sc_sunleaves5_1Jul15h = PCO2sc_sunleaves5

      gstom_1Jul15h = gstom         !m s-1. Leaf stomatal conductance.
      gstome3_1Jul15h = c1000 * gstom_1Jul15h !mm s-1.
      gs_1Jul15h = gstom_1Jul15h    !10 characters. Output only.
      gse3_1Jul15h = gs_1Jul15h * c1000 !mm s-1. Output only.
      ge3_1Jul15h = gse3_1Jul15h    !Output only - print statements.
      rchl_1Jul15h = rchl           !m-1 s. Carboxylation resistance
                                            !for CO2.  Flux = [CO2]/rchl.
                                            ![CO2] = kg CO2 m-3.
      rsCO_1Jul15h = rstom_CO2      !m-1 s. Stomatal resistance to CO2.
      rCO2_1Jul15h = rCO2           !m-1 s. !Total resistance to CO2 uptake,
                                    !diffusion + carboxylation.
                      !rCO2 = rstom_CO2 + rchl  !m-1 s. 

      rstom_CO2_1Jul15h = rstom_CO2 !m-1 s. !Total resistance to CO2 uptake,
      gstom_1Jul15h = gstom !m-1 s. !Total conductance to water uptake,
      gstom_thetale_1Jul15h = gstom_thetale !gstom = gstom_thetale 
      rstom_1Jul15h = rstom !m-1 s. !Total resistance to water uptake,
            !rstom = one / gstom !m-1 s. Stomatal resistance.
      fg_P_1Jul15h = fgstom_Pmax_1Jul15h !Output only.
      alpha_1Jul15h = alpha         !kg CO2 (J PAR)-1.  Initial slope
                                    !of leaf light response curve.
      LAI_1Jul15h = LAI
      hstem_1Jul15h = hstem
      Aleaf_1Jul15h = Aleaf
         Alf_1Jul15h = Aleaf_1Jul15h    !11 characters for Axum print/file.
      MXfi_gnd_1jul15h = MXfi_gnd
         MXfg1jul15h = MXfi_gnd_1jul15h 

      !C * N substrate products.
      CNle_1Jul15h = CNle           !foliage
      CNbr_1Jul15h = CNbr           !branches
      CNst_1Jul15h = CNst           !stem
      CNco_1Jul15h = CNco           !coarse roots
      CNfi_1Jul15h = CNfi           !fine roots.

      !Ratio of potential meristem size to actual meristem size:
      rbrmpot_brm_1Jul15h = rbrmpot_brm      !branches
      rstmpot_stm_1Jul15h = rstmpot_stm      !stem
      rcompot_com_1Jul15h = rcompot_com      !coarse roots
      rfimpot_fim_1Jul15h = rfimpot_fim      !fine roots.

      Cle_1Jul15h = Cle             !kg CS (kg XDM)-1. Foliage C substrate
                                    !concn.
      !Water vapour pressure deficit (VPD):
         VPD_1Jul15h = VPD          !Pa.

!   PROCEDURAL
!    ilogd = i10
!     IF ( calllogd ) CALL LOGD( .true. ) 
!   END

      !Water potential and components [J (kg water)-1]:
      !Foliage (le)
      psile_1Jul15h =   psile        !Total foliage water potential.
      psle_1Jul15h = psile_1Jul15h   !Output only.
      psiOle_1Jul15h =  psiOle       !osmotic
      psiPle_1Jul15h =  psiPle       !pressure
      psiGle_1Jul15h =  psiGle       !gravitational
      MXle_1Jul15h = MXle            !Above and 3 below involved in the 
      hcan_1Jul15h = hcan            !calulation of Wle_psi0.
      MSle_1Jul15h = MSle
      fWle_1Jul15h =    fWle         !Water function, foliage.
      thetale_1Jul15h = thetale      !Dimensionless. Foliage relative water
                                        !content.
      Wle_1Jul15h = Wle              !Foliage water content. kg water stem-1..
      Wle_psi0_1Jul15h = Wle_psi0    !Foliage water content at zero water
                                     !potential. This inexplicably --> Wle.
      !To debug Wle_psi0 do the next 3 statements:
      z2leW_1Jul15h = z2leW 
      sqrtb24acl_1Jul15h = sqrtb24acl 
      z1leW_1Jul15h = z1leW
      DWle_1Jul15h = DWle   
         !kg water stem-1 d-1. Rate of change of foliage water pool.
      DWleda_1Jul15h = DWleda 
         !Rate of change of foliage water pool, daily average.
      IWle_1Jul15h = IWle   !kg water stem-1 d-1. Input to foliage water pool.
      OWle_1Jul15h = OWle   !kg water stem-1 d-1. 
                            !Output from foliage water pool.
      fthetale_gs_1Jul15h = fthetale_gs    !Function of thetale, 0 to 1.
      fGbud_thetale_1Jul15h = fGbud_thetale !Effect of thetale on bud growth
                                            !and opening.
      OWle_rad_gnd_1Jul15h = OWle_rad_gnd
      OWle_vdg_gnd_1Jul15h = OWle_vdg_gnd
      jNetRabs_can_1Jul15h = jNetRabs_can 
      denPenman_1Jul15h = denPenman
      gBoundaryLayer_1Jul15h = gBoundaryLayer 
      rcan_1Jul15h = rcan 
      delWVap_1Jul15h = delWVap 

      !Fine roots (fi)
      psifi_1Jul15h =  psifi         !Total fine roots water potential.
      psfi_1Jul15h = psifi_1Jul15h   !Output only.
      psiOfi_1Jul15h = psiOfi        !osmotic
      psiPfi_1Jul15h = psiPfi        !pressure
      psiGfi_1Jul15h = psiGfi        !gravitational.

      !Within-plant resistances to water transport:
         rWle_1Jul15h = rWle
         rWst_1Jul15h = rWst
         rWfi_1Jul15h = rWfi

      !Soil
      psisoil_1Jul15h = psisoil      !Soil water potential.
      psso_1Jul15h = psisoil_1Jul15h !Output only.
      thetasoil_1Jul15h = thetasoil  !Dimensionless. Soil relative water
                                     !content.
         tso_1Jul15h = thetasoil_1Jul15h 
      !Soil-plant resistances (m4 kg-1 d/s s-1):
         gsoilW_1Jul15h =      gsoilW        !Soil hydraulic conductivity.
         rWso_fisurf_1Jul15h = rWso_fisurf   !Soil to fine root surface.
         rWfisurf_fi_1Jul15h = rWfisurf_fi   !Fine root surface to fine root.
         rWso_fi_1Jul15h =     rWso_fi       !Soil to fine root.
         rWfi_st_le_gnd_1Jul15h = rWfi_st_le_gnd !Fine root to foliage.
      !Water fluxes (kg water m-2 day-1):
         OWso_fi_1Jul15h =     OWso_fi       !Flux, soil to fine roots.
         OWfi_Wle_gnd_1Jul15h = OWfi_Wle_gnd   !Flux, fine roots to foliage.
         OWle_atm_gnd_1Jul15h = OWle_atm_gnd  !Evapotranspiration.
         OWle_atm_gnd_pot_1Jul15h = OWle_atm_gnd_pot 
                                    !Potential evapotranspiration if 
                                    !stomates open.
   ENDIF !1Jul15h block.

!Extract some 1 August 15.00 hour quantities (1Aug15h):
   IF ( ( iJulian .EQ. j1Aug ) .AND. t15h ) THEN   !It is 1 August and 15h.
      s_leaf_1Aug15h = s_leaf
      LAI_1Aug15h = LAI
      Nph_A_1Aug15h = Nph_A
      Pmax20fCO2_1Aug15h = Pmax20fCO2
      Pmax20_1Aug15h = Pmax20
         Pm20_1Aug15h = Pmax20_1Aug15h !12 characters. For output only.
      gstom_1Aug15h = gstom         !m s-1. Leaf stomatal conductance.
         gs_1Aug15h = gstom_1Aug15h        !10 characters. Output only.
         gse3_1Aug15h = gs_1Aug15h * c1000 !mm s-1. Output only.
      fgstom_Pmax_1Aug15h = fgstom_Pmax !Fractional effect of stomatal
                                        !closure on Pmax.
      alpha_1Aug15h = alpha         !kg CO2 (J PAR)-1.  Initial slope
                                    !of leaf light response curve.

      MXle_1Aug15h = MXle
      Mle_1Aug15h = Mle
      SLA_1Aug15h = SLA;                 Nletot_A_1Aug15h = Nletot_A
            NltA_1Aug15h = Nletot_A_1Aug15h 
      Cle_1Aug15h = Cle;                 Cfi_1Aug15h = Cfi
      Nle_1Aug15h = Nle;                 Nfi_1Aug15h = Nfi
      Nph_1Aug15h = Nph;
      Nmin_1Aug15h = Nmin

      !Water variables:
      Wle_1Aug15h = Wle              !kg water stem-1. Foliage water.    
      VPD_1Aug15h = VPD              !Pa. Water vapour pressure deficit (VPD).
      psile_1Aug15h =   psile        !Total foliage water potential.
      psiOle_1Aug15h =  psiOle       !osmotic
      psiPle_1Aug15h =  psiPle       !pressure
      psiGle_1Aug15h =  psiGle       !gravitational.
      fWle_1Aug15h =    fWle         !Water function, foliage.
      thetale_1Aug15h = thetale      !Dimensionless. Foliage relative water
                                        !content.
      !Fine roots (fi)
      psifi_1Aug15h =  psifi         !Total fine roots water potential.
      psiOfi_1Aug15h = psiOfi        !osmotic
      psiPfi_1Aug15h = psiPfi        !pressure
      psiGfi_1Aug15h = psiGfi        !gravitational.

      !Within-plant resistances to water transport:
         rWle_1Aug15h = rWle
         rWst_1Aug15h = rWst
         rWfi_1Aug15h = rWfi

      !Soil
      psisoil_1Aug15h = psisoil     !Soil water potential.
      thetasoil_1Aug15h = thetasoil !Dimensionless. Soil relative water
                                       !content.
      !Soil-plant resistances (m4 kg-1 d/s s-1):
         gsoilW_1Aug15h =      gsoilW        !Soil hydraulic conductivity.
         rWso_fisurf_1Aug15h = rWso_fisurf   !Soil to fine root surface.
         rWfisurf_fi_1Aug15h = rWfisurf_fi   !Fine root surface to fine root.
         rWso_fi_1Aug15h =     rWso_fi       !Soil to fine root.
         rWfi_st_le_gnd_1Aug15h = rWfi_st_le_gnd !Fine root to foliage.
      !Water fluxes (kg water m-2 day-1):
         OWso_fi_1Aug15h =     OWso_fi       !Flux, soil to fine roots.
         OWfi_Wle_gnd_1Aug15h = OWfi_Wle_gnd   !Flux, fine roots to foliage.
         OWle_atm_gnd_1Aug15h = OWle_atm_gnd  !Evapotranspiration.
         OWle_atm_gnd_pot_1Aug15h = OWle_atm_gnd_pot 
                                    !Potential evapotranspiration if 
                                    !stomates open.
   ENDIF !1Aug15h block.


!Extract some quantities at 12.00 hours on 21 June.
      IF ( iJulian .EQ. j21Jun .AND. noon ) THEN
           fsun_21Jun12h = fsun 
           solar_elevation_noon_deg_21Jun12h = solar_elevation_noon_deg 
      ENDIF

!Extract some quantities at 12.00 hours on 21 December.
      IF ( iJulian .EQ. j21Dec .AND. noon ) THEN
           fsun_21Dec12h = fsun 
           solar_elevation_noon_deg_21Dec12h = solar_elevation_noon_deg 
      ENDIF

!SUM SOME ONCE-PER-YEAR QUANTITIES OVER THE RUN
   IF ( yearbeg .AND. daybeg ) THEN
       chk_yr_sum = chk_yr_sum + one   !This should be year + 1
       Pcan_1Jul15h_yr_sum = &
                   Pcan_1Jul15h_yr_sum + Pcan_1Jul15h
       Pcan_IP_1Jul15h_yr_sum = &
                   Pcan_IP_1Jul15h_yr_sum + Pcan_IP_1Jul15h
       Pmax_1Jul15h_yr_sum = &
                   Pmax_1Jul15h_yr_sum + Pmax_1Jul15h
       alpha_1Jul15h_yr_sum = &
                   alpha_1Jul15h_yr_sum + alpha_1Jul15h
       thetale_1Jul15h_yr_sum = &
                   thetale_1Jul15h_yr_sum + thetale_1Jul15h
       gstom_1Jul15h_yr_sum = &
                   gstom_1Jul15h_yr_sum + gstom_1Jul15h
       fgstom_Pmax_1Jul15h_yr_sum = &
                   fgstom_Pmax_1Jul15h_yr_sum + fgstom_Pmax_1Jul15h
       gstom_1Aug15h_yr_sum = &
                   gstom_1Aug15h_yr_sum + gstom_1Aug15h
       fgstom_Pmax_1Aug15h_yr_sum = &
                   fgstom_Pmax_1Aug15h_yr_sum + fgstom_Pmax_1Aug15h
       psiPle_1Jul15h_yr_sum = &
                   psiPle_1Jul15h_yr_sum + psiPle_1Jul15h
       thetasoil_1Jul15h_yr_sum = &
                   thetasoil_1Jul15h_yr_sum + thetasoil_1Jul15h
    ENDIF


!DAILY AVERAGES.
   !This block accumulates quantities over the last complete day, i.e. 
      !from 0 h to 24 h.  This gives either a flux accumulated over the day,
      !or because the time unit of the model is 1 day, for a quantity like
      !LAI, the daily average.
      !Fda (F daily average) is the sum of F*dt for the day just finished. 
      !Fdb is the sum of F*dt from the beginning of the
         !present day up to the current time + maxt.
   !Also, yearly sums are accumulated in Fya.
   !This block is carried out if
      Constant s_dyav = 1  !Default value. Calculate daily averages.
           !If s_dyav = 0,  then daily averages and sums are not calculated. 
                           !This speeds up execution time. 

   IF ( s_dyav .EQ. one .AND. t .NE. tdumpda ) THEN
      !Skip calculation of daily averages if:
         !procedure is switched off with s_dyav = 0;
         !procedure is switched on but has already been executed at the
         !current time, in which case t = tdumpda.
            tdumpda = t  !Store the present time.

      IF ( daybeg ) THEN
         !A new day is beginning. Therefore:
         !1. Move contents of daily accumulator Fdb to Fda,
         !2. and reset daily accumulator Fdb to 0.0.
            dychda = dychdb; dychchkdb = dychdb; dychdb = zero
                         !Checks on method. dychda should = 1.

            kpulse_thinda = kpulse_thindb;   kpulse_thindb = zero
               !kpulse_thinda will be equal to the relevant kthin operating
               !on the day of thinning.

            Onstems_thda = Onstems_thdb;   Onstems_thdb = zero

            kpruneda = kprunedb;   kprunedb = zero

            pulse_fireda = pulse_firedb;   pulse_firedb = zero
            kst_firezda = kst_firezdb;     kst_firezdb = zero    !day-1.
            INtree_fire_Nammda = INtree_fire_Nammdb; INtree_fire_Nammdb = zero
            INsurf_li_fire_Nammda = INsurf_li_fire_Nammdb; 
                                    INsurf_li_fire_Nammdb = zero

         !Environment.
            Tairda = Tairdb;             Tairdb = zero
            Tsoilda = Tsoildb;           Tsoildb = zero
            fTshda = fTshdb;             fTshdb = zero
            fTsoilda = fTsoildb;         fTsoildb = zero

          !Soil water.
            Wsoilda = Wsoildb;         Wsoildb = zero
          !Soil water fluxes: (kg water m-2 d-1) input and output
            IWsoilda = IWsoildb;       IWsoildb = zero
            OWsoilda = OWsoildb;       OWsoildb = zero


          !Soil water function.
            fWsoilda = fWsoildb;         fWsoildb = zero

            jPARscda = s_diurnal * jPARscdb &
                     + one_s_diurnal * daylength_yday * jPARscdb;         
                                         jPARscdb = zero
                    !This is necessary because with s_diurnal = 0, jPARsc
                    !is the mean light as if all the light for the 
                    !day (jPARdy) falls during the light period.
                    !This is done because of the non-linear photosynthetic
                    !response.
               jPARscem6da = 1.0e-6 * jPARscda            !MJ PAR m-2 day-1.
            jPARscabsda =    jPARscabsdb;     jPARscabsdb =    zero
            jNetRscda =      jNetRscdb;       jNetRscdb =      zero
            jNetRabs_canda = jNetRabs_candb;  jNetRabs_candb = zero

         !N fluxes. kg N m-2 day-1.
            !Environmental inputs: 
            INenv_Nammda = INenv_Nammdb; INenv_Nadb = INenv_Nammdb;
               !INenv_Nadb is not used xcept for output and maybe in ...tl
                            INenv_Nammdb = zero  
               INenv_Nada = INenv_Nammda   !Not used xcept for output
            INenv_Nnitda = INenv_Nnitdb; INenv_Nndb = INenv_Nnitdb; 
                   !Not used xcept for output (? in ...tl)
                           INenv_Nnitdb = zero
               INenv_Nnda = INenv_Nnitda   !Not used xcept for output

               INenv_Nminda = INenv_Nammda + INenv_Nnitda

            !Fertilizer inputs are usually zero. "d INfert_N*d?"
            INfert_Nammda = INfert_Nammdb;   INfert_Nammdb = zero
               INfert_Nada = INfert_Nammda   !For output.
            INfert_Nnitda = INfert_Nnitdb;   INfert_Nnitdb = zero
               INfert_Nnda = INfert_Nnitda   !For output.
               INfert_Nminda = INfert_Nammda + INfert_Nnitda
            zNfert1_Nminda = zNfert1_Nmindb;  zNfert1_Nmindb = zero

            RHda = RHdb;       RHdb = zero
            windda = winddb;             winddb = zero

         !Plant.
            !Structural dry mass of tree, MXtree (kg XDM stem-1)
               MXtreeda = MXtreedb;          MXtreedb = zero

            !Phenology
            kchillda = kchilldb;             kchilldb = zero
            kforceda = kforcedb;             kforcedb = zero
            kbudb_dorm1da = kbudb_dorm1db;   kbudb_dorm1db = zero 
            kdorm1_2da = kdorm1_2db;         kdorm1_2db = zero
            budsopeningda = budsopeningdb;   budsopeningdb = zero
            !Budsopening rate
            kObudda = kObuddb;               kObuddb = zero
            OMbud_leaf1da = OMbud_leaf1db;   OMbud_leaf1db = zero
            leaf_fallda = leaf_falldb;       leaf_falldb = zero
            OWle_lfda = OWle_lfdb;           OWle_lfdb = zero

            LAIda = LAIdb;                   LAIdb = zero  
               DLAIda = LAI - LAId1                            !m2 m-2 day-1.
                              LAId1 = LAI               !Update stored value.
            DMXle1da = DMXle1db;     DMXle1db = zero !Rate of change of
                        !1st foliage compartment.  XDM stem-1 d-1.
            IXle1da = IXle1db;     IXle1db = zero !Input to 1st foliage
                                              !compartment.  XDM stem-1 d-1.
            OXle1da = OXle1db;     OXle1db = zero !Output from 1st foliage
                                              !compartment.  XDM stem-1 d-1.
!       PROCEDURAL
!         ilogd = i11
!         IF ( calllogd ) CALL LOGD( .true. ) 
!       END

            Pcanda = Pcandb;                 Pcandb = zero    !kg C m-2 day-1.
              !Pcan includes isoprene emissions.
            OCle_IP_atm_gndda = OCle_IP_atm_gnddb;  OCle_IP_atm_gnddb = zero
                  !OCle_IP_atm_gnd is kg C in isoprene emissions m-2 day-1.
               IPda = OCle_IP_atm_gndda !for a simpler output function.
               Pcane3da = Pcanda * c1000    !g C m-2 d-1.
            Pcan_IPda = Pcan_IPdb;           Pcan_IPdb = zero !kg C m-2 day-1.
                            !Pcan_IP = Pcan after removing loss of Pcan to
                            !isoprene emission.
               IF ( nstems .GT. zero ) ICph_CSleda = Pcan_IPda / nstems      
                                                      !kg C stem-1 day-1.
               IF ( s_leaf .EQ. one .AND. LAIda .GT. c1E_14 ) THEN
                  rPcanLAIda = Pcanda / LAIda  !kg C (m2 leaf)-1 day-1.
               ELSE
                  rPcanLAIda = zero
               ENDIF
!       PROCEDURAL
!         ilogd = i12
!         IF ( calllogd ) CALL LOGD( .true. ) 
!       END

            Pnetda = Pnetdb;                 Pnetdb = zero  !kg C m-2 day-1.
               IF ( Pcanda .NE. zero ) THEN 
                    rPnet_Pcanda = Pnetda / Pcanda
               ELSE 
                    rPnet_Pcanda = csmall
               ENDIF
                                                       !dimensionless ratio.
               Pnete3da = Pnetda * c1000    !g C m-2 d-1.

!       PROCEDURAL
!         ilogd = i13 
!         IF ( calllogd ) CALL LOGD( .true. ) 
!       END
               IF ( t .GT. zero .AND. Pcanda .NE. zero ) THEN
                  fIP_Pcanda = OCle_IP_atm_gndda / Pcanda !The fraction of
               ELSE  !gross daily photosynthesis Pcanda emitted as isoprene.
                  fIP_Pcanda = csmall
               ENDIF

!       PROCEDURAL
!         ilogd = i14
!         IF ( calllogd ) CALL LOGD( .true. ) 
!       END

            Pmax20da = Pmax20db;             Pmax20db = zero!kg CO2 m-2 day-1.
            Pmaxda = Pmaxdb;                 Pmaxdb = zero  !kg CO2 m-2 day-1.
               Pmax20_qe6da = r_MCO2_qCO2 * c1E6 * Pmax20da
               Pmax_qe6da = r_MCO2_qCO2 * c1E6 * Pmaxda
                                                       !micromols CO2 m-2 s-1.
               !Constant r_MCO2_qCO2 = 22.72 = 1000 g / 44.01 g mol-1.
            Nph_Ada = Nph_Adb;               Nph_Adb = zero  
                                                     !kg photosynthetic N m-2.
            fWphda = fWphdb;                 fWphdb = zero
            fgstom_Pmaxda = fgstom_Pmaxdb;   fgstom_Pmaxdb = zero

!   PROCEDURAL
!     ilogd = i15
!     IF ( calllogd ) CALL LOGD( .true. ) 
!   END

            !Nph pool:
            INphda = INphdb;                 INphdb = zero
            ONphda = ONphdb;                 ONphdb = zero
            INSle_Nphda = INSle_Nphdb;       INSle_Nphdb = zero
            INbud_Nphda = INbud_Nphdb;       INbud_Nphdb = zero
            ONph_NSleda = ONph_NSledb;       ONph_NSledb = zero
            ONph_li0da = ONph_li0db;         ONph_li0db = zero
            ONph_snda = ONph_sndb;           ONph_sndb = zero
            ONph_pruneda = ONph_prunedb;     ONph_prunedb = zero
            ONph_lfda = ONph_lfdb;           ONph_lfdb = zero
            ONph_fireda = ONph_firedb;       ONph_firedb = zero
            fNSle_Nphda = fNSle_Nphdb;       fNSle_Nphdb = zero
            fjPAR_Nphda = fjPAR_Nphdb;       fjPAR_Nphdb = zero

            !Foliage substrate C and N pools, MCSle, MNSle
            DMCSleda = DMCSledb;             DMCSledb = zero !d/dt of MCSle. 
            DMNSleda = DMNSledb;             DMNSledb = zero !d/dt of MNSle. 
            ICSleda = ICSledb;               ICSledb = zero !Input to MCSle. 
            OCSleda = OCSledb;               OCSledb = zero !Output from MCSle.
            INSleda = INSledb;               INSledb = zero !Input to MNSle. 
            ONSleda = ONSledb;               ONSledb = zero !Output from MNSle.

            Rtree_stemda =  Rtree_stemdb;  Rtree_stemdb = zero
                                                          !kg C stem-1 day-1.
            Rtreem_stemda = Rtreem_stemdb; Rtreem_stemdb = zero ! -.
            RtreeG_stemda = RtreeG_stemdb; RtreeG_stemdb = zero ! -.
               Rtree_gndda = nstems * Rtree_stemda           !kg C m-2 day-1.
               Rtreem_gndda = nstems * Rtreem_stemda         !kg C m-2 day-1.
               RtreeG_gndda = nstems * RtreeG_stemda         !kg C m-2 day-1.
                  IF ( Pcanda .GT. zero ) &
                     rRtreePcanda = Rtree_gndda / Pcanda  !Dimensionless.
                  IF ( RtreeG_gndda .GT. zero ) &
                     rRmRGtreeda = Rtreem_stemda / RtreeG_stemda

            Dnstemsda = nstems - nstemsd1                  !stem m-2 day-1.
                                 nstemsd1 = nstems !Update stored values.
            FBRnstemsda = FBRnstemsdb;        FBRnstemsdb = zero
               FBRnst_snda = FBRnstemsda !For output.
            FBRnstemstrzda = FBRnstemstrzdb;  FBRnstemstrzdb = zero
            FBRnstemstrda = FBRnstemstrdb;    FBRnstemstrdb = zero
            FBRnstemssdda = FBRnstemssddb;    FBRnstemssddb = zero
            FDRnstemsda = FDRnstemsdb;        FDRnstemsdb = zero
               FDRnst_snda = FDRnstemsda !For output.
            FGRnstemsda = FGRnstemsdb;              FGRnstemsdb = zero
            sgrMtreeda = sgrMtreedb;                sgrMtreedb = zero
            sgrMXstda = sgrMXstdb;                  sgrMXstdb = zero
            sn_expda = sn_expdb;     sn_expdb = zero
            sn_expMXstda = sn_expMXstdb;     sn_expMXstdb = zero
            sn_expMXtreeda = sn_expMXtreedb; sn_expMXtreedb = zero
            Instems_snda = Instems_sndb;     Instems_sndb = zero !# m-2 d-1.
            Onstems_snda = Onstems_sndb;     Onstems_sndb = zero ! ditto
            Dnstems_snda = Dnstems_sndb;     Dnstems_sndb = zero ! ditto
            
            Dhstemda = Dhstemdb;             Dhstemdb = zero
               Dhsteme3da = c1000 * Dhstemda  !Multiply by 1000 for output.
            Ddstemda = Ddstemdb;             Ddstemdb = zero
               Ddsteme3da = c1000 * Ddstemda  !Multiply by 1000 for output.

                  IF ( Ddstemda .NE. zero ) THEN         !Ratio of stem height 
                       RDhDdstemda = Dhstemda / Ddstemda 
                  ELSE                                  !growth to stem
                       RDhDdstemda = 9.999e10            !diameter   
                  ENDIF                                 !growth over last day. 

            Cleda = Cledb;               Cledb = zero    
            Nleda = Nledb;               Nledb = zero    
            Cfida = Cfidb;               Cfidb = zero    
            Nfida = Nfidb;               Nfidb = zero    
            CStreeda = CStreedb;         CStreedb = zero    
            NStreeda = NStreedb;         NStreedb = zero    
            CNtreeda = CNtreedb;         CNtreedb = zero
            Cphloemda = Cphloemdb;       Cphloemdb = zero    
            Nphloemda = Nphloemdb;       Nphloemdb = zero    
            rCNphloemda = rCNphloemdb;   rCNphloemdb = zero    

         !Ammonia emission from foliage:
            ONSle_atm_stemda = ONSle_atm_stemdb; ONSle_atm_stemdb = zero
               INatm_NSle_stemda = - ONSle_atm_stemda       !kg N stem-1 day.
               ONSle_atm_gndda = nstems * ONSle_atm_stemda   !kg N m-2 day-1.
               INatm_NSle_gndda = nstems * INatm_NSle_stemda !kg N m-2 day-1.
         !N uptake by tree from soil mineral N pools:
            uN_stemda = uN_stemdb;         uN_stemdb = zero !kg N stem-1 day-1.
            uN_gndda = uN_gnddb;           uN_gnddb = zero  !kg N m-2 day-1.
               uN_gnde4da = uN_gndda * c10000               !kg N ha-1 d-1.

         !Soil:
            Nminda = Nmindb;               Nmindb = zero  !kg N m-2.
               Nmine3da = Nminda * c1000                  !g N m-2.

         !N fluxes (kg N m-2 day-1):
            INfix_Nammda = INfix_Nammdb;       INfix_Nammdb = zero
               INfx_Nae7da = c1e7 * INfix_Nammda !g N ha-1 day-1.
            INfi_Nammda = INfi_Nammdb;         INfi_Nammdb = zero
            INlitter_Nammda = INlitter_Nammdb; INlitter_Nammdb = zero 
            INbio_Nammda = INbio_Nammdb;       INbio_Nammdb = zero
            INSOM_Nammda = INSOM_Nammdb;       INSOM_Nammdb = zero

            ONsoil_fida = ONsoil_fidb;     ONsoil_fidb = zero

            DNnitda = DNnitdb;             DNnitdb = zero
            INnitda = INnitdb;             INnitdb = zero
            INamm_Nnitda = INamm_Nnitdb;   INamm_Nnitdb = zero

            ONnitda = ONnitdb;             ONnitdb = zero
            ONnit_immda = ONnit_immdb;     ONnit_immdb = zero
            ONnit_bioGda = ONnit_bioGdb;   ONnit_bioGdb = zero
            ONnit_rtda = ONnit_rtdb;       ONnit_rtdb = zero
            ONnit_lchda = ONnit_lchdb;     ONnit_lchdb = zero
            ONnit_denitda = ONnit_denitdb; ONnit_denitdb = zero

            ONamm_volda = ONamm_voldb;     ONamm_voldb = zero
            ONamm_nitrif_envda = ONamm_nitrif_envdb; 
                                           ONamm_nitrif_envdb = zero
               ONsoil_gasda = ONamm_volda + ONamm_nitrif_envda &
                                          + ONnit_denitda
                  !Gaseous N outputs from soil (kg N m-2 year-1).
               ONsys_gasda = ONsoil_gasda + ONSle_atm_gndda
                  !Gaseous N outputs from system (kg N m-2 year-1).
               ONsys_envda = ONsys_gasda + ONnit_lchda

         !Water fluxes and variables:
            DWleda = DWledb;  DWledb = zero  !kg water stem day-1.

            psiPleda = psiPledb;           psiPledb = zero
            psiPfida = psiPfidb;           psiPfidb = zero
            rpsiPle_fida = rpsiPle_fidb;   rpsiPle_fidb = zero
            thetaleda = thetaledb;         thetaledb = zero

            rainda = raindb;                 raindb = zero
            OWso_fida = OWso_fidb;           OWso_fidb = zero
            OWle_atm_gndda = OWle_atm_gnddb; OWle_atm_gnddb = zero
            OWle_rad_gndda = OWle_rad_gnddb; OWle_rad_gnddb = zero
            OWle_vdg_gndda = OWle_vdg_gnddb; OWle_vdg_gnddb = zero
            IF ( nstems .GT. zero ) OWle_atmda = OWle_atm_gndda / nstems
               !per tree basis.
            drainda = draindb;               draindb = zero

         !Aphid fluxes.
            INaphda = INaphdb;               INaphdb = zero   !kg N m-2 d-1. 
            ICaphda = ICaphdb;               ICaphdb = zero   !kg C m-2 d-1. 
            Oapta_axx1da = Oapta_axx1db;     Oapta_axx1db = zero 
            Oalaa_axx1da = Oalaa_axx1db;     Oalaa_axx1db = zero 
            Oapta_apt1da = Oapta_apt1db;     Oapta_apt1db = zero 
            Oalaa_apt1da = Oalaa_apt1db;     Oalaa_apt1db = zero 
            Oapta_ala1da = Oapta_ala1db;     Oapta_ala1db = zero 
            Oalaa_ala1da = Oalaa_ala1db;     Oalaa_ala1db = zero 
                                                       !aphids stem-1 d-1. 
            Oaph_mortda = Oaph_mortdb; Oaph_mortdb = zero  !aphids stem-1 d-1.
            Oalaa_emida = Oalaa_emidb; Oalaa_emidb = zero  !aphids stem-1 d-1.
            Oalaa_mortda = Oalaa_mortdb; Oalaa_mortdb = zero  
               !aphids stem-1 d-1.
            Oalaa_mortemida = Oalaa_mortemidb; Oalaa_mortemidb = zero  
                !aphids stem-1 d-1.
            Oaph_mortemida = Oaph_mortemidb; Oaph_mortemidb = zero  
               !aphids stem-1 d-1. Mortality and emigration.
            fmortda = fmortdb; fmortdb = zero  !d-1. Fractional mortality,
               !fmort = Oaph_mort / aph             

            !Phloem volume flux taken up by apterous adults: m3 aphid-1 d-1.
            vphloem_aptada = vphloem_aptadb;   vphloem_aptadb = zero

            !Total fecundity rate:
               Oaxxa_axx1da = Oaxxa_axx1db; Oaxxa_axx1db = zero 
                                            !1st instar aphids stem-1 d-1.
               !where Oaxxa_axx1 = Oalaa_axx1 + Oapta_axx1 !aphids stem-1 d-1.
                  Oaph_fecda = Oaxxa_axx1da   !For output only.

         !System.
            INsysda = INsysdb;               INsysdb = zero   !kg N m-2 d-1. 
            ONsysda = ONsysdb;               ONsysdb = zero   !kg N m-2 d-1. 
               ONsyse4da = ONsysda * c10000                   !kg N ha-1 d-1.
            DNsysda = DNsysdb;               DNsysdb = zero   !kg N m-2 d-1. 

            
      ENDIF !End of IF ( daybeg ) THEN block of resetting statements.

      !Now continue with integration:
         !Check with dychdb that we are summing to 1 day:
            dychdb = dychdb + maxt 
            kpulse_thindb = kpulse_thindb + kpulse_thin * maxt !Dimensionless.
                                             !Fraction removed by thinning.

            Onstems_thdb = Onstems_thdb + Onstems_th * maxt !Actual numbers
                                        !of stems removed by thinning.
                                        !stems removed per day.

            kprunedb = kprunedb + kprune * maxt !Dimensionless.
                                             !Fraction removed by pruning.

            pulse_firedb = pulse_firedb + pulse_fire * maxt !Dimensionless.
            kst_firezdb = kst_firezdb + kst_firez * maxt !(kst_firez: d-1)
            INtree_fire_Nammdb = INtree_fire_Nammdb + INtree_fire_Namm * maxt
            INsurf_li_fire_Nammdb = INsurf_li_fire_Nammdb + & 
                                    INsurf_li_fire_Namm * maxt 

         !Daily means of:
            Tairdb = Tairdb + Tair * maxt             !Air temperature, oC.
            Tsoildb = Tsoildb + Tsoil * maxt         !Soil temperature, oC.
            fTshdb = fTshdb + fTsh * maxt       !Shoot temperature function.
            fTsoildb = fTsoildb + fTsoil * maxt !Soil temperature function.
               !Temperature functions are dimensionless.

          !Soil water content (kg water m-2).
            Wsoildb = Wsoildb + Wsoil * maxt
          !Soil water fluxes: (kg water m-2 d-1) input and output
            IWsoildb = IWsoildb + IWsoil * maxt
            OWsoildb = OWsoildb + OWsoil * maxt
               
          !Soil water function (dimensionless). 
            fWsoildb = fWsoildb + fWsoil * maxt

!   PROCEDURAL
!         ilogd = i16
!          IF ( calllogd ) CALL LOGD( .true. ) 
!   END

         !Radiation, J (PAR) m-2 day-1:
            jPARscdb = jPARscdb + jPARsc * maxtsec !Incident light receipt.
            jPARscabsdb = jPARscabsdb + jPARscabs * maxtsec !Absorbed light.
         !Net radiation, J m-2 day-1:
            jNetRscdb = jNetRscdb + jNetRsc * maxtsec
         !Net radiation absorbed by canopy, J m-2 day-1:
            jNetRabs_candb = jNetRabs_candb + jNetRabs_can * maxt 

         !N fluxes. kg N m-2 day-1.
            !Fertilizer inputs:
               INfert_Nammdb =  INfert_Nammdb  + INfert_Namm  * maxt
               INfert_Nnitdb =  INfert_Nnitdb  + INfert_Nnit  * maxt
               zNfert1_Nmindb = zNfert1_Nmindb + zNfert1_Nmin * maxt
            !N input, environment to soil ammonium pool:
               INenv_Nammdb = INenv_Nammdb + INenv_Namm * maxt
            !N input, environment to soil nitrate pool:
               INenv_Nnitdb = INenv_Nnitdb + INenv_Nnit * maxt
            !N input, non-symbiotic N fixation to soil ammonium pool:
               INfix_Nammdb = INfix_Nammdb + INfix_Namm * maxt
            !N input, from root exudation:
               INfi_Nammdb = INfi_Nammdb + INfi_Namm * maxt
            !N input, from litter pools:
               INlitter_Nammdb = INlitter_Nammdb + INlitter_Namm * maxt
            !N input, from biomass death:
               INbio_Nammdb = INbio_Nammdb + INbio_Namm * maxt
            !N input, from SOM mineralization:
               INSOM_Nammdb = INSOM_Nammdb + INSOM_Namm * maxt

            !N uptake by trees:
               ONsoil_fidb = ONsoil_fidb + ONsoil_fi * maxt
            !Nnit, rate of change:
               DNnitdb = DNnitdb + DNnit * maxt
            !Nnit total input:
               INnitdb = INnitdb + INnit * maxt
            !Nnit, nitrification input from Namm:
               INamm_Nnitdb = INamm_Nnitdb + INamm_Nnit * maxt
            !Nnit total output:
               ONnitdb = ONnitdb + ONnit * maxt
            !Nnit output to immobilization:
               ONnit_immdb = ONnit_immdb + ONnit_imm * maxt
            !Nnit output to soil biomass growth:
               ONnit_bioGdb = ONnit_bioGdb + ONnit_bioG * maxt
            !Nnit output to roots:
               ONnit_rtdb = ONnit_rtdb + ONnit_rt * maxt
            !N output to nitrification:
               ONamm_nitrif_envdb = ONamm_nitrif_envdb &
                                  + ONamm_nitrif_env * maxt
            !N output to leaching:
               ONnit_lchdb = ONnit_lchdb + ONnit_lch * maxt
            !N output to volatilization:
               ONamm_voldb = ONamm_voldb + ONamm_vol * maxt
            !N output to denitrification:
               ONnit_denitdb = ONnit_denitdb + ONnit_denit * maxt

         !Water fluxes:
            DWledb = DWledb + DWle * maxt  !kg water stem day-1.

         !Relative humidity:
            RHdb = RHdb + RH * maxt
         !Wind:
            winddb = winddb + wind * maxt

!   PROCEDURAL
!    ilogd = i17
!     IF ( calllogd ) CALL LOGD( .true. ) 
!   END
         !Plant:
            !Structural dry mass of tree, MXtree (kg XDM stem-1)
               MXtreedb = MXtreedb + maxt * MXtree

           !Phenology
            kchilldb = kchilldb                + kchill * maxt
            kforcedb = kforcedb                + kforce * maxt
            kbudb_dorm1db = kbudb_dorm1db + kbudb_dorm1 * maxt
            kdorm1_2db = kdorm1_2db          + kdorm1_2 * maxt
            budsopeningdb = budsopeningdb + budsopening * maxt 
           !Budopening rate
            kObuddb = kObuddb                   + kObud * maxt
            OMbud_leaf1db = OMbud_leaf1db + OMbud_leaf1 * maxt
           !Leaf fall
            leaf_falldb = leaf_falldb       + leaf_fall * maxt
            OWle_lfdb = OWle_lfdb             + OWle_lf * maxt


            LAIdb = LAIdb   + LAI * maxt        !Leaf area index.
              !Photosynthesis asymptote, 20 deg C, and actual.
            DMXle1db = DMXle1db + DMXle1 * maxt !Rate of change of
              !1st foliage box. kg XDM stem-1 d-1.
            IXle1db = IXle1db + IXle1 * maxt  !Input to 1st foliage box.
            OXle1db = OXle1db + OXle1 * maxt  !Output from 1st foliage box.
                                              !kg XDM d-1.
            Pmax20db = Pmax20db + Pmax20 * maxt  !kg CO2 m-2 s-1.
            Pmaxdb = Pmaxdb + Pmax * maxt        !kg CO2 m-2 s-1.
            Nph_Adb = Nph_Adb + Nph_A * maxt     !kg photosynthetic N m-2.
            fWphdb = fWphdb + fWph * maxt        !Water potential effect on
                                                 !photosynthesis.
            fgstom_Pmaxdb = fgstom_Pmaxdb + fgstom_Pmax * maxt  !Stomatal
                                          !closure effect on photosynthesis.
            !Nph pool:
            INphdb =       INphdb +       INph * maxt
            ONphdb =       ONphdb +       ONph * maxt
            INSle_Nphdb =  INSle_Nphdb +  INSle_Nph * maxt
            INbud_Nphdb =  INbud_Nphdb +  INbud_Nph * maxt
            ONph_NSledb =  ONph_NSledb +  ONph_NSle * maxt
            ONph_li0db =   ONph_li0db +   ONph_li0 * maxt
            ONph_sndb =    ONph_sndb +    ONph_sn * maxt
            ONph_prunedb = ONph_prunedb + ONph_prune * maxt
            ONph_lfdb =    ONph_lfdb +    ONph_lf * maxt
            ONph_firedb =  ONph_firedb +  ONph_fire * maxt
            fNSle_Nphdb =  fNSle_Nphdb +  fNSle_Nph * maxt
            fjPAR_Nphdb =  fjPAR_Nphdb +  fjPAR_Nph * maxt


            Pcandb = Pcandb + Pcan * maxt  !kg C m-2 day-1.  
                                             !Gross canopy photosynthesis.
            Pcan_IPdb = Pcan_IPdb + Pcan_IP * maxt  !kg C m-2 day-1.  
                        !Gross canopy photosynthesis less isoprene emissions.
            OCle_IP_atm_gnddb = OCle_IP_atm_gnddb + OCle_IP_atm_gnd * maxt
                  !OCle_IP_atm_gnd is kg C in isoprene emissions:
                  !kg C m-2 day-1.

            !Foliage substrate C and N pools, MCSle, MNSle
            DMCSledb = DMCSledb + DMCSle * maxt !d/dt of MCSle. 
            DMNSledb = DMNSledb + DMNSle * maxt !d/dt of MNSle. 

            ICSledb = ICSledb + ICSle * maxt !Input to MCSle. kg CS stem-1 d-1.
            OCSledb = OCSledb + OCSle * maxt 
                                          !output from MCSle. kg CS stem-1 d-1.
            INSledb = INSledb + INSle * maxt !Input to MNSle. kg NS stem-1 d-1.
            ONSledb = ONSledb + ONSle * maxt 
                                          !output from MNSle. kg NS stem-1 d-1.

            Rtree_stemdb = Rtree_stemdb + Rtree_stem * maxt 
                          !Respiration of tree: kg C stem-1 (24-hour day)-1.
            Rtreem_stemdb = Rtreem_stemdb + Rtreem_stem * maxt !Maintenance,
            RtreeG_stemdb = RtreeG_stemdb + RtreeG_stem * maxt !Growth
                                   !respiration. kg C stem-1 (24-hour day)-1.
            Pnetdb = Pnetdb + Pnet * maxt            !Net primary production.
                                                            !kg C m-2 day-1.
           !Fractional birth/death rates of nstems due to self thinning:
            FBRnstemsdb = FBRnstemsdb + FBRnstems * maxt
                                                             !Dimensionless.
            FBRnstemstrzdb = FBRnstemstrzdb + FBRnstemstrz * maxt
            FBRnstemstrdb = FBRnstemstrdb + FBRnstemstr * maxt
            FBRnstemssddb = FBRnstemssddb + FBRnstemssd * maxt
                                                             !Dimensionless.
            FDRnstemsdb = FDRnstemsdb + FDRnstems * maxt 
                                                             !Dimensionless.
            FGRnstemsdb = FGRnstemsdb + FGRnstems * maxt     !Dimensionless.
         !Specific growth rates:
            sgrMtreedb = sgrMtreedb + sgrMtree * maxt
            sgrMXstdb =  sgrMXstdb  + sgrMXst  * maxt

         !Self-thinning exponent (Dimensionless).
            sn_expdb = sn_expdb + sn_exp * maxt
            sn_expMXstdb = sn_expMXstdb + sn_expMXst * maxt
            sn_expMXtreedb = sn_expMXtreedb + sn_expMXtree * maxt
            Instems_sndb = Instems_sndb + Instems_sn * maxt !# m-2 d-1.
            Onstems_sndb = Onstems_sndb + Onstems_sn * maxt !# m-2 d-1.
            Dnstems_sndb = Dnstems_sndb + Dnstems_sn * maxt !# m-2 d-1.

            Dhstemdb = Dhstemdb + Dhstem * maxt !Stem height growth (m day-1).
            Ddstemdb = Ddstemdb + Ddstem * maxt !Stem diameter growth
                                                !(m day-1).
         !kg N stem-1 (actual 24-hour day)-1:
            ONSle_atm_stemdb = ONSle_atm_stemdb + ONSle_atm_stem * maxt
                               !Ammonia emission from foliage. ONSle_atm_stem
                               !be + or - during the day.
            uN_stemdb = uN_stemdb + uN_stem * maxt !N uptake by tree
                                                   !(kg N stem-1 d-1).
            uN_gnddb = uN_gnddb + uN_gnd * maxt !ditto but kg N m-2 d-1.

            Cledb = Cledb   + Cle * maxt !Foliage C substrate concn.
            Nledb = Nledb   + Nle * maxt !Foliage N substrate concn.
            Cfidb = Cfidb   + Cfi * maxt !Fine roots C substrate concn.
            Nfidb = Nfidb   + Nfi * maxt !Fine roots N substrate concn.
            CStreedb = CStreedb   + CStree * maxt !Tree C substrate concn.
            NStreedb = NStreedb   + NStree * maxt !Tree N substrate concn.
                        !kg C, N substrate (kg structural DM)-1.
            CNtreedb = CNtreedb + CNtree * maxt !CSNStree. 
               !Tree nutrient status. 
               !(kg C substrate) (kg N substrate) (kg structural DM)-2.
            Cphloemdb = Cphloemdb + Cphloem * maxt       !Cphloem. 
            Nphloemdb = Nphloemdb + Nphloem * maxt       !Nphloem. 
            rCNphloemdb = rCNphloemdb + rCNphloem * maxt !rCNphloem. 


         !Soil submodel.
            Nmindb = Nmindb   + Nmin * maxt     !Soil mineral N. kg N m-2.

         !Water submodel.
            raindb = raindb + rain * maxt 
                                     !Rainfall: kg water m-2 (24-hour day)-1.
            psiPledb = psiPledb + psiPle * maxt !Foliage pressure
                                                    !potential.
            psiPfidb = psiPfidb + psiPfi * maxt !Fine root pressure
                                                    !potential.
            rpsiPle_fidb = rpsiPle_fidb + rpsiPle_fi * maxt !Ratio of
                           !foliage turgor pressure to fine root pressure.
            thetaledb = thetaledb + thetale * maxt
                                       !Foliage relative water content.
            OWso_fidb = OWso_fidb + OWso_fi * maxt 
               !Water flux, soil to fine roots: kg water m-2 (24-hour day)-1.
            OWle_atm_gnddb = OWle_atm_gnddb + OWle_atm_gnd * maxt 
            OWle_rad_gnddb = OWle_rad_gnddb + OWle_rad_gnd * maxt 
            OWle_vdg_gnddb = OWle_vdg_gnddb + OWle_vdg_gnd * maxt 
             !Water flux, foliage to atmosphere: kg water m-2 (24-hour day)-1.
            draindb = draindb + OWso_drain * maxt 
                                     !Drainage: kg water m-2 (24-hour day)-1.

         !Aphid fluxes.
            INaphdb = INaphdb   +  INaph * maxt   !kg N m-2 d-1. 
            ICaphdb = ICaphdb   +  ICaph * maxt   !kg C m-2 d-1. 
            Oapta_axx1db = Oapta_axx1db + Oapta_axx1 * maxt 
            Oalaa_axx1db = Oalaa_axx1db + Oalaa_axx1 * maxt 
            Oapta_apt1db = Oapta_apt1db + Oapta_apt1 * maxt 
            Oalaa_apt1db = Oalaa_apt1db + Oalaa_apt1 * maxt 
            Oapta_ala1db = Oapta_ala1db + Oapta_ala1 * maxt 
            Oalaa_ala1db = Oalaa_ala1db + Oalaa_ala1 * maxt 
                                                       !aphids stem-1 d-1. 
            Oaph_mortdb = Oaph_mortdb + Oaph_mort * maxt  !aphids stem-1 d-1.
            Oalaa_emidb = Oalaa_emidb + Oalaa_emi * maxt  !aphids stem-1 d-1. 
            Oalaa_mortdb = Oalaa_mortdb + Oalaa_mort * maxt  
               !aphids stem-1 d-1. 
            Oalaa_mortemidb = Oalaa_mortemidb + Oalaa_mortemi * maxt  
                                                        !aphids stem-1 d-1. 
            Oaph_mortemidb = Oaph_mortemidb + Oaph_mortemi * maxt 
                                                        !aphids stem-1 d-1.  
            fmortdb = fmortdb + fmort * maxt !d-1. Fractional mortality,
               !fmort = Oaph_mort / aph  !d-1. 

            !Phloem volume flux taken up by apterous adults: m3 aphid-1 d-1.
            vphloem_aptadb = vphloem_aptadb + vphloem_apta * maxt

            !Total fecundity from apta and alaa:
                Oaxxa_axx1db = Oaxxa_axx1db + Oaxxa_axx1 * maxt 
                                                        !aphids stem-1 d-1. 



         !System.
            INsysdb = INsysdb   + INsys * maxt     !kg N m-2 day-1.
            ONsysdb = ONsysdb   + ONsys * maxt     !kg N m-2 day-1.
            DNsysdb = DNsysdb   + DNsys * maxt     !kg N m-2 day-1.

   ENDIF  !End of procedure for calculating DAILY AVERAGES.


!YEARLY AVERAGES 
   !This block accumulates some fluxes, and calculates some averages
   !over the last complete year, i.e. from 0 h, 1 Jan to 24 h, 31 Dec.

      !Fya (F yearly average) is the sum of F*dt for the last year that has 
         !finished. 
      !Fyb is the sum of F*dt from the beginning of the
         !present year up to the current time + maxt.

   IF ( t .NE. tdumpya ) THEN
         !Procedure has already been executed at the
         !current time, in which case t = tdumpya
            tdumpya = t  !Store the present time.

      IF ( yearbeg ) THEN
         !A year is complete, or we are starting at t = 0. 
         !Move contents of accumulator Fyb to Fya and reset Fyb to 0.0.
            yrchya = yrchyb;               yrchyb = zero
            s_leafya = s_leafyb;           s_leafyb = zero
            kpulse_thinya = kpulse_thinyb;   kpulse_thinyb = zero
               !kpulse_thinya is equal to the relevant kthin falling
               !within the year, if any does.
               kpul_thinya = kpulse_thinya !For print output only.
            kpruneya = kpruneyb;   kpruneyb = zero
               !kpruneya is equal to the relevant kprune falling
               !within the year, if any does.
            pulse_fireya = pulse_fireyb;   pulse_fireyb = zero
               puls_fireya = pulse_fireya !For print output only.

         !Environment:
            jPARscya = jPARscyb;           jPARscyb = zero
                jPARdyem6ya = jPARscya / c365E6  !MJ PAR m-2 day-1.
            jPARscabsya = jPARscabsyb;     jPARscabsyb = zero
            jPAR_ravya = jPAR_ravyb;       jPAR_ravyb = zero
            jNetRscya = jNetRscyb;         jNetRscyb = zero  
            fbshrsya = fbshrsyb;           fbshrsyb = zero  
            Tairya = Tairyb;               Tairyb = zero
            Tsoilya = Tsoilyb;             Tsoilyb = zero
            RHya = RHyb;                   RHyb = zero
            rainya = rainyb;               rainyb = zero
            windya = windyb;               windyb = zero
            m_kminya = m_kminyb;           m_kminyb = zero

          !Environmental modifiers:
            fTshya = fTshyb;               fTshyb = zero
            fTrtya = fTrtyb;               fTrtyb = zero
            fT_Pmaxya = fT_Pmaxyb;         fT_Pmaxyb = zero


         !Tree:
            DCtreeya = DCtreeyb;           DCtreeyb = 0    !kg C m-2 year-1.
            DNtreeya = DNtreeyb;           DNtreeyb = 0    !kg N m-2 year-1.
            DWtreeya = DWtreeyb;           DWtreeyb = 0    !kg W m-2 year-1.

            ICtreeya = ICtreeyb;           ICtreeyb = 0    !kg C m-2 year-1.
            INtreeya = INtreeyb;           INtreeyb = 0    !kg N m-2 year-1.
            IWtreeya = IWtreeyb;           IWtreeyb = 0    !kg W m-2 year-1.

            OCtreeya = OCtreeyb;           OCtreeyb = 0    !kg C m-2 year-1.
            ONtreeya = ONtreeyb;           ONtreeyb = 0    !kg N m-2 year-1.
            OWtreeya = OWtreeyb;           OWtreeyb = 0    !kg W m-2 year-1.
 
           !nstems.
            nstemsya = nstemsyb;           nstemsyb = zero
            Dnstemsya = nstems - nstemsyz                  !stem m-2 year-1.
               nstems_1yr = nstemsyz; nstemsyz = nstems !Update stored values.
               log10nstems_1yr = log10nstemsz; log10nstemsz = log10nstems
               !nstems_1yr etc is the value of nstems 1 year ago.
                nstems_mn1yr = 0.5 * ( nstems_1yr + nstems )
                   !Mean valye over the last year.
                IF ( nstems_mn1yr .NE. zero ) THEN
                     fgrnstems_1yr = ( nstems - nstems_1yr ) &
                                     / nstems_mn1yr 
                ELSE
                     fgrnstems_1yr = csmall
                ENDIF

           !These fractional birth, death, growth rates are all year-1.
           !_sn denotes due to self-thinning, not including other thinning.
            FBRnstemsya = FBRnstemsyb;  FBRnstemsyb = zero
            FDRnstemsya = FDRnstemsyb;  FDRnstemsyb = zero
            z1_FDRnstemsya = z1_FDRnstemsyb;  z1_FDRnstemsyb = zero
            z2_FDRnstemsya = z2_FDRnstemsyb;  z2_FDRnstemsyb = zero
            FGRnstems_snya = FGRnstems_snyb;  FGRnstems_snyb = zero
               FBRnst_snya = FBRnstemsya ; FDRnst_snya = FDRnstemsya 
               FGRnst_snya = FGRnstems_snya 
            Instems_snya = Instems_snyb;      Instems_snyb = zero
            Onstems_snya = Onstems_snyb;      Onstems_snyb = zero
               Dnstems_snya = Instemsya - Onstems_snya

            FGRnstemsya = FGRnstemsyb;        FGRnstemsyb = zero
               FGRnstya = FGRnstemsya 


            Instemsya = Instemsyb;    Instemsyb = zero         !stems year-1.
            Onstemsya = Onstemsyb;    Onstemsyb = zero         !stems year-1.
            Onstems_thya = Onstems_thyb; Onstems_thyb = zero   !stems year-1.
            Onstems_fireya = Onstems_fireyb; ONstems_fireyb = zero
                                                               !stems year-1.
         !Seeds, nseeds (# seeds m-2)
            nseeds_1yr = nseedsyz; nseedsyz = nseeds !Update stored values.
                        !nseeds_1yr is the value of nseeds 1 yr ago.
                nseeds_mn1yr = 0.5 * ( nseeds_1yr + nseeds )
                   !Mean valye over the last year.
                IF ( nseeds_mn1yr .NE. zero ) THEN
                     fgrnseeds_1yr = ( nseeds - nseeds_1yr ) &
                                     / nseeds_mn1yr 
                ELSE
                     fgrnseeds_1yr = csmall
                ENDIF

            Otree_nseedsya = Otree_nseedsyb;   Otree_nseedsyb = zero
                Inseedsya = Otree_nseedsya
            Onseeds_deathya = Onseeds_deathyb; Onseeds_deathyb = zero
               Onsds_dthya = Onseeds_deathya  !For output only.
            Onseeds_germya = Onseeds_germyb;   Onseeds_germyb = zero
               Onsds_grmya = Onseeds_germya   !For output only.
                Onseedsya = Onseeds_deathya + Onseeds_germya 
            Dnseedsya = Dnseedsyb;             Dnseedsyb = zero

         !Self-thinning (sn)
           !Calculate self-thinning exponent for self-thinning eqn:
              !Mtree = constant * nstems ** ( - sn_exponent (aka 3/2) )
              !logMtree = constant - sn_exponent * lognstems
              !sn_exponent = - del(logMtree) / del(lognstems).
              !sn_exponent = - 1/M dM/dt / 1/n dn/dt (cf with 3/2)
            sn_expya = sn_expyb;     sn_expyb = zero
            sn_expMXstya = sn_expMXstyb;       sn_expMXstyb = zero
            sn_expMXtreeya = sn_expMXtreeyb;   sn_expMXtreeyb = zero

            Mtree_1yr = Mtreez;       Mtreez = Mtree
            MXst_1yr =   MXstz;       MXstz =  MXst
            MXtree_1yr =   MXtreez;   MXtreez =  MXtree
            Mtreesh_1yr =   Mtreeshz;       Mtreeshz =  Mtreesh
            Mtreert_1yr =   Mtreertz;       Mtreertz =  Mtreert
            log10Mtree_1yr = log10Mtreez; log10Mtreez = log10Mtree
            log10MXst_1yr = log10MXstz; log10MXstz = log10MXst
            log10MXtree_1yr = log10MXtreez; log10MXtreez = log10MXtree
            log10Mtreesh_1yr = log10Mtreeshz; log10Mtreeshz = log10Mtreesh
            log10Mtreert_1yr = log10Mtreertz; log10Mtreertz = log10Mtreert

           !log10nstems_1yr = log10nstemsz; !log10nstemsz = log10nstems Above.

            num_sn_exp =        log10Mtree_1yr  - log10Mtree  !numerator
            num_sn_expMXst =    log10MXst_1yr   - log10MXst
            num_sn_expMXtree =  log10MXtree_1yr - log10MXtree
            num_sn_expMtreesh = log10Mtreesh_1yr   - log10Mtreesh
            num_sn_expMtreert = log10Mtreert_1yr   - log10Mtreert
            den_sn_exp =        log10nstems_1yr - log10nstems !denominator
           !IF ( ABS( num_sn_exp ) .GT. c0x00001 .AND. &
           !     ABS( den_sn_exp ) .GT. c0x00001 .AND. &
            IF (        den_sn_exp .NE. zero   .AND. &
                                 t .NE. zero )  THEN
                 sn_exp1yr =     - num_sn_exp     / den_sn_exp 
                 sn_expMXst1yr = - num_sn_expMXst / den_sn_exp 
                 sn_expMXtree1yr = - num_sn_expMXtree / den_sn_exp 
                 sn_expMtreesh1yr = - num_sn_expMtreesh / den_sn_exp 
                 sn_expMtreert1yr = - num_sn_expMtreert / den_sn_exp 
                 alloMXst1yr = num_sn_expMXst / num_sn_exp !Allometric
                           !parameter, beta for MXst ~ Mtree ** beta.
            ELSE
                 sn_exp1yr     =      csmall
                 sn_expMXst1yr =      csmall
                 sn_expMXtree1yr =    csmall
                 sn_expMtreesh1yr =   csmall
                 sn_expMtreert1yr =   csmall
                 alloMxst1yr =        csmall
            ENDIF

            DMXstyaz = MXst - MXsty1;       MXsty1= MXst   !kg XDM year-1.
               IF ( t .EQ. zero ) THEN
                  DMXstya = zero
               ELSE
                  DMXstya = DMXstyaz
               ENDIF
            DLAIya = LAI - LAIy1                           !m2 m-2 year-1.
            IF ( LAIy1 .GT. zero ) RGRLAIya = DLAIya / LAIy1    !year-1.
               LAIy1 = LAI                                 !Update LAIy1.
            Pmax20ya = Pmax20yb;             Pmax20yb = zero  !kg CO2 m-2 s-1.
               Pmax20e6ya = Pmax20ya * c1E6     !mg CO2 m-2 s-1.
               Pmax20_qe6ya = r_MCO2_qCO2 * c1E6 * Pmax20ya
                                             !micromols CO2 m-2 s-1.
            IF ( s_leafya .NE. zero ) &
            Pmax20s_leafya = Pmax20s_leafyb * c365 / s_leafya 
                             Pmax20s_leafyb = zero       !kg CO2 m-2 s-1.
               Pmax20s_leaf_qe6ya = r_MCO2_qCO2 * c1E6 * Pmax20s_leafya
                                                     !micromols CO2 m-2 s-1.
            Pcanya = Pcanyb;               Pcanyb = zero    !kg C m-2 year-1.
            !Pcanya is gross production, GP. This includes isoprene emissions.
            GP = Pcanya !kg C m-2 y-1. 
            Pcan_IPya = Pcan_IPyb;         Pcan_IPyb = zero !kg C m-2 year-1.
           !Pcan_IP = Pcan - OCle_IP_atm_gnd  !kg C m-2 ground day-1.
               !ICsys = Pcan + ICimm_alaa_m2
                                                
                    !Pcan_IP = Pcan less isoprene emissions. IP = isoprene.
            OCle_IP_atm_gndya = OCle_IP_atm_gndyb;  OCle_IP_atm_gndyb = 0
                  !OCle_IP_atm_gnd is kg C in isoprene emissions:
                  !kg C m-2 day-1.
               IPya = OCle_IP_atm_gndya !For simplicity. Not used.
               IF ( t .GT. zero .OR. Pcanya .NE. zero ) THEN
                  fIP_Pcanya = OCle_IP_atm_gndya / Pcanya
               ELSE
                  fIP_Pcanya = csmall
               ENDIF

               IF ( nstems .GT. zero ) THEN
                    ICph_CSleya = Pcan_IPya / nstems  !kg C stem-1 year-1.
               ELSE
                    ICph_CSleya = clarge
               ENDIF
                                    
            Pnetya = Pnetyb;               Pnetyb = zero    !kg C m-2 year-1.
               IF ( Pcanya .GT. zero ) THEN
                    rPnet_Pcanya = Pnetya / Pcanya
               ELSE
                    rPnet_Pcanya = csmall
               ENDIF                       !dimensionless ratio.
                    rPnet_Pcaya = rPnet_Pcanya !Only 11 chars, no wrap when
                                               !printing.
            Pnet2ya = Pnet2yb;             Pnet2yb = zero !Pnet squared
                                            !(kg C m-2 d-1)^2 365 d y-1.

            !Respiration.
            RGbudya = RGbudyb;             RGbudyb = zero  !kg C stem-1 year-1.
            RGbrya = RGbryb;               RGbryb = zero   !ditto
            RGstya = RGstyb;               RGstyb = zero   !ditto
            RGcoya = RGcoyb;               RGcoyb = zero   !ditto
            RGfiya = RGfiyb;               RGfiyb = zero   !ditto
               RGtreeya = RGbudya + RGbrya + RGstya + RGcoya + RGfiya
                                                          !kg C stem-1 year-1.
               RGtree_gndya = nstems * RGtreeya           !kg C m-2 year-1.

            OCSle_maiya = OCSle_maiyb; OCSle_maiyb = zero !kg C stem-1 year-1.
            OCSbr_maiya = OCSbr_maiyb; OCSbr_maiyb = zero !kg C stem-1 year-1.
            OCSst_maiya = OCSst_maiyb; OCSst_maiyb = zero !kg C stem-1 year-1.
            OCSco_maiya = OCSco_maiyb; OCSco_maiyb = zero !kg C stem-1 year-1.
            OCSfi_maiya = OCSfi_maiyb; OCSfi_maiyb = zero !kg C stem-1 year-1.
               RmaiCS_treeya = OCSle_maiya + OCSbr_maiya + OCSst_maiya &
                             + OCSco_maiya + OCSfi_maiya !kg C stem-1 year-1.

            RmaiXleya = RmaiXleyb;     RmaiXleyb = zero   !kg C stem-1 year-1.
            RmaiXbrya = RmaiXbryb;     RmaiXbryb = zero   !kg C stem-1 year-1.
            RmaiXstya = RmaiXstyb;     RmaiXstyb = zero   !kg C stem-1 year-1.
            RmaiXcoya = RmaiXcoyb;     RmaiXcoyb = zero   !kg C stem-1 year-1.
            RmaiXfiya = RmaiXfiyb;     RmaiXfiyb = zero   !kg C stem-1 year-1.
               RmaiX_treeya = RmaiXleya + RmaiXbrya + RmaiXstya &
                             + RmaiXcoya + RmaiXfiya     !kg C stem-1 year-1.
            Rmai_treeya = RmaiCS_treeya + RmaiX_treeya   !kg C stem-1 year-1.
               IF ( Rmai_treeya .GT. zero ) &
                             rRG_Rmai_treeya = RGtreeya / Rmai_treeya 
               IF ( RGtreeya .GT. zero ) &
                             rRmai_RGtreeya = Rmai_treeya / RGtreeya
               Rmai_tree_gndya = nstems * Rmai_treeya   !kg C m-2 year-1.

            RNmin_uptya = RNmin_uptyb; RNmin_uptyb = zero !kg C stem-1 year-1.
               RNmin_upt_gndya = nstems * RNmin_uptya    !kg C m-2 year-1.
            Rmin_uptya = Rmin_uptyb;   Rmin_uptyb = zero  !kg C stem-1 year-1.
               Rmin_upt_gndya = nstems * Rmin_uptya      !kg C m-2 year-1.
            RNnit_red_fiya = RNnit_red_fiyb;  RNnit_red_fiyb = zero
                                                         !kg C stem-1 year-1.
            RNnit_red_leya = RNnit_red_leyb;  RNnit_red_leyb = zero !ditto
               RNnit_red_treeya = RNnit_red_leya + RNnit_red_fiya  !ditto
                  RNn_rd_trya = RNnit_red_treeya 
               RNnit_red_tree_gndya = nstems * RNnit_red_treeya 
                                                            !kg C m-2 year-1.
            Rphloem_loadingya = Rphloem_loadingyb;
                                              Rphloem_loadingyb = zero
               Rphl_loadya = Rphloem_loadingya 
               Rphloem_loading_gndya = nstems * Rphloem_loadingya  
                                                        !kg C m-2 year-1.
               OCSfi_Nnit_redya = RNnit_red_fiya        !kg C stem-1 year-1.
               OCSle_Nnit_redya = RNnit_red_leya        !kg C stem-1 year-1.
               OCSle_loadingya =  Rphloem_loadingya     !kg C stem-1 year-1.

               Rtree_stemya = RGtreeya + Rmai_treeya + RNmin_uptya &
                              + Rphloem_loadingya + Rmin_uptya &
                              + RNnit_red_treeya 
               Rtree_gndya = nstems * Rtree_stemya

              IF (Pcanya .GT. zero ) &
                             rRtree_gndPcanya = Rtree_gndya / Pcanya

            !Next are again in kg C stem-1 year-1:
            !Growth of meristem structure and non-meristem structure:
            OCSbr_budya = OCSbr_budyb;     OCSbr_budyb = zero
            OCSle_budya = OCSle_budyb;     OCSle_budyb = zero
            OCSbr_Gya = OCSbr_Gyb;         OCSbr_Gyb = zero
            OCSst_Gya = OCSst_Gyb;         OCSst_Gyb = zero
            OCSco_Gya = OCSco_Gyb;         OCSco_Gyb = zero
            OCSfi_Gya = OCSfi_Gyb;         OCSfi_Gyb = zero

            !Transport fluxes:
            OCSle_CSbrya = OCSle_CSbryb;   OCSle_CSbryb = zero
            OCSbr_CSstya = OCSbr_CSstyb;   OCSbr_CSstyb = zero
            OCSst_CScoya = OCSst_CScoyb;   OCSst_CScoyb = zero
            OCSco_CSfiya = OCSco_CSfiyb;   OCSco_CSfiyb = zero

            Dhstemya = Dhstemyb;           Dhstemyb = zero
            Ddstemya = Ddstemyb;           Ddstemyb = zero
               IF ( Ddstemya .NE. zero ) rDhDdstemya = Dhstemya / Ddstemya
               IF ( rhdstem .GT. zero )  rFGRhdstemya = rDhDdstemya / rhdstem
            rISGRle_snya = rISGRle_snyb;   rISGRle_snyb = zero
            rDhDdstemGya = rDhDdstemGyb;   rDhDdstemGyb = zero
            rDhDdstemWya = rDhDdstemWyb;   rDhDdstemWyb = zero

            !Buds:
            fGbud_thetaleya = fGbud_thetaleyb; fGbud_thetaleyb = zero

            !Foliage growth items:
            ISGRleya = ISGRleyb;        ISGRleyb = zero 
            ISGRstya = ISGRstyb;        ISGRstyb = zero 
            PXDMbudya = PXDMbudyb;      PXDMbudyb = zero 
            PXDMbrmya = PXDMbrmyb;      PXDMbrmyb = zero 
            PXDMstmya = PXDMstmyb;      PXDMstmyb = zero 
            PXDMcomya = PXDMcomyb;      PXDMcomyb = zero 
            PXDMfimya = PXDMfimyb;      PXDMfimyb = zero 
               PXDMtreeya = PXDMbudya + PXDMbrmya + PXDMstmya + &
                            PXDMcomya + PXDMfimya
              !Fractions of XDM in the different categories over 1 year:
                 IF ( PXDMtreeya .NE. zero ) THEN
                      fPXDMbudya = PXDMbudya / PXDMtreeya
                      fPXDMbrmya = PXDMbrmya / PXDMtreeya
                      fPXDMstmya = PXDMstmya / PXDMtreeya
                      fPXDMcomya = PXDMcomya / PXDMtreeya
                      fPXDMfimya = PXDMfimya / PXDMtreeya
                 ENDIF
            IXle1ya = IXle1yb;     IXle1yb = zero !Input to 1st foliage
                                              !compartment.  XDM stem-1 y-1.
            OXle1ya = OXle1yb;     OXle1yb = zero !Output from 1st foliage
                                              !compartment.  XDM stem-1 y-1.
            IXfi1ya = IXfi1yb;     IXfi1yb = zero !Input to 1st fine
                                              !root compartment.  XDM.
               IF ( IXfi1ya .NE. zero ) rIXle_fiya = IXle1ya / IXfi1ya
                  !Ratio of inputs to leaf growth and fine root growth.
               IXleya = IXle1ya; IXfiya = IXfi1ya !For convenience/output.
            IXbrya = IXbryb;     IXbryb = zero !Input to branches.
            IXstya = IXstyb;     IXstyb = zero !Input to stem.
            IXcoya = IXcoyb;     IXcoyb = zero !Input to coarse roots.
               IXtreeya = IXle1ya + IXbrya + IXstya + IXcoya + IXfi1ya
                                                          !kg XDM stem-1 y-1.
            IXtree_gndya = IXtree_gndyb; IXtree_gndyb = zero !kg XDM m-2 y-1.
               IXtree_gndXfCstXya = IXtree_gndya * fCstX !kg C m-2 y-1.
                   !Compare this with Pnetya (assumes all fC tree cpts are
                                            !the same).

               IF ( IXtreeya .NE. zero ) THEN
                    fGXleya = IXle1ya / IXtreeya
                    fGXbrya = IXbrya / IXtreeya
                    fGXstya = IXstya / IXtreeya
                    fGXcoya = IXcoya / IXtreeya
                    fGXfiya = IXfi1ya / IXtreeya
               ELSE
                    fGXleya = csmall !7.7777e-17
                    fGXbrya = csmall 
                    fGXstya = csmall 
                    fGXcoya = csmall 
                    fGXfiya = csmall 
               ENDIF
               

            ICbud_Xle1_gndya = ICbud_Xle1_gndyb;  ICbud_Xle1_gndyb = zero
            IC_Xbrtot_gndya = IC_Xbrtot_gndyb;          IC_Xbrtot_gndyb = zero
            IC_Xsttot_gndya = IC_Xsttot_gndyb;          IC_Xsttot_gndyb = zero
            IC_Xcotot_gndya = IC_Xcotot_gndyb;          IC_Xcotot_gndyb = zero
            IC_Xfitot_gndya = IC_Xfitot_gndyb;          IC_Xfitot_gndyb = zero
               IC_Xtree_gndya = ICbud_Xle1_gndya + IC_Xbrtot_gndya &
                              + IC_Xsttot_gndya  + IC_Xcotot_gndya &
                              + IC_Xfitot_gndya 
               IF ( IC_Xtree_gndya .NE. zero ) THEN
                    fC_IXleya = ICbud_Xle1_gndya / IC_Xtree_gndya
                    fC_IXbrya = IC_Xbrtot_gndya  / IC_Xtree_gndya
                    fC_IXstya = IC_Xsttot_gndya  / IC_Xtree_gndya
                    fC_IXcoya = IC_Xcotot_gndya  / IC_Xtree_gndya
                    fC_IXfiya = IC_Xfitot_gndya  / IC_Xtree_gndya
               ELSE
                    fC_IXleya = csmall !7.7777e-17
                    fC_IXbrya = csmall 
                    fC_IXstya = csmall 
                    fC_IXcoya = csmall 
                    fC_IXfiya = csmall 
               ENDIF

            IAleaf1ya = IAleaf1yb;      IAleaf1yb = zero !Ditto. Leaf area.
            SLAXnewya = SLAXnewyb;      SLAXnewyb = zero !SLA of new growth.


            OCtree_soilya = OCtree_soilyb; OCtree_soilyb = zero!kg C m-2 y-1.
            uN_stemya = uN_stemyb;      uN_stemyb = zero !kg N stem-1 year-1.
            uN_gndya = uN_gndyb;     uN_gndyb = zero     !kg N m-2 year-1.
               uN_gnde4ya = c10000 * uN_gndya               !kg N ha-1 year-1.

           !Integral of uN_gnd^2:
            uN_gnd2ya = uN_gnd2yb;   uN_gnd2yb = zero 
                                              ![(kg N m-2 d-1)^2 x 365 d y-1].
           !Integrals of uN_gnd * INsys (and ONsys):
            uN_gndINsysya = uN_gndINsysyb;   uN_gndINsysyb = zero 
            uN_gndONsysya = uN_gndONsysyb;   uN_gndONsysyb = zero 
            uN_gndPnetya = uN_gndPnetyb;     uN_gndPnetyb = zero 

        !Foliage NH3 emission, may be + or -:
            ONSle_atm_gndya = ONSle_atm_gndyb;  ONSle_atm_gndyb = zero
                                                           !kg N m-2 year-1.
               INatm_NSle_gndya = - ONSle_atm_gndya        !kg N m-2 year-1.
               ONSle_atm_gnde4ya = ONSle_atm_gndya * c10000!kg N ha-1 year-1.
               INatm_NSle_gnde4ya = - ONSle_atm_gnde4ya    !kg N ha-1 year-1.

            IXfimya = IXfimyb;             IXfimyb = zero

            fWleya = fWleyb;       fWleyb = zero  !Foliage water function.



         !Litter and soil (kg C, N m-2 year-1):
            ICtree_soilya = ICtree_soilyb;  ICtree_soilyb = zero 
               ICtree_soya = ICtree_soilya                !kg C m-2 year-1.
            INtree_soilya = INtree_soilyb;  INtree_soilyb = zero 
               INtree_soya = INtree_soilya                !kg N m-2 year-1.
            INenv_soilya = INenv_soilyb;  INenv_soilyb = zero 
                                                            !kg N m-2 year-1.
            DCsoilya = DCsoilyb;           DCsoilyb = 0    !kg C m-2 year-1.
            DNsoilya = DNsoilyb;           DNsoilyb = 0    !kg N m-2 year-1.
            DWsoilya = DWsoilyb;           DWsoilyb = 0    !kg W m-2 year-1.

            ICsoilya = ICsoilyb;           ICsoilyb = 0    !kg C m-2 year-1.
            INsoilya = INsoilyb;           INsoilyb = 0    !kg N m-2 year-1.
            IWsoilya = IWsoilyb;           IWsoilyb = 0    !kg W m-2 year-1.

            OCsoilya = OCsoilyb;           OCsoilyb = 0    !kg C m-2 year-1.
            ONsoilya = ONsoilyb;           ONsoilyb = 0    !kg N m-2 year-1.
            OWsoilya = OWsoilyb;           OWsoilyb = 0    !kg W m-2 year-1.

            OCsol_lchya = OCsol_lchyb;     OCsol_lchyb = zero

            Rsoilya = Rsoilyb;             Rsoilyb = 0     !kg C m-2 year-1.
            
            kXle_liya =  kXle_liyb;        kXle_liyb = zero
            kXle1_2ya =  kXle1_2yb;        kXle1_2yb = zero
            kXle2_3ya =  kXle2_3yb;        kXle2_3yb = zero
            kXle3_4ya =  kXle3_4yb;        kXle3_4yb = zero
            kXle4_liya = kXle4_liyb;       kXle4_liyb = zero
            !Leaf lifetime over the 4 compartments:
            IF ( kXle1_2ya .NE. zero .AND. kXle2_3ya .NE. zero .AND. &
                 kXle3_4ya .NE. zero .AND. kXle4_liya .NE. zero ) THEN
               tau_le_liya = one / kXle1_2ya + one / kXle2_3ya &
                           + one / kXle3_4ya + one / kXle4_liya     !d.
            ELSE
               tau_le_liya = clarge !7.7777e17.
            ENDIF
               tau_le_liyrya = tau_le_liya / c365  !y.

            OXle4_liya = OXle4_liyb;       OXle4_liyb = zero
            OXbr_liya = OXbr_liyb;         OXbr_liyb = zero
            OXst_liya = OXst_liyb;         OXst_liyb = zero

            ICsurf_liya = ICsurf_liyb;     ICsurf_liyb = zero
            INsurf_liya = INsurf_liyb;     INsurf_liyb = zero
           !Components of ICsurf_li:
            ICsurf_li_metya = ICsurf_li_metyb;     ICsurf_li_metyb = zero
            ICsurf_li_celya = ICsurf_li_celyb;     ICsurf_li_celyb = zero
            ICsurf_li_ligya = ICsurf_li_ligyb;     ICsurf_li_ligyb = zero
            ICtree_surf_liya = ICtree_surf_liyb;  ICtree_surf_liyb = zero
            ICaph_surf_li_metya = ICaph_surf_li_metyb;
                                           ICaph_surf_li_metyb = zero
            ICaph_surf_liya = ICaph_surf_liyb;  ICaph_surf_liyb = zero
           !Components of INsurf_li:
            INtree_surf_liya = INtree_surf_liyb;  INtree_surf_liyb = zero
            INaph_surf_liya = INaph_surf_liyb;  INaph_surf_liyb = zero

            ICsoil_liya = ICsoil_liyb;     ICsoil_liyb = zero
            INsoil_liya = INsoil_liyb;     INsoil_liyb = zero
           !Components of ICsoil_li:
            ICSsoil_liya = ICSsoil_liyb;   ICSsoil_liyb = zero
            ICXsoil_liya = ICXsoil_liyb;   ICXsoil_liyb = zero
           !Components of INsoil_li:
            INSsoil_liya = INSsoil_liyb;   INSsoil_liyb = zero
            INXsoil_liya = INXsoil_liyb;   INXsoil_liyb = zero

            INsurf_li_Nammya = INsurf_li_Nammyb;  INsurf_li_Nammyb = zero
            INsoil_li_Nammya = INsoil_li_Nammyb;  INsoil_li_Nammyb = zero
               INlitter_Nammya = INsurf_li_Nammya + INsoil_li_Nammya 
            fTsurfya = fTsurfyb;                 fTsurfyb = zero
            fWsurfya = fWsurfyb;                 fWsurfyb = zero

            rCNsurf_liya = rCNsurf_liyb;         rCNsurf_liyb = zero
            frCNsurf_liya = frCNsurf_liyb;       frCNsurf_liyb = zero
            fdecay_lig_surfya = fdecay_lig_surf; fdecay_lig_surfyb = zero

            fTsoilya = fTsoilyb;                 fTsoilyb = zero
            fWsoilya = fWsoilyb;                 fWsoilyb = zero

            rCNsoil_liya = rCNsoil_liyb;         rCNsoil_liyb = zero
            frCNsoil_liya = frCNsoil_liyb;       frCNsoil_liyb = zero
            fdecay_lig_soilya = fdecay_lig_soil; fdecay_lig_soilyb = zero

            ksurf_li_celya = ksurf_li_celyb;     ksurf_li_celyb = zero
            ksoil_li_celya = ksoil_li_celyb;     ksoil_li_celyb = zero
            ksurf_li_ligya = ksurf_li_ligyb;     ksurf_li_ligyb = zero !d-1.
               IF ( ksurf_li_ligya .NE. zero ) THEN
                    tau_surf_li_ligya = one / ksurf_li_ligya  !d.
               ELSE
                    tau_surf_li_ligya = clarge
               ENDIF
               tau_surf_li_ligyrya = tau_surf_li_ligya / c365  !y.
            ksoil_li_ligya = ksoil_li_ligyb;     ksoil_li_ligyb = zero

               IClitterya = ICsurf_liya + ICsurf_liya
               INlitterya = INsurf_liya + INsurf_liya
               INlittere4ya = c10000 * INlitterya      !kg N ha-1 year-1.

            kuSOM_minya = kuSOM_minyb;           kuSOM_minyb = zero
            kpSOM_minya = kpSOM_minyb;           kpSOM_minyb = zero
            ksSOM_minya = ksSOM_minyb;           ksSOM_minyb = zero

            INuSOM_Nammya = INuSOM_Nammyb;       INuSOM_Nammyb = zero
            INpSOM_Nammya = INpSOM_Nammyb;       INpSOM_Nammyb = zero
            INsSOM_Nammya = INsSOM_Nammyb;       INsSOM_Nammyb = zero
            INSOM_Nammya = INSOM_Nammyb;         INSOM_Nammyb = zero
               INliSOM_Nammya = INlitter_Nammya + INSOM_Nammya
               INSOM_Namme4ya = c10000 * INSOM_Nammya  !kg ha-1 y-1.
            ONmin_immya = ONmin_immyb;     ONmin_immyb =  zero
                          ONmin_imme4ya = c10000 * ONmin_immya
               IF ( INSOM_Nammya .NE. zero ) THEN
                    rNmin_imm_minya = ONmin_immya / INSOM_Nammya 
               ELSE
                    rNmin_imm_minya = clarge
               ENDIF
                  !Ratio of immobilization from Nmin (Namm + Nnit) to 
                  !mineralization of SOM to Namm.
            netSOM_minfluxya = netSOM_minfluxyb; netSOM_minfluxyb =  zero
               netSOM_minfluxe4ya = c10000 * netSOM_minfluxya !kg N ha-1 y-1.
               NSO_mine4ya = netSOM_minfluxe4ya !For printing.
                 

            ONtreeX_gndya = ONtreeX_gndyb; ONtreeX_gndyb = zero
            INtreeS_gndya = INtreeS_gndyb; INtreeS_gndyb = zero
               !Ratio of recycled N flux to total initial N flux 
               !towards litter:
               IF ( ONtreeX_gndya .NE. zero ) &
                  rINtreeS_ONtreeXya = INtreeS_gndya / ONtreeX_gndya

            INammya = INammyb;             INammyb = zero
            INfi_Nammya = INfi_Nammyb;     INfi_Nammyb = zero
            INbio_Nammya = INbio_Nammyb;   INbio_Nammyb = zero
            INenv_Nammya = INenv_Nammyb;   INenv_Nammyb = zero
               INenv_Namya = INenv_Nammya !11 chars for output.
               INen_Nae4ya = c10000 * INenv_Nammya !kg N ha-1 y-1.
               INe_Ne4ya = INen_Nae4ya 

            INenv_Nnitya = INenv_Nnityb;   INenv_Nnityb = zero
               INenv_Nminya = INenv_Nammya + INenv_Nnitya
               

               INenv_Nmine4ya = INenv_Nminya * c10000    !kg N ha-1 y-1.

            zNfert_Nminya = zNfert_Nminyb; zNfert_Nminyb = zero
               zNfert_Nmiya = zNfert_Nminya  !For output.
               zNfert_Nmya =  zNfert_Nminya  !For output.
            INfert_Nammya = INfert_Nammyb; INfert_Nammyb = zero
               INfert_Namya = INfert_Nammya  !For output.
               INfert_Naya = INfert_Nammya   !For output.
            INfert_Nnitya = INfert_Nnityb; INfert_Nnityb = zero
               INfert_Nniya = INfert_Nnitya !For output.
               INfert_Nnya = INfert_Nnitya  !For output.
               INfert_Nminya = INfert_Nammya + INfert_Nnitya
               INfert_Nmine4ya = INfert_Nminya * c10000  !kg N ha-1 y-1.

            INfix_Nammya = INfix_Nammyb;   INfix_Nammyb = zero
               INfix_Namya = INfix_Nammya 
               INfix_Namme4ya = c10000 * INfix_Nammya    !kg N ha-1 y-1.
               INfx_Nae4ya = INfix_Namme4ya              !kg N ha-1 y-1.
            ONsoil_fiya = ONsoil_fiyb;     ONsoil_fiyb = zero
            ONnit_lchya = ONnit_lchyb;     ONnit_lchyb = zero
                  ONnit_lche4ya = c10000 * ONnit_lchya   !kg N ha-1 y-1.
                  ON_lche4ya = ONnit_lche4ya !For printing.
            ONamm_volya = ONamm_volyb;     ONamm_volyb = zero
                  ONamm_vole4ya = c10000 * ONamm_volya   !kg N ha-1 y-1.
            ONamm_nitya = ONamm_nityb;     ONamm_nityb = zero
                  ONamm_nite4ya = c10000 * ONamm_nitya   !kg N ha-1 y-1.
            ONamm_nitrif_envya = ONamm_nitrif_envyb; 
                                           ONamm_nitrif_envyb = zero
               ONamm_nitrif_enve4ya = c10000 * ONamm_nitrif_envya 
                                                         !kg N ha-1 y-1.
            ONnit_denitya = ONnit_denityb; ONnit_denityb = zero
                  ONnit_denite4ya = c10000 * ONnit_denitya !kg N ha-1 y-1.
               ONsoil_gasya = ONamm_volya + ONamm_nitrif_envya &
                                          + ONnit_denitya
                  !Gaseous N outputs from soil (kg N m-2 year-1).
               ONsys_gasya = ONsoil_gasya + ONSle_atm_gndya
               ONsys_gase4ya = ONsys_gasya * c10000  !kg N ha-1 y-1.
                  !Gaseous N outputs from system (kg N m-2 year-1).
               ONsoil_gaya = ONsoil_gasya !Output only.
               ONsys_envya = ONsys_gasya + ONnit_lchya
                  !N outputs from system (not products) (kg N m-2 year-1).
         !sSOM pool:
             DCsSOMya = DCsSOMyb;            DCsSOMyb = zero
             ICsSOMya = ICsSOMyb;            ICsSOMyb = zero
             ICuSOM_sSOMya = ICuSOM_sSOMyb;  ICuSOM_sSOMyb = zero
             ICpSOM_sSOMya = ICpSOM_sSOMyb;  ICpSOM_sSOMyb = zero
             OCsSOM_minya = OCsSOM_minyb;    OCsSOM_minyb = zero
             INsSOMya = INsSOMyb;            INsSOMyb = zero
             ONsSOM_Nammya = ONsSOM_Nammyb;  ONsSOM_Nammyb = zero
             rCNsSOMnya = rCNsSOMnyb;        rCNsSOMnyb = zero

         !Water fluxes (all kg water m-2 year-1, except drainya):
!           rainya = rainyb;               rainyb = zero   See above
               IWsysya = rainya  !At present, IWsys = rain.
               !OWsys = OWrain_int + OWle_atm_gnd + OWso_atm + OWso_drain &
               !  + OWprthd + OWprrod (these last 2 = OWprd).
            OWsysya = OWsysyb;             OWsysyb = zero
            OWso_drainya = OWso_drainyb;   OWso_drainyb = zero
               OWso_drain_mya = OWso_drainya / roW      !m water year-1.
               OWso_drain_mmya = c1000 * OWso_drain_mya !mm water year-1.
            OWrain_intya = OWrain_intyb;   OWrain_intyb = zero
            OWle_atm_gndya = OWle_atm_gndyb;  OWle_atm_gndyb = zero
               IF ( nstems .GT. zero ) OWle_atmya = OWle_atm_gndya / nstems 
            OWle_rad_gndya = OWle_rad_gndyb;  OWle_rad_gndyb = zero 
            OWle_vdg_gndya = OWle_vdg_gndyb;  OWle_vdg_gndyb = zero
            OWso_atmya = OWso_atmyb;       OWso_atmyb = zero
            OWprdya = OWprdyb;     OWprdyb = zero

         !Products:
            IVptya = IVptyb;         IVptyb = zero !Input by volume, to
                        !products of thinning. !m3 wood (m2 ground)-1 year-1.
            Vpth_haya = 10000.0 * IVptya                !m3 wood ha-1 year-1.
            INth_prya = INth_pryb;   INth_pryb = zero !kg N m-2 year-1. 
                                            !N input, thinning, to products.
            OCprdya = OCprdyb;       OCprdyb = zero !kg C m-2 year.
                                            !C output from decaying 
                                            !rotation product pool Cprd. 
            ONprdya = ONprdyb;       ONprdyb = zero
               OCprd_envya = OCprdya
               ONprd_envya = ONprdya
         
            ICprune_prodya = ICprune_prodyb;   ICprune_prodyb = zero
                  !C input to products from pruning (kg C m-2 year-1).
                  ICpru_prya = ICprune_prodya !for output only.
       
         !System fluxes (kg C, N m-2 y-1 unless stated otherwise):
            ICsysya = ICsysyb;             ICsysyb = zero  
               !aS ICsys = Pcan + ICimm_alaa_m2 
            ICimm_alaa_m2ya = ICimm_alaa_m2yb; ICimm_alaa_m2yb = zero  
            OCsysya = OCsysyb;             OCsysyb = zero
            DCsysya = DCsysyb;             DCsysyb = zero
            DCsys_chkya = DCsys_chkyb;     DCsys_chkyb = zero

            INsysya = INsysyb;             INsysyb = zero 
               INsyse4ya = c10000 * INsysya                  !kg N ha-1 y-1.
            ONsysya = ONsysyb;             ONsysyb = zero
               ONsyse4ya = c10000 * ONsysya                  !kg N ha-1 y-1.
               I_ONsy4ya = INsyse4ya - ONsyse4ya             !kg N ha-1 y-1.
            I_ONsysya = INsysya - ONsysya                    !kg m-2 year-1.
            DNsysya = DNsysyb;             DNsysyb = zero    !kg N m-2 y-1.
               DNsyse3ya = c1000 * DNsysya                   !g N m-2 y-1.
               DNsyse4ya = c10000 * DNsysya                  !kg N ha-1 y-1.
            DNsysya_last_year = DNsysya !Store last years value.
            D2nsysya = DNsysya - DNsysya_last_year
            DNsys_chkya = DNsys_chkyb;     DNsys_chkyb = zero

           !Squared values are averaged [(kg N m-2 d-1)^2 x 365 d y-1]:
            INsys2ya = INsys2yb;             INsys2yb = zero  
            ONsys2ya = ONsys2yb;             ONsys2yb = zero
   
           !Correlation coefficients:
      IF ( nstart .GT. i1 ) THEN !Failure if nstart = 1, the first run.
               ruN_gndINsysya = &
     ( uN_gndINsysya / c365 - (uN_gndya / c365) * (INsysya / c365) ) / ( &
     ( SQRT( uN_gnd2ya / c365 - (uN_gndya / c365) * (uN_gndya / c365)) ) * &
     ( SQRT( INsys2ya / c365 - (INsysya / c365) * (INsysya / c365)) ) )
               ruN_gndONsysya = &
     ( uN_gndONsysya / c365 - (uN_gndya / c365) * (ONsysya / c365) ) / ( &
     ( SQRT( uN_gnd2ya / c365 - (uN_gndya / c365) * (uN_gndya / c365)) ) * &
     ( SQRT( ONsys2ya / c365 - (ONsysya / c365) * (ONsysya / c365)) ) )
               ruN_gndPnetya = &
     ( uN_gndPnetya / c365 - (uN_gndya / c365) * (Pnetya / c365) ) / ( &
     ( SQRT( uN_gnd2ya / c365 - (uN_gndya / c365) * (uN_gndya / c365)) ) * &
     ( SQRT( Pnet2ya / c365 - (Pnetya / c365) * (Pnetya / c365)) ) )
      ENDIF

         !Property variables:
            yrch_15hya = yrch_15hyb / c365; yrch_15hyb = zero

            fWph_15hya = fWph_15hyb / c365; fWph_15hyb = zero
            fgstom_Pmax_15hya = fgstom_Pmax_15hyb / c365
                                fgstom_Pmax_15hyb = zero
                  fgsPx_15hya = fgstom_Pmax_15hya !For output only.

         !Aphid submodel:
            aphya = aphyb;     aphyb = zero !Aphids per stem.
            Axxaya = Axxayb;   Axxayb = zero !Adult aphids stem-1.
            !Axxa = apta + alaa.
            alaaya = alaayb; alaayb = zero !Adult alate aphids stem-1.
            aptaya = aptayb; aptayb = zero !Adult apterous aphids stem-1.
           !where Axxa = apta + alaa !adult aphids, numbers (stem)-1.
            alaya = alayb;   alayb = zero !Alate aphids stem-1.
            aptya = aptyb;   aptyb = zero !Apterous aphids stem-1.

            roaphya = roaphyb;     roaphyb = zero 
                               !Aphids per m2 of aphid inhabited leaf (2,3,4).
            survivalya = survivalyb; survivalyb = zero

            kapt1_2ya = kapt1_2yb;  kapt1_2yb = zero !d-1. Development rate
                  !of 1st apterous instar.
            kaph_mortya = kaph_mortyb; kaph_mortyb = zero !d-1. Mortality rate.

            !Survival = kapt1_2 / ( kapt1_2 + kaph_mort ). Instantaneous value.
              !This is averaged over 1 y to give survivalya.
            !We can also calculate
               IF ( ( kapt1_2ya + kaph_mortya ) .GT. zero ) THEN
                  Survival1ya = kapt1_2ya / ( kapt1_2ya + kaph_mortya )
               ELSE
                  Survival1ya = csmall
               ENDIF
            Daphya = Daphyb;     Daphyb = zero !Aphids per stem d-1.
            OCaph_mort_m2ya = OCaph_mort_m2yb;  OCaph_mort_m2yb = zero
            ONaph_mort_m2ya = ONaph_mort_m2yb;  ONaph_mort_m2yb = zero
               OCAp_m_m2ya = OCaph_mort_m2ya; ONAp_m_m2ya = ONaph_mort_m2ya

            Oaph_mortya = Oaph_mortyb; Oaph_mortyb = zero  !aphids stem-1 y-1.
            Oalaa_emiya = Oalaa_emiyb; Oalaa_emiyb = zero  !aphids stem-1 y-1.
            Oalaa_mortya = Oalaa_mortyb; Oalaa_mortyb = zero  
               Oalaa_morya = Oalaa_mortya !For print output only.
               !aphids stem-1 y-1.
            Oalaa_mortemiya = Oalaa_mortemiyb; Oalaa_mortemiyb = zero  
                !aphids stem-1 y-1. 
                Oalaa_meiya = Oalaa_mortemiya !For print output only.
           !Put these onto a daily basis:
               Oalaa_emiyady = Oalaa_emiya * oneOVER365
               Oalaa_mortyady = Oalaa_mortya * oneOVER365
               Oalaa_mortemiyady = Oalaa_mortemiya * oneOVER365
                  !Note oneOVER365 has units of years per day.
                  Oalaa_eyady = Oalaa_emiyady
                  Oalaa_myady = Oalaa_mortyady
                  Oaaa_meyady = Oalaa_mortemiyady
            Oaph_mortemiya = Oaph_mortemiyb; Oaph_mortemiyb = zero  
               !aphids stem-1 y-1. Mortality and emigration.
            !On a ground area basis  (eg Oalaa_emi_m2 = nstems * Oalaa_emi):
               Oalaa_emi_m2ya = Oalaa_emi_m2yb; Oalaa_emi_m2yb = zero 
                                                        !aphids m-2 y-1.
               OCalaa_emi_m2ya = OCalaa_emi_m2yb; OCalaa_emi_m2yb = zero 
                                                       !kg C m-2 y-1.
               ONalaa_emi_m2ya = ONalaa_emi_m2yb; ONalaa_emi_m2yb = zero 
                                                       !kg N m-2 y-1.
            !Total fecundity rate:
            Oaxxa_axx1ya = Oaxxa_axx1yb; Oaxxa_axx1yb = zero 
               !1st instar aphids stem-1 y-1.
               !and Oaxxa_axx1 = Oalaa_axx1 + Oapta_axx1 !aphids stem-1 d-1.
            !Fecundity rates of alate adults and apterous adults:
            Oalaa_axx1ya = Oalaa_axx1yb; Oalaa_axx1yb = zero 
            Oapta_axx1ya = Oapta_axx1yb; Oapta_axx1yb = zero 
               !_axx1 includes both alate and apterous 1st instar offspring.
            Oaph_fecya = Oaxxa_axx1ya   !For output only.

            !Fractional mortality, emigration, mortality + emigration,
            !fecundity rates:
                    fmortya = fmortyb;   fmortyb = zero
               IF ( aphya .GT. zero ) THEN !We assume that if aphya .gt. 0, 
                                           !then axxaya is also .gt. 0.
                    fmort2ya = Oaph_mortya / aphya          !y-1.
                    femiya =  Oalaa_emiya / aphya               !y-1.
                    fmortemiya =  ( Oaph_mortya + Oalaa_emiya ) / aphya  !y-1.
                    ffecaxxaya = Oaxxa_axx1ya / axxaya              !y-1.
                       !where axxa = apta + alaa   !adult aphid #'s (stem)-1.
               ELSE
                    fmort2ya = csmall 
                    femiya = csmall 
                    fmortemiya = csmall
                    ffecaxxaya = csmall
               ENDIF
           !Put fmort2ya on a per day basis so it can be compared with fmort.
                fmort2yady = fmort2ya * oneOVER365 !d-1.
                fmortyady =   fmortya * oneOVER365 !d-1.

         !? annual averages of fecundity, by above or by fecundity over the
         !year.  We do not calculate ffecaxxayb. See below.

            kaph_Tmortya = kaph_Tmortyb;          kaph_Tmortyb = zero
            kaph_Nmortya =    kaph_Nmortyb;     kaph_Nmortyb = zero


            ICphloem_aphya = ICphloem_aphyb;      ICphloem_aphyb = zero
            INphloem_aphya = INphloem_aphyb;      INphloem_aphyb = zero

            ICphloem_aph_m2ya = ICphloem_aph_m2yb; ICphloem_aph_m2yb = zero
            INphloem_aph_m2ya = INphloem_aph_m2yb; INphloem_aph_m2yb = zero

            INphloem_aptaya = INphloem_aptayb;    INphloem_aptayb = zero
            INphloem_alaaya = INphloem_alaayb;    INphloem_alaayb = zero

            INphloem_apta_aphidya = INphloem_apta_aphidyb; 
            INphloem_apta_aphidyb = zero !kg N apterous adult aphid day-1.
               INp_apa_aya = INphloem_apta_aphidya 

            INphloem_alaa_aphidya = INphloem_alaa_aphidyb; 
            INphloem_alaa_aphidyb = zero !kg N alate adult aphid day-1.
               INp_ala_aya = INphloem_alaa_aphidya 

           !Tree phenology:
            dormantya = dormantyb;         dormantyb = zero
            budburstya = budburstyb;       budburstyb = zero
            budsopeningya = budsopeningyb; budsopeningyb = zero
            leaf_fallya = leaf_fallyb;     leaf_fallyb = zero

            MXtreeya = MXtreeyb;            MXtreeyb = zero
            MCStreeya = MCStreeyb;          MCStreeyb = zero
            MCStorestya = MCStorestyb;      MCStorestyb = zero

            Mbudya = Mbudyb;                Mbudyb = zero
            MXleya = MXleyb;                MXleyb = zero
               MXle_gndya = nstems * MXleya !Assumes nstems is constant.
            MXbrya = MXbryb;                MXbryb = zero
            MXbrmya = MXbrmyb;              MXbrmyb = zero
            MXstya = MXstyb;                MXstyb = zero
            MXstmya = MXstmyb;              MXstmyb = zero
            Mstya = Mstyb;                  Mstyb = zero
            Mst_gndya = Mst_gndyb;          Mst_gndyb = zero
            MXcoya = MXcoyb;                MXcoyb = zero
            MXcomya = MXcomyb;              MXcomyb = zero
            MXfiya = MXfiyb;                MXfiyb = zero
            MXfimya = MXfimyb;              MXfimyb = zero
               IF ( MXtreeya .NE. zero ) THEN
                    fbudya = Mbudya / MXtreeya
                       fXbudya = fbudya !for output purposes.
                    fbudya = Mbudya / MXtreeya
                    fXleya = MXleya / MXtreeya
                    fXbrya = MXbrya / MXtreeya
                    fXbrmya = MXbrmya / MXtreeya
                    fXstya = MXstya / MXtreeya
                    fXstmya = MXstmya / MXtreeya
                    fXcoya = MXcoya / MXtreeya
                    fXcomya = MXcomya / MXtreeya
                    fXfiya = MXfiya / MXtreeya
                    fXfimya = MXfimya / MXtreeya
                ELSE
                    fbudya = csmall 
                    fXbudya = csmall !for output purposes.
                    fbudya = csmall
                    fXleya = csmall
                    fXbrya = csmall
                    fXbrmya = csmall
                    fXstya = csmall
                    fXstmya = csmall
                    fXcoya = csmall
                    fXcomya = csmall
                    fXfiya = csmall
                    fXfimya = csmall
                ENDIF

            Mleya = Mleyb;                  Mleyb = zero
               Mle_gndya = nstems * Mleya !Assumes nstems is fairly constant.
            MXle1ya = MXle1yb;              MXle1yb = zero
            MXle2ya = MXle2yb;              MXle2yb = zero
            MXle3ya = MXle3yb;              MXle3yb = zero
            MXle4ya = MXle4yb;              MXle4yb = zero
    
            LAIya = LAIyb;                 LAIyb = zero
            Mtreeya = Mtreeyb;             Mtreeyb = zero 
                !kg DM structure and storage per stem.
          
               IF ( LAIya .GT. zero ) rPcanLAIya = Pcanya / LAIya
            Aleafya = Aleafyb;             Aleafyb = zero

            Aleaf_aphya = Aleaf_aphyb;     Aleaf_aphyb = zero

            IF (s_leafya .NE. zero .AND. s_leafya .LT. clarge ) THEN
               LAIs_leafya = LAIs_leafyb * c365 / s_leafya
               Aleafs_leafya = Aleafs_leafyb * c365 / s_leafya
            ELSE
               LAIs_leafya = clarge
               Aleafs_leafya = clarge
            ENDIF;              
               LAIs_leafyb = zero
               Aleafs_leafyb = zero
                   Aleafs_leya = Aleafs_leafya !For output only.

            hstemya = hstemyb;             hstemyb = zero
            SLAya = SLAyb;                 SLAyb = zero

            IF (s_leafya .NE. zero .AND. s_leafya .LT. clarge ) THEN
               SLAs_leafya = SLAs_leafyb * c365 / s_leafya
            ELSE
               SLAs_leafya = clarge
            ENDIF;                         SLAs_leafyb = zero

            rCNleya = rCNleyb;             rCNleyb = zero
            IF (s_leafya .NE. zero ) &
               rCNles_leafya = rCNles_leafyb * c365 / s_leafya
                                           rCNles_leafyb = zero
               rCNles_lfya = rCNles_leafya 
            fSLA_rCNya = fSLA_rCNyb;       fSLA_rCNyb = zero
            fSLA_Cya = fSLA_Cyb;           fSLA_Cyb = zero
            fSLA_CMMya = fSLA_CMMyb;       fSLA_CMMyb = zero
            fSLA_Wya = fSLA_Wyb;           fSLA_Wyb = zero

            Cleya = Cleyb;                 Cleyb = zero
            Cbrya = Cbryb;                 Cbryb = zero
            Cstya = Cstyb;                 Cstyb = zero
            Ccoya = Ccoyb;                 Ccoyb = zero
            Cfiya = Cfiyb;                 Cfiyb = zero
            Nleya = Nleyb;                 Nleyb = zero
            Nbrya = Nbryb;                 Nbryb = zero
            Nstya = Nstyb;                 Nstyb = zero
            Ncoya = Ncoyb;                 Ncoyb = zero
            Nfiya = Nfiyb;                 Nfiyb = zero
            Cphloemya = Cphloemyb;         Cphloemyb = zero
            Nphloemya = Nphloemyb;         Nphloemyb = zero
            rCNphloemya = rCNphloemyb;     rCNphloemyb = zero
            Cletotya = Cletotyb;           Cletotyb = zero
            CSletotya = CSletotyb;         CSletotyb = zero
            CXletotya = CXletotyb;         CXletotyb = zero
            NXleya = NXleyb;               NXleyb = zero
            NXfiya = NXfiyb;               NXfiyb = zero
            MNphya = MNphyb;               MNphyb = zero
            MNSleya = MNSleyb;             MNSleyb = zero
            MNSleya = MNSleyb;             MNSleyb = zero
            Nphya = Nphyb;                 Nphyb = zero
            Nph_Aya = Nph_Ayb;             Nph_Ayb = zero
            Nletotya = Nletotyb;           Nletotyb = zero
               Nletote3ya = c1000 * Nletotya   !g N (kg total DM)-1.
            NSletotya = NSletotyb;         NSletotyb = zero
            Nphtotya = Nphtotyb;           Nphtotyb = zero
            NXletotya = NXletotyb;         NXletotyb = zero
            Nletot_Xya = Nletot_Xyb;       Nletot_Xyb = zero
            Nletot_Aya = Nletot_Ayb;       Nletot_Ayb = zero
            CNleya = CNleyb;               CNleyb = zero
            CNbrya = CNbryb;               CNbryb = zero
            CNstya = CNstyb;               CNstyb = zero
            CNcoya = CNcoyb;               CNcoyb = zero
            CNfiya = CNfiyb;               CNfiyb = zero
            CStreeya = CStreeyb;           CStreeyb = zero
            rCNStreeya = rCNStreeyb;       rCNStreeyb = zero
            
            IF (s_leafya .NE. zero .AND. s_leafya .LT. clarge ) THEN
               rCNStrees_leafya = rCNStrees_leafyb * c365 / s_leafya
            ELSE
               rCNStrees_leafya = clarge
            ENDIF;                         rCNStrees_leafyb = zero

            NStreeya = NStreeyb;           NStreeyb = zero
            CNtreeya = CNtreeyb;           CNtreeyb = zero
               CNStreeya = CNtreeya; CSNStreeya = CNtreeya !Output only.
               CNStreee4ya = c10000 * CNStreeya 
               CNtreee4ya = CNStreee4ya 
           !Components of CNtree = ...
            zCNleya = zCNleyb;           zCNleyb = zero
            zCNbrya = zCNbryb;           zCNbryb = zero
            zCNstya = zCNstyb;           zCNstyb = zero
            zCNcoya = zCNcoyb;           zCNcoyb = zero
            zCNfiya = zCNfiyb;           zCNfiyb = zero
            CNtreefTshya = CNtreefTshyb;       CNtreefTshyb = zero 
               CNtrfTe4ya = c10000 * CNtreefTshya 
            fCXle_recya = fCXle_recyb;     fCXle_recyb = zero
            fNXle_recya = fNXle_recyb;     fNXle_recyb = zero
            fCXbr_recya = fCXbr_recyb;     fCXbr_recyb = zero
            fNXbr_recya = fNXbr_recyb;     fNXbr_recyb = zero
            fCXco_recya = fCXco_recyb;     fCXco_recyb = zero
            fNXco_recya = fNXco_recyb;     fNXco_recyb = zero
            fCXfi_recya = fCXfi_recyb;     fCXfi_recyb = zero
            fNXfi_recya = fNXfi_recyb;     fNXfi_recyb = zero
            fCSmai_treeya = fCSmai_treeyb; fCSmai_treeyb = zero
            Ntree_mai_gndya = Ntree_mai_gndyb;  Ntree_mai_gndyb = zero
            rshrtya = rshrtyb;             rshrtyb = zero
            rlefiya = rlefiyb;             rlefiyb = zero
            rlefiGXya = rlefiGXyb;         rlefiGXyb = zero

         !Soil soluble C pool:
            Csolya = Csolyb;               Csolyb = zero
         !Soil microbes pool, Cbio:
            DCbioya = DCbioyb;             DCbioyb = zero
            Cbioya = Cbioyb;               Cbioyb = zero
            Gbioya = Gbioyb;               Gbioyb = zero               
            Dbioya = Dbioyb;               Dbioyb = zero               
            fCNbioya = fCNbioyb;           fCNbioyb = zero
            fbiomaxya = fbiomaxyb;         fbiomaxyb = zero
            fbiominya = fbiominyb;         fbiominyb = zero

            Neff_uNya = Neff_uNyb;         Neff_uNyb = zero
            Neff_bioya = Neff_bioyb;       Neff_bioyb = zero
            Nammya = Nammyb;               Nammyb = zero
            Nnitya = Nnityb;               Nnityb = zero
               Nminya = Nammya + Nnitya;  !kg N m-2.
               IF ( Nnitya .NE. zero ) rNammNnitya = Nammya / Nnitya
               Namme3ya = c1000 * Nammya       !g N m-2.
               Nnite3ya = c1000 * Nnitya       !g N m-2.
               Nmine3ya = Namme3ya + Nnite3ya  !g N m-2.
               Nmine4ya = c10000 * Nminya      !kg N ha-1.

            psiPleya = psiPleyb;           psiPleyb = zero
            psiPleqya = psiPleqyb;         psiPleqyb = zero
            psiPfiya = psiPfiyb;           psiPfiyb = zero
            rpsiPle_fiya = rpsiPle_fiyb;   rpsiPle_fiyb = zero
            thetaleya = thetaleyb;         thetaleyb = zero
            
            Csysya = Csysyb;               Csysyb = zero
            Ctreeya = Ctreeyb;   Ctreeyb = zero
            Csoilya = Csoilyb;             Csoilyb = zero
            Clitterya = Clitteryb;         Clitteryb = zero
            Csurf_li_metya = Csurf_li_metyb;  Csurf_li_metyb = zero
            Csurf_li_celya = Csurf_li_celyb;  Csurf_li_celyb = zero
            Csurf_li_ligya = Csurf_li_ligyb;  Csurf_li_ligyb = zero
            Csurf_liya = Csurf_liyb;       Csurf_liyb = zero

            Csoil_liya = Csoil_liyb;       Csoil_liyb = zero
            
            CSOMya = CSOMyb;               CSOMyb = zero
            CuSOMya = CuSOMyb;             CuSOMyb = zero
            CpSOMya = CpSOMyb;             CpSOMyb = zero
            CsSOMya = CsSOMyb;             CsSOMyb = zero
            Cptrdya = Cptrdyb;             Cptrdyb = zero

            Nsysya = Nsysyb;               Nsysyb = zero
            Ntreeya = Ntreeyb;             Ntreeyb = zero
            Nsoilya = Nsoilyb;             Nsoilyb = zero
            Nlitterya = Nlitteryb;         Nlitteryb = zero
            Nsurf_liya = Nsurf_liyb;       Nsurf_liyb = zero
            Nsoil_liya = Nsoil_liyb;       Nsoil_liyb = zero
            NSOMya = NSOMyb;               NSOMyb = zero
            Nptrdya = Nptrdyb;             Nptrdyb = zero

      ENDIF !End of resetting statements.

      !Now continue with integration:
         !Check that we are summing to 1 year:
            yrchyb = yrchyb + maxt                       !days. 
            kpulse_thinyb = kpulse_thinyb + kpulse_thin * maxt !day-1.
                                                   !Thinning rate constant.
            kpruneyb = kpruneyb + kprune * maxt !day-1.
                                                   !Pruning rate constant.
            pulse_fireyb = pulse_fireyb + pulse_fire * maxt !days of fire.


         !Environment:  
            jPARscyb = jPARscyb + jPARsc * maxtsec   !J (PAR) m-2 year-1.
                                         !Annual radiation (PAR) receipt.
            jPARscabsyb = jPARscabsyb + jPARscabs * maxtsec 
                                         !J (PAR) m-2 year-1.
                                         !Annual radiation (PAR) absorbed by
                                         !canopy.
            jPAR_ravyb = jPAR_ravyb + jPAR_rav * maxtsec !J (PAR) m-2 year-1.
                                         !Running average (_rav) of jPARsc.
            jNetRscyb = jNetRscyb + jNetRsc * maxtsec !Net radiation.
            Tairyb =  Tairyb + Tair * maxtyear   !deg C.  Air temperature.
            Tsoilyb = Tsoilyb + Tsoil * maxtyear !deg C. Soil temperature.
            RHyb = RHyb + RH * maxtyear          !Relative humidity.
            rainyb =         rainyb +         rain * maxt !Rainfall.
            windyb =         windyb +         wind * maxtyear !Windspeed.
            m_kminyb = m_kminyb + m_kmin * maxtyear  !Dimensionless
                                   !multiplier of mineralization constants.

         !Environmental modifiers:  
            fTshyb =  fTshyb + fTsh * maxtyear !Dimensionless. Shoot modifier.
            fTrtyb =  fTrtyb + fTrt * maxtyear !Dimensionless. Root modifier.
            fT_Pmaxyb =  fT_Pmaxyb + fT_Pmax * maxtyear !Dimensionless.
                                               !Photosynthesis Pmax modifier.

         !Tree:
            Pmax20yb = Pmax20yb + Pmax20 * maxtyear      !kg CO2 m-2 sec-1.
            Pmax20s_leafyb = Pmax20s_leafyb + Pmax20s_leaf * maxtyear
            !Gross photosynthesis, Pcan:
            Pcanyb = Pcanyb + Pcan * maxt                !kg C m-2 year-1.
            Pcan_IPyb = Pcan_IPyb + Pcan_IP * maxt       !kg C m-2 year-1.
               !_IP = less isoprene emissions.
               !Pcan_IP = Pcan - OCle_IP_atm_gnd  !kg C m-2 ground day-1.

            OCle_IP_atm_gndyb = OCle_IP_atm_gndyb + OCle_IP_atm_gnd * maxt
               !kg in isoprene emissions (m2 gnd)-1 year-1.

            !Net annual primary production: 
            Pnetyb = Pnetyb + Pnet * maxt                !kg C m-2 year-1.
            Pnet2yb = Pnet2yb + Pnet * Pnet * maxt       !(kg C m-2 d-1)^2 
                                                         !365 d y-1.

            DCtreeyb = DCtreeyb + DCtree * maxt           !kg C m-2 year-1.
            DNtreeyb = DNtreeyb + DNtree * maxt           !kg N m-2 year-1.
            DWtreeyb = DWtreeyb + DWtree * maxt           !kg W m-2 year-1.

            ICtreeyb = ICtreeyb + ICtree * maxt           !kg C m-2 year-1.
            INtreeyb = INtreeyb + INtree * maxt           !kg N m-2 year-1.
            IWtreeyb = IWtreeyb + IWtree * maxt           !kg W m-2 year-1.

            OCtreeyb = OCtreeyb + OCtree * maxt           !kg C m-2 year-1.
            ONtreeyb = ONtreeyb + ONtree * maxt           !kg N m-2 year-1.
            OWtreeyb = OWtreeyb + OWtree * maxt           !kg W m-2 year-1.



         !Seeds, nseeds (# seeds m-2)
            Otree_nseedsyb = Otree_nseedsyb + Otree_nseeds * maxt       
                                                         !# seeds m-2 year-1.
            Onseeds_deathyb = Onseeds_deathyb + Onseeds_death * maxt !ditto
            Onseeds_germyb = Onseeds_germyb + Onseeds_germ * maxt    !ditto
            Dnseedsyb = Dnseedsyb + Dnseeds * maxt                   !ditto

         !Self-thinning exponent (Dimensionless).
            sn_expyb = sn_expyb + sn_exp * maxtyear
            sn_expMXstyb = sn_expMXstyb + sn_expMXst * maxtyear
            sn_expMXtreeyb = sn_expMXtreeyb + sn_expMXtree * maxtyear

         !Compartments of tree:
            !C fluxes (kg C stem-1 year-1)
            !Growth respiration components:
            RGbudyb = RGbudyb + RGbud * maxt      !Buds.
            RGbryb = RGbryb + RGbr * maxt         !Branches.
            RGstyb = RGstyb + RGst * maxt         !Stem.
            RGcoyb = RGcoyb + RGco * maxt         !Coarse roots.
            RGfiyb = RGfiyb + RGfi * maxt         !Fine roots.
            RNmin_uptyb = RNmin_uptyb + RNmin_upt * maxt
                           !N uptake in fine roots.

            !Maintenance respiration components:
            !C substrate dependent terms:
            OCSle_maiyb = OCSle_maiyb + OCSle_mai * maxt   !Foliage (leaves).
            OCSbr_maiyb = OCSbr_maiyb + OCSbr_mai * maxt   !Branches.
            OCSst_maiyb = OCSst_maiyb + OCSst_mai * maxt   !Stem.
            OCSco_maiyb = OCSco_maiyb + OCSco_mai * maxt   !Coarse roots.
            OCSfi_maiyb = OCSfi_maiyb + OCSfi_mai * maxt   !Fine roots and 
                                                              !mycorrhiza.
            !Structural DM degradation terms:
            RmaiXleyb = RmaiXleyb + RmaiXle * maxt   !Foliage (leaves).
            RmaiXbryb = RmaiXbryb + RmaiXbr * maxt   !Branches.
            RmaiXstyb = RmaiXstyb + RmaiXst * maxt   !Stem.
            RmaiXcoyb = RmaiXcoyb + RmaiXco * maxt   !Coarse roots.
            RmaiXfiyb = RmaiXfiyb + RmaiXfi * maxt   !Fine roots and 
                                                        !mycorrhiza.
            Rphloem_loadingyb = Rphloem_loadingyb + Rphloem_loading * maxt
                                                           !Phloem loading.
            Rmin_uptyb = Rmin_uptyb + Rmin_upt * maxt
                              !Respiration for root mineral (exc. N) uptake.
            RNmin_uptyb = RNmin_uptyb + RNmin_upt * maxt
                                                    !N uptake in fine roots.
            RNnit_red_fiyb = RNnit_red_fiyb + RNnit_red_fi * maxt 
                        !Root nitrate reduction respiration.
            RNnit_red_leyb = RNnit_red_leyb + RNnit_red_le * maxt 
                        !Foliage nitrate reduction respiration.



            !Growth of meristem structure and non-meristem structure:
            OCSle_budyb = OCSle_budyb + OCSle_bud * maxt   !Buds. 
            OCSbr_budyb = OCSbr_budyb + OCSbr_bud * maxt   !Buds. 
            OCSbr_Gyb = OCSbr_Gyb + OCSbr_G * maxt   !Branches.
            OCSst_Gyb = OCSst_Gyb + OCSst_G * maxt   !Stem.
            OCSco_Gyb = OCSco_Gyb + OCSco_G * maxt   !Coarse roots.
            OCSfi_Gyb = OCSfi_Gyb + OCSfi_G * maxt   !Fine roots and 
                                                        !mycorrhiza.

            !C substrate transport: 
            OCSle_CSbryb = OCSle_CSbryb + OCSle_CSbr * maxt 
                                                       !Foliage to branches.
                                         !C transport into branches.
            OCSbr_CSstyb = OCSbr_CSstyb + OCSbr_CSst * maxt 
                                                       !Branches to stem.
            OCSst_CScoyb = OCSst_CScoyb + OCSst_CSco  * maxt 
                                                       !Stem to coarse roots.
            OCSco_CSfiyb = OCSco_CSfiyb + OCSco_CSfi  * maxt   
                                                 !Coarse roots to fine roots. 

            dhstemyb = dhstemyb + dhstem * maxt  !m year-1.
                                         !Stem height growth rate.
            ddstemyb = ddstemyb + ddstem * maxt  !m year-1.
                                         !Stem diameter growth rate.
            rISGRle_styb = rISGRle_styb + rISGRle_st * maxtyear !Dimensionless.
               !Ratio of intrinsic specific growth rates of le:st meristems.
            rDhDdstemGyb = rDhDdstemGyb + rDhDdstemG * maxtyear !Ratio of
                  !stem height:diameter growth rates obtained from growth.
            rDhDdstemWyb = rDhDdstemWyb + rDhDdstemW * maxtyear !Modifier of
                  !stem height:diameter growth ratio due to water (foliage
                  !pressure potential).

            !Buds:
            fGbud_thetaleyb = fGbud_thetaleyb + fGbud_thetale * maxtyear
               !Dimensionless. Fraction by which bud growth and opening is
               !switched off by water stress.

            ISGRleyb = ISGRleyb + ISGRle * maxtyear !day-1. 
            ISGRstyb = ISGRstyb + ISGRst * maxtyear !day-1. 
            PXDMbudyb = PXDMbudyb + PXDMbud * maxt  !kg XDM stem-1 day-1.
            PXDMbrmyb = PXDMbrmyb + PXDMbrm * maxt  !kg XDM stem-1 day-1.
            PXDMstmyb = PXDMstmyb + PXDMstm * maxt  !kg XDM stem-1 day-1.
            PXDMcomyb = PXDMcomyb + PXDMcom * maxt  !kg XDM stem-1 day-1.
            PXDMfimyb = PXDMfimyb + PXDMfim * maxt  !kg XDM stem-1 day-1.
                             !Production of XDM by the various meristems.
            !Structural inputs (kg XDM stem-1 year-1):
            IXle1yb = IXle1yb + IXle1 * maxt  !Input to 1st foliage box.
            OXle1yb = OXle1yb + OXle1 * maxt  !Output from 1st foliage box.
            IXbryb = IXbryb + IXbr * maxt  !Input to branches.
            IXstyb = IXstyb + IXst * maxt  !Input to stem.
            IXcoyb = IXcoyb + IXco * maxt  !Input to coarse roots.
            IXtree_gndyb = IXtree_gndyb + IXtree_gnd * maxt  !Input to 5 tree
                           !compartments (le1, br, st, co, fi1, not buds).
                           !See <IXtree = >.  kg XDM m-2 y-1.
            IXfi1yb = IXfi1yb + IXfi1 * maxt  !Input to 1st fine root box.

            !C inputs into XDM in tree structural compartments:
            ICbud_Xle1_gndyb = ICbud_Xle1_gndyb + ICbud_Xle1_gnd * maxt
            IC_Xbrtot_gndyb = IC_Xbrtot_gndyb + IC_Xbrtot_gnd * maxt
            IC_Xsttot_gndyb = IC_Xsttot_gndyb + IC_Xsttot_gnd * maxt
            IC_Xcotot_gndyb = IC_Xcotot_gndyb + IC_Xcotot_gnd * maxt
            IC_Xfitot_gndyb = IC_Xfitot_gndyb + IC_Xfitot_gnd * maxt 
                                                              !kg C m-2 y-1.

            IAleaf1yb = IAleaf1yb + IAleaf1 * maxt        !Ditto.  Leaf area.
                                               !m2 leaf m-2 year-1.
            SLAXnewyb = SLAXnewyb + SLAXnew * maxtyear    !SLA of new growth.
                                                     !m2 new leaf (kg XDM)-1.

         !C output from tree to soil:
            OCtree_soilyb = OCtree_soilyb + OCtree_soil* maxt   !kg C m-2 y-1.
         !N ammonia emissions by foliage (ONSle_atm_gnd can be + or -):
            ONSle_atm_gndyb = ONSle_atm_gndyb + ONSle_atm_gnd * maxt
                                                           !kg N m-2 year-1.
         !N uptake by plant:
            uN_stemyb = uN_stemyb + uN_stem * maxt         !kg N stem-1 year-1.
            uN_gndyb = uN_gndyb + uN_gnd * maxt            !kg N m-2 year-1.
            uN_gnd2yb = uN_gnd2yb + uN_gnd * uN_gnd * maxt 
                                             ![(kg N m-2 d-1)^2 x 365 d y-1].
            !For correlations:
            uN_gndINsysyb = uN_gndINsysyb + uN_gndINsys * maxt
            uN_gndONsysyb = uN_gndONsysyb + uN_gndONsys * maxt
            uN_gndPnetyb = uN_gndPnetyb + uN_gndPnet * maxt

         !N input, surface litter to Namm:
            INsurf_li_Nammyb = INsurf_li_Nammyb + INsurf_li_Namm * maxt
         !N input, soil litter to Namm:
            INsoil_li_Nammyb = INsoil_li_Nammyb + INsoil_li_Namm * maxt

         !Surface and soil litter modifiers (dimensionless):
            fTsurfyb = fTsurfyb +                 fTsurf * maxtyear
            fWsurfyb = fWsurfyb +                 fWsurf * maxtyear
            rCNsurf_liyb = rCNsurf_liyb +         rCNsurf_li * maxtyear
            frCNsurf_liyb = frCNsurf_liyb +       frCNsurf_li * maxtyear
            fdecay_lig_surfyb = fdecay_lig_surfyb + fdecay_lig_surf * maxtyear

            fTsoilyb = fTsoilyb +                 fTsoil * maxtyear
            fWsoilyb = fWsoilyb +                 fWsoil * maxtyear
            rCNsoil_liyb = rCNsoil_liyb +         rCNsoil_li * maxtyear
            frCNsoil_liyb = frCNsoil_liyb +       frCNsoil_li * maxtyear
            fdecay_lig_soilyb = fdecay_lig_soilyb + fdecay_lig_soil * maxtyear

            ksurf_li_celyb = ksurf_li_celyb +     ksurf_li_cel * maxtyear
            ksoil_li_celyb = ksoil_li_celyb +     ksoil_li_cel * maxtyear
            ksurf_li_ligyb = ksurf_li_ligyb +     ksurf_li_lig * maxtyear
            ksoil_li_ligyb = ksoil_li_ligyb +     ksoil_li_lig * maxtyear

            kuSOM_minyb = kuSOM_minyb +           kuSOM_min * maxtyear
            kpSOM_minyb = kpSOM_minyb +           kpSOM_min * maxtyear
            ksSOM_minyb = ksSOM_minyb +           ksSOM_min * maxtyear

         !N input, mineralization from 3 SOM pools to Namm:
            INuSOM_Nammyb = INuSOM_Nammyb + INuSOM_Namm * maxt
            INpSOM_Nammyb = INpSOM_Nammyb + INpSOM_Namm * maxt
            INsSOM_Nammyb = INsSOM_Nammyb + INsSOM_Namm * maxt
            INSOM_Nammyb = INSOM_Nammyb + INSOM_Namm * maxt
         !Total Nmin immobilization (to litter and SOM):
            ONmin_immyb = ONmin_immyb + ONmin_imm * maxt

         !System:
            ICsysyb = ICsysyb + ICsys * maxt   !C input to system.
               !Note that ICsys = Pcan + ICimm_alaa_m2 
            ICimm_alaa_m2yb = ICimm_alaa_m2yb + ICimm_alaa_m2 * maxt 
               !C input alate aphid immigration.
            OCsysyb = OCsysyb + OCsys * maxt   !C output from system.
            DCsysyb = DCsysyb + DCsys * maxt   !Change in system C.
            DCsys_chkyb = DCsys_chkyb + DCsys_chk * maxt !Change in system C.
                                               !kg C m-2 year-1.
            INsysyb = INsysyb + INsys * maxt   !N input to system.
            ONsysyb = ONsysyb + ONsys * maxt   !N output from system.
            DNsysyb = DNsysyb + DNsys * maxt   !Change in system N.
            DNsys_chkyb = DNsys_chkyb + DNsys_chk * maxt !Change in system N.
                                               !kg N m-2 year-1.
                                                         !Squared values of
            INsys2yb = INsys2yb + INsys * INsys * maxt   !N input to system,
            ONsys2yb = ONsys2yb + ONsys * ONsys * maxt   !N output from system.


         !Litter and soil:

            DNsoilyb = DNsoilyb + DNsoil * maxt           !kg N m-2 year-1.
            DWsoilyb = DWsoilyb + DWsoil * maxt           !kg W m-2 year-1.

            ICsoilyb = ICsoilyb + ICsoil * maxt           !kg C m-2 year-1.
            INsoilyb = INsoilyb + INsoil * maxt           !kg N m-2 year-1.
            IWsoilyb = IWsoilyb + IWsoil * maxt           !kg W m-2 year-1.

            OCsoilyb = OCsoilyb + OCsoil * maxt           !kg C m-2 year-1.
            ONsoilyb = ONsoilyb + ONsoil * maxt           !kg N m-2 year-1.
            OWsoilyb = OWsoilyb + OWsoil * maxt           !kg W m-2 year-1.

            !C output to leaching:
               OCsol_lchyb = OCsol_lchyb + OCsol_lch * maxt !kg C m-2 year-1.

            !Total soil + litter respiration:
               Rsoilyb = Rsoilyb + Rsoil * maxt           !kg C m-2 year-1.
               
            !Litter outputs:
            !The kXle...  are annual averages (not sums)
            kXle_liyb =   kXle_liyb +  kXle_li *  maxtyear
            kXle1_2yb =   kXle1_2yb +  kXle1_2 *  maxtyear
            kXle2_3yb =   kXle2_3yb +  kXle2_3 *  maxtyear
            kXle3_4yb =   kXle3_4yb +  kXle3_4 *  maxtyear
            kXle4_liyb =  kXle4_liyb + kXle4_li * maxtyear
            OXle4_liyb = OXle4_liyb + OXle4_li * maxt
            OXbr_liyb =  OXbr_liyb +  OXbr_li  * maxt
            OXst_liyb =  OXst_liyb +  OXst_li  * maxt

            !C, N total inputs to surface and soil litter pools:
            ICsurf_liyb = ICsurf_liyb + ICsurf_li * maxt
            INsurf_liyb = INsurf_liyb + INsurf_li * maxt
            ICsoil_liyb = ICsoil_liyb + ICsoil_li * maxt
            INsoil_liyb = INsoil_liyb + INsoil_li * maxt
                                                           !kg C, N m-2 y-1.
           !Components of ICsurf_li (kg C, N m-2 y-1):
            ICsurf_li_metyb = ICsurf_li_metyb + ICsurf_li_met * maxt
            ICsurf_li_celyb = ICsurf_li_celyb + ICsurf_li_cel * maxt
            ICsurf_li_ligyb = ICsurf_li_ligyb + ICsurf_li_lig * maxt
            ICtree_surf_liyb = ICtree_surf_liyb + ICtree_surf_li * maxt
            ICaph_surf_li_metyb = ICaph_surf_li_metyb + &
                                           ICaph_surf_li_met * maxt
            ICaph_surf_liyb = ICaph_surf_liyb + ICaph_surf_liyb * maxt
           !Components of INsurf_li:
            INtree_surf_liyb = INtree_surf_liyb + INtree_surf_liyb * maxt
            INaph_surf_liyb = INaph_surf_liyb + INaph_surf_liyb * maxt
           !Components of ICsoil_li:
            ICSsoil_liyb = ICSsoil_liyb + ICSsoil_li * maxt
            ICXsoil_liyb = ICXsoil_liyb + ICXsoil_li * maxt
           !Components of INsoil_li:
            INSsoil_liyb = INSsoil_liyb + INSsoil_li * maxt
            INXsoil_liyb = INXsoil_liyb + INXsoil_li * maxt
           !Net SOM mineralization flux (INSOM_Namm - ONmin_imm (total):
            netSOM_minfluxyb = netSOM_minfluxyb + netSOM_minflux * maxt
            !Total output of tree structural N towards litter:
               ONtreeX_gndyb = ONtreeX_gndyb + ONtreeX_gnd * maxt 
                                         !kg XN m-2 year-1.
            !Total input to tree N substrate pools of recycled N from
            !ONtreeX_gnd above:
               INtreeS_gndyb = INtreeS_gndyb + INtreeS_gnd * maxt
                                         !kg XN m-2 year-1.
            !Total input to Namm pool:
               INammyb = INammyb + INamm * maxt
            !Exudation from fine roots to Namm pool:
               INfi_Nammyb = INfi_Nammyb + INfi_Namm * maxt
            !Soil bugs death flux to Namm pool:
               INbio_Nammyb = INbio_Nammyb + INbio_Namm * maxt
            !N input, environment to soil ammonium pool:
               INenv_Nammyb = INenv_Nammyb + INenv_Namm * maxt
            !N input, environment to soil nitrate pool:
               INenv_Nnityb = INenv_Nnityb + INenv_Nnit * maxt
            !Fertilizer inputs:
               zNfert_Nminyb = zNfert_Nminyb + zNfert_Nmin * maxt
               INfert_Nammyb = INfert_Nammyb + INfert_Namm * maxt
               INfert_Nnityb = INfert_Nnityb + INfert_Nnit * maxt
            !N input, non-symbiotic N fixation to soil ammonium pool:
               INfix_Nammyb = INfix_Nammyb + INfix_Namm * maxt
            !N uptake by trees:
               ONsoil_fiyb = ONsoil_fiyb + ONsoil_fi * maxt !kg N m-2 year-1.
            !N output to leaching:
               ONnit_lchyb = ONnit_lchyb + ONnit_lch * maxt !kg N m-2 year-1.
            !N output to volatilization:
               ONamm_volyb = ONamm_volyb + ONamm_vol * maxt !kg N m-2 year-1.
            !Nitrification output from Namm towards Nnit:        !jt     
               ONamm_nityb = ONamm_nityb + ONamm_nit * maxt!kg N m-2 year-1.jt
            !N output to nitrification losses to the environment:  jt
               ONamm_nitrif_envyb = ONamm_nitrif_envyb &
                                  + ONamm_nitrif_env * maxt !kg N m-2 year-1.
            !N output to denitrification:
               ONnit_denityb = ONnit_denityb + ONnit_denit * maxt
                                                            !kg N m-2 year-1.
         !Soil microbes pool, Cbio:
            
         !sSOM pool:
             DCsSOMyb =      DCsSOMyb      + maxt * DCsSOM      !kg C m-2 y-1.
             ICsSOMyb =      ICsSOMyb      + maxt * ICsSOM      !kg C m-2 y-1.
             ICuSOM_sSOMyb = ICuSOM_sSOMyb + maxt * ICuSOM_sSOM
             ICpSOM_sSOMyb = ICpSOM_sSOMyb + maxt * ICpSOM_sSOM
             OCsSOM_minyb =  OCsSOM_minyb  + maxt * OCsSOM_min
             INsSOMyb =      INsSOMyb      + maxt * INsSOM      !kg N m-2 y-1.
             ONsSOM_Nammyb = ONsSOM_Nammyb + maxt * ONsSOM_Namm
             rCNsSOMnyb =    rCNsSOMnyb    + maxt * rCNsSOMn !C:N ratio in
                                                             !new sSOM.

         !Tree:
            !All averages, e.g. LAIya, have the same units as LAI etc.

            IF ( daybeg ) THEN !Yearly averages of daily quantities.
               yrch_15hyb = yrch_15hyb + 1.0

               fWph_15hyb = fWph_15hyb + fWph_15h
               fgstom_Pmax_15hyb = fgstom_Pmax_15hyb + fgstom_Pmax_15h
               fbshrsyb = fbshrsyb + fbshrs * oneOVER365 !Fraction of bright
                                     !sunshine hours - varies daily.

               !Phenology:
               dormantyb = dormantyb + dormant
                                              !Count number of dormant days.
               budburstyb = budburstyb + budburst 
                                              !Count number of budburst days.
               budsopeningyb = budsopeningyb + budsopening 
                                 !Count number of days when buds are opening.
               s_leafyb = s_leafyb + s_leaf !Count number of days when leaf 
                          !activity is switched on (days in each year).
               leaf_fallyb = leaf_fallyb + leaf_fall !Count number of days
                                !when leaf fall occurs (days in each year).
            ENDIF


           !Aphid:
            aphyb = aphyb + aph * maxtyear      !Aphid numbers / stem.
            Axxayb = Axxayb + Axxa * maxtyear   !Adult aphids stem-1.
            alaayb = alaayb + alaa * maxtyear !Adult alate aphids stem-1.
            aptayb = aptayb + apta * maxtyear !Adult apterous aphids stem-1.
            alayb = alayb + ala * maxtyear   !Alate aphids stem-1.
            aptyb = aptyb + apt * maxtyear   !Apterous aphids stem-1.
            roaphyb = roaphyb + roaph * maxtyear
               !Aphid numbers / m2 leaf (ages 2,3 & 4), averaged over 1 y.
            !Survival = kapt1_2 / ( kapt1_2 + kaph_mort ). Instantaneous value.
            survivalyb = survivalyb + survival * maxtyear 
               !Fraction of survivors, averaged over 1 y.
            kapt1_2yb = kapt1_2yb + kapt1_2 * maxt !y-1. Development rate
                  !of 1st apterous instar, accumulated over 1 y.
            kaph_mortyb = kaph_mortyb + kaph_mort * maxt !y-1. Mortality rate
                  !accumulated over 1 y.

            Daphyb = Daphyb + Daph * maxt !aphids stem-1 y-1.
            OCaph_mort_m2yb = OCaph_mort_m2yb + OCaph_mort_m2 * maxt
            ONaph_mort_m2yb = ONaph_mort_m2yb + ONaph_mort_m2 * maxt
              !kg C, N from aphid mortality to surface litter (m2 gnd)-1 y-1.

            Oaph_mortyb = Oaph_mortyb + Oaph_mort * maxt  !aphids stem-1 y-1.
            Oalaa_emiyb = Oalaa_emiyb + Oalaa_emi * maxt  !aphids stem-1 y-1. 
            Oalaa_mortyb = Oalaa_mortyb + Oalaa_mort * maxt  
               !aphids stem-1 y-1. 
            Oalaa_mortemiyb = Oalaa_mortemiyb + Oalaa_mortemi * maxt  
                !aphids stem-1 y-1. 
            Oaph_mortemiyb = Oaph_mortemiyb + Oaph_mortemi * maxt 
                !aphids stem-1 y-1. 

            !On a ground area basis  (eg Oalaa_emi_m2 = nstems * Oalaa_emi):
               Oalaa_emi_m2yb = Oalaa_emi_m2yb + Oalaa_emi_m2 * maxt 
                                                        !aphids m-2 y-1.
               OCalaa_emi_m2yb = OCalaa_emi_m2yb + OCalaa_emi_m2 * maxt 
                                                       !kg C m-2 y-1.
               ONalaa_emi_m2yb = ONalaa_emi_m2yb + ONalaa_emi_m2 * maxt 
                                                       !kg N m-2 y-1.

            Oaxxa_axx1yb = Oaxxa_axx1yb + Oaxxa_axx1 * maxt 
            Oalaa_axx1yb = Oalaa_axx1yb + Oalaa_axx1 * maxt 
            Oapta_axx1yb = Oapta_axx1yb + Oapta_axx1 * maxt 
               !1st instar aphids (alates + atperous) stem-1 y-1. 

            kaph_mortyb =      kaph_mortyb +     kaph_mort *  maxtyear !day-1.
!           kaph_mort1yb =     kaph_mort1yb +    kaph_mort1 * maxtyear !day-1.
!Bug. If this ! is removed, and the corresponding one above 
!(search up for "!Bug"), compilation fails, for no obvious reason.

            kaph_Tmortyb = kaph_Tmortyb &
                                           + kaph_Tmort * maxtyear !day-1.
            kaph_Nmortyb = kaph_Nmortyb + kaph_Nmort * maxtyear     !day-1. 

            ICphloem_aphyb = ICphloem_aphyb + ICphloem_aph * maxt
            INphloem_aphyb = INphloem_aphyb + INphloem_aph * maxt

            ICphloem_aph_m2yb = ICphloem_aph_m2yb + ICphloem_aph_m2 * maxt
            INphloem_aph_m2yb = INphloem_aph_m2yb + INphloem_aph_m2 * maxt

            INphloem_aptayb = INphloem_aptayb + INphloem_apta * maxt
            INphloem_alaayb = INphloem_alaayb + INphloem_alaa * maxt
               !kg N substrate taken in from the phloem by 
               !apterous/alate adult aphids stem-1 y-1.

            INphloem_apta_aphidyb = INphloem_apta_aphidyb + &
                                    INphloem_apta_aphid * maxt
                !kg N ingested from phloem per apterous adult aphid year-1.
            INphloem_alaa_aphidyb = INphloem_alaa_aphidyb + &
                                    INphloem_alaa_aphid * maxt
                !kg N ingested from phloem per alate adult aphid year-1.


            !Tree structural DM components (kg XDM stem-1):
            MXtreeyb = MXtreeyb +  MXtree * maxtyear  !Total tree X.
            MCStreeyb = MCStreeyb +  MCStree * maxtyear  !Total tree CS.
            MCstorestyb = MCstorestyb +  MCstorest * maxtyear 
                                !Tree C store associated with the stem.
            Mbudyb = Mbudyb +      Mbud * maxtyear    !Total bud X.
            MXleyb = MXleyb +      MXle * maxtyear    !Leaf X.
            MXbryb = MXbryb +      MXbr * maxtyear !Branch X.
            MXbrmyb = MXbrmyb +      MXbrm * maxtyear !Branch meristem X.
            MXstyb = MXstyb +      MXst * maxtyear !Stem X.
            MXstmyb = MXstmyb +      MXstm * maxtyear !Stem meristem X.
            Mstyb = Mstyb +        Mst * maxtyear !Stem total DM (kg stem-1).
            Mst_gndyb = Mst_gndyb + Mst_gnd * maxtyear !Stem total DM m-2.
            MXcoyb = MXcoyb +      MXco * maxtyear !Coarse root X.
            MXcomyb = MXcomyb +      MXcom * maxtyear !Coarse root metistem X.
            MXfiyb = MXfiyb +      MXfi * maxtyear !Fine root X.
            MXfimyb = MXfimyb +      MXfim * maxtyear !fine root meristem X.

            Mleyb = Mleyb +        Mle * maxtyear !Total foliage mass.
                                                  !kg DM stem-1.
            MXle1yb = MXle1yb +    MXle1 * maxtyear !Foliage kg XDM stem-1.
            MXle2yb = MXle2yb +    MXle2 * maxtyear !Foliage kg XDM stem-1.
            MXle3yb = MXle3yb +    MXle3 * maxtyear !Foliage kg XDM stem-1.
            MXle4yb = MXle4yb +    MXle4 * maxtyear !Foliage kg XDM stem-1.

            LAIyb = LAIyb +      LAI * maxtyear !Leaf area index.
            Mtreeyb = Mtreeyb + Mtree * maxtyear !Mtree is tree mass.
                                    !kg DM structure and storage per stem.

            Aleafyb = Aleafyb +  Aleaf * maxtyear !Leaf area = Aleaf1 + Aleaf2
                                               ! + Aleaf3 + Aleaf4 !m2 stem-1.
            Aleaf_aphyb = Aleaf_aphyb + Aleaf_aph * maxtyear !Leaf area 
                   !colonizable by aphids: Aleaf2 + Aleaf3 + Aleaf4 m2 stem.
            LAIs_leafyb = LAIs_leafyb + LAIs_leaf * maxtyear !Leaf area
            Aleafs_leafyb = Aleafs_leafyb + Aleafs_leaf * maxtyear !Leaf area
                         !Average just for the period when leaves are present.
            hstemyb = hstemyb + hstem * maxtyear    !Stem height (m).
            SLAyb = SLAyb +      SLA * maxtyear !Specific leaf area.
            SLAs_leafyb = SLAs_leafyb + SLAs_leaf * maxtyear !specific leaf
                          !area just for the period when leaves are present.
            rCNleyb = rCNleyb + rCNle * maxtyear !Ratio C:N substrates in leaf.
            rCNles_leafyb = rCNles_leafyb + rCNles_leaf * maxtyear 
                      !Ratio C:N substrates in leaf.
                      !just for the period when leaves are present (s_leaf=1).

            fSLA_rCNyb = fSLA_rCNyb + fSLA_rCN * maxtyear 
                              !SLA function depending on substrate C:N ratio.
            fSLA_Cyb = fSLA_Cyb + fSLA_C * maxtyear 
                              !SLA function depending on substrate C.
            fSLA_CMMyb = fSLA_CMMyb + fSLA_CMM * maxtyear 
                              !SLA function depending on substrate C, but
                              !Michaelis-Menten-like.
            fSLA_Wyb = fSLA_Wyb + fSLA_W * maxtyear 
                              !SLA function depending on foliage water.

            Cleyb = Cleyb +      Cle * maxtyear !Foliage substrate C concn.
            Cbryb = Cbryb +      Cbr * maxtyear !Branch substrate C concn.
            Cstyb = Cstyb +      Cst * maxtyear !Stem substrate C (SC) concn.
            Ccoyb = Ccoyb +      Cco * maxtyear !Coarse roots SC concn.
            Cfiyb = Cfiyb +      Cfi * maxtyear !Fine roots substrate C concn.
               !kg SC (kg XDM)-1.  Meristem + structure XDM for le, fi.
               !kg SC (kg XDM)-1.  Meristem XDM alone for br, st, co fi.
            Nleyb = Nleyb +      Nle * maxtyear !Foliage substrate N concn.
            Nbryb = Nbryb +      Nbr * maxtyear !Branch substrate N concn.
            Nstyb = Nstyb +      Nst * maxtyear !Stem substrate N (SN) concn.
            Ncoyb = Ncoyb +      Nco * maxtyear !Coarse roots SN concn.
            Nfiyb = Nfiyb +      Nfi * maxtyear !Fine rt NS concn.
               !kg SN (kg XDM)-1.  Meristem + structure XDM for le, fi.
               !kg SN (kg XDM)-1.  Meristem XDM alone for br, st, co fi.
            Cphloemyb = Cphloemyb + Cphloem * maxtyear !Phloem CS concn.
            Nphloemyb = Nphloemyb + Nphloem * maxtyear !phloem NS concn.
                        !kg CS, NS per m3 sap.               
            rCNphloemyb = rCNphloemyb + rCNphloem * maxtyear !phloem C:N
                        !ratio. kg CS (kg NS)-1.
            Cletotyb = Cletotyb +   Cletot * maxtyear !Foliage total C concn.
                                                 !kg total C (kg total DM)-1.
            CSletotyb = CSletotyb +   CSletot * maxtyear !Foliage C
                         !substrate concn. !kg C substrate (kg total DM)-1.
            CXletotyb = CXletotyb +   CXletot * maxtyear !Foliage C
                         !structure concn. kg CX (kg total DM)-1.
            NXleyb = NXleyb +   NXle * maxtyear            !Foliage NX concn.
                   !kg meristem NX + non-meristem NX (kg total foliage CX)-1.
            NXfiyb = NXfiyb +   NXfi * maxtyear          !Fine root NX concn.
                   !kg meristem NX + non-meristem NX (kg total foliage CX)-1.
            Nphyb = Nphyb + Nph * maxtyear  !Photosynthetic N concn.
               !kg foliage phN (kg total foliage NX)-1 in canopy upper layer.
            MNphyb = MNphyb +  MNph * maxtyear    !Photosynthetic N,
                          !amount, upper layer, kg foliage photossynthetic N.
            MNSleyb = MNSleyb +  MNSle * maxtyear    !Foliage N substrate,
                          !kg foliage substrate N stem-1.
            MCSleyb = MCSleyb +  MCSle * maxtyear    !Foliage C substrate,
                          !kg foliage substrate C stem-1.
            Nph_Ayb = Nph_Ayb   + Nph_A * maxtyear   !kg phN(ul) m2.
                                  !Photosynthetic N in upper layer of canopy.
            Nletotyb = Nletotyb + Nletot * maxtyear   !Foliage total N concn.
                                              !kg N (kg total foliage DM)-1.
            NSletotyb = NSletotyb + NSletot * maxtyear  !Foliage N substrate
                                       !concn. kg NS (kg total foliage DM)-1.
            Nphtotyb = Nphtotyb + Nphtot * maxtyear   !Foliage photosynthetic
                                    !N concn. kg phN (kg total foliage DM)-1.
            NXletotyb = NXletotyb + NXletot * maxtyear !Foliage structural
                           !N concn. kg structural N (kg total foliage DM)-1.
            Nletot_Xyb = Nletot_Xyb + Nletot_X * maxtyear
                                                 !kg total N (kg XDM)-1 m-2.
                   !Foliage total N concentration per structural dry mass.
            Nletot_Ayb = Nletot_Ayb + Nletot_A * maxtyear    !kg total N m-2.
                                !Foliage total N concentration per unit area.
            CNleyb = CNleyb +  CNle * maxtyear !Foliage substrate CN product.
            CNbryb = CNbryb +  CNbr * maxtyear !Branches substrate CN product.
            CNstyb = CNstyb +  CNst * maxtyear !Stem substrate CN product.
            CNcoyb = CNcoyb +  CNco * maxtyear !Coarse rts sub. CN product.
            CNfiyb = CNfiyb +  CNfi * maxtyear !Fine rt substrate CN product.
            CStreeyb = CStreeyb + CStree * maxtyear !C substrate 
                                                !concentration in tree.
            rCNStreeyb = rCNStreeyb + rCNStree * maxtyear 
               !Ratio of tree C:N substrates.
            rCNStrees_leafyb = rCNStrees_leafyb + rCNStrees_leaf * maxtyear
               !Ratio of tree C:N substrates just for the period when
               !leaves are present.

            NStreeyb = NStreeyb + NStree * maxtyear !N substrate 
                                                !concentration in tree.
            psiPleyb = psiPleyb + psiPle * maxtyear !Foliage pressure
                                                    !potential.
            psiPleqyb = psiPleqyb + psiPleq * maxtyear !Foliage pressure
                                                !potential to power q.
            psiPfiyb = psiPfiyb + psiPfi * maxtyear !Fine root pressure
                                                    !potential.
            rpsiPle_fiyb = rpsiPle_fiyb + rpsiPle_fi * maxtyear !Ratio of
                           !foliage turgor pressure to fine root pressure.
            thetaleyb = thetaleyb + thetale * maxtyear
                                       !Foliage relative water content.

            CNtreeyb = CNtreeyb + CNtree * maxtyear  !C substrate concn * 
                      !N substrate concn.  Average for tree.
           !Components of CNtree = ...
            zCNleyb = zCNleyb + zCNle * maxtyear 
            zCNbryb = zCNbryb + zCNbr * maxtyear 
            zCNstyb = zCNstyb + zCNst * maxtyear
            zCNcoyb = zCNcoyb + zCNco * maxtyear 
            zCNfiyy = zCNfiyb + zCNfi * maxtyear 

            CNtreefTshyb = CNtreefTshyb + CNtree * fTsh * maxtyear
                      !As above, weighted for shoot temperature function.
         !Fractions of structural C and N recycled:
            fCXle_recyb = fCXle_recyb + fCXle_rec * maxtyear
            fNXle_recyb = fNXle_recyb + fNXle_rec * maxtyear
            fCXbr_recyb = fCXbr_recyb + fCXbr_rec * maxtyear
            fNXbr_recyb = fNXbr_recyb + fNXbr_rec * maxtyear
            fCXco_recyb = fCXco_recyb + fCXco_rec * maxtyear
            fNXco_recyb = fNXco_recyb + fNXco_rec * maxtyear
            fCXfi_recyb = fCXfi_recyb + fCXfi_rec * maxtyear
            fNXfi_recyb = fNXfi_recyb + fNXfi_rec * maxtyear
         !Average value of substrate-dependent Michaelis-Menten
         !maintenance factor:
            fCSmai_treeyb = fCSmai_treeyb + fCSmai_tree * maxtyear
         !N contributing to maintenance respiration:
   !JHMT 17/8/00.  Bug was in next line.
            Ntree_mai_gndyb = Ntree_mai_gndyb + Ntree_mai_gnd * maxtyear
                                                               !kg N m-2.

            rshrtyb = rshrtyb + rshrt * maxtyear   !Shoot root ratio.
            rlefiyb = rlefiyb + rlefi * maxtyear   !Foliage fine root ratio.
            rlefiGXyb = rlefiGXyb + rlefiGX * maxtyear   !Foliage fine root
                            !structural growth ratio.


            IXfimyb = IXfimyb + IXfim * maxt !(kg meristem XDM stem-1 day-1).
                                             !Fine root meristem growth rate.

            fWleyb = fWleyb + fWle * maxtyear        !Foliage water function.

         !Stem numbers:
            nstemsyb = nstemsyb + nstems * maxtyear !Stems per m2 ground.
            Instemsyb = Instemsyb + Instems * maxt           !stems year-1.
            Onstemsyb = Onstemsyb + Onstems * maxt           !stems year-1.
         !Fractional rates of birth, death, growth (net) of nstems from
         !self_thinning:
            FBRnstemsyb = FBRnstemsyb + FBRnstems * maxt  !year-1.
            FDRnstemsyb = FDRnstemsyb + FDRnstems * maxt  !year-1.
            z1_FDRnstemsyb = z1_FDRnstemsyb + z1_FDRnstems * maxt  !year-1.
            z2_FDRnstemsyb = z2_FDRnstemsyb + z2_FDRnstems * maxt  !year-1.
            FGRnstems_snyb = FGRnstems_snyb + FGRnstems_sn * maxt  !year-1.
         !Inputs and outputs to nstems from self_thinning:
            Instems_snyb = Instems_snyb + Instems_sn * maxt !# stems year-1.
            Onstems_snyb = Onstems_snyb + Onstems_sn * maxt !# stems year-1.
         !Fractional growth rate (net) of nstems from all causes:
            FGRnstemsyb = FGRnstemsyb + FGRnstems * maxt    !year-1.

         !Fractional mortality, mortality + emigration, fecundity rates.
            !fmort, fmortemi, ffecaxxa all have units of d-1.
            !We use maxtyear (y) rather than maxt (d) to give averages rather
            !then accumulation over the year. See "maxtyear = " above.
               fmortyb = fmortyb + fmort * maxtyear
               fmortemiyb = fmortemiyb + fmortemi * maxtyear
               !ffecaxxayb = ffecaxxayb + ffecaxxa * maxtyear !Not used.
                   !See ffecaxxaya

            Onstems_thyb = Onstems_thyb + Onstems_th * maxt  !stems year-1.
            Onstems_fireyb = Onstems_fireyb + Onstems_fire * maxt
                                                             !stems year-1.

         !C flux from tree to litter + soil (= litter + exudation fluxes):
            ICtree_soilyb = ICtree_soilyb + ICtree_soil * maxt 
                                                          !kg C m-2 year-1.

         !N flux from tree to litter + soil (= litter + exudation fluxes):
            INtree_soilyb = INtree_soilyb + INtree_soil * maxt 
         !N flux from environment to litter + soil 
               !(= litter + exudation fluxes):
            INenv_soilyb = INenv_soilyb + INenv_soil * maxt 
                                                          !kg N m-2 year-1.


         !Soil microbes pool, Cbio:
            DCbioyb = DCbioyb + DCbio * maxt 
                           !Rate of change of soil biomass. kg C m-2 y-1.
            Cbioyb = Cbioyb +   Cbio * maxtyear !Soil biomass.
            Gbioyb = Gbioyb + Gbio * maxt 
                           !Growth rate of soil biomass. kg C m-2 y-1.
            Dbioyb = Dbioyb + Dbio * maxt 
                           !Death rate of soil biomass.  kg C m-2 y-1.
            fCNbioyb = fCNbioyb +   fCNbio  * maxtyear !Effects of Csol, Nmin,
            fbiomaxyb = fbiomaxyb + fbiomax * maxtyear !CSOM on biomass growth.
            fbiominyb = fbiominyb + fbiomin * maxtyear !Effect of Cbio on
                                           !biomass death rate.
         !Soil:
            Csolyb = Csolyb +   Csol * maxtyear !Soil soluble C. 
            Neff_uNyb = Neff_uNyb +   Neff_uN * maxtyear !Effective soil 
                                                !mineral N for N uptake.
            Neff_bioyb = Neff_bioyb +   Neff_bio * maxtyear !Effective soil 
                                !mineral N for biomass growth and N fixation.
            Nammyb = Nammyb +   Namm * maxtyear !Soil ammonium N. 
            Nnityb = Nnityb +   Nnit * maxtyear !Soil nitrate N.

         !System (all kg C, N m-2):
            Csysyb = Csysyb + Csys  * maxtyear  !System C (total).
            Ctreeyb = Ctreeyb + Ctree  * maxtyear  !Tree C.
            Csoilyb = Csoilyb + Csoil  * maxtyear  !Soil C.
            Clitteryb = Clitteryb + Clitter  * maxtyear  !Litter C (total).
           !Surface litter C:
            Csurf_li_metyb = Csurf_li_metyb + Csurf_li_met  * maxtyear !met.
            Csurf_li_celyb = Csurf_li_celyb + Csurf_li_cel  * maxtyear !cel.
            Csurf_li_ligyb = Csurf_li_ligyb + Csurf_li_lig  * maxtyear !lig.
            Csurf_liyb = Csurf_liyb + Csurf_li  * maxtyear  !Surface litter C.
            Csoil_liyb = Csoil_liyb + Csoil_li  * maxtyear  !Soil litter C.
            CSOMyb = CSOMyb + CSOM  * maxtyear  !SOM C (total).
            CuSOMyb = CuSOMyb + CuSOM  * maxtyear  !Unprotected SOM C.
            CpSOMyb = CpSOMyb + CpSOM  * maxtyear  !Protected SOM C.
            CsSOMyb = CsSOMyb + CsSOM  * maxtyear  !Stabilized SOM C.
            Cptrdyb = Cptrdyb + Cptrd  * maxtyear  !ptrd C = C in products of
                                            !thinning and rotation, decaying.

            Nsysyb = Nsysyb + Nsys  * maxtyear  !System N (total).  
            Ntreeyb = Ntreeyb + Ntree  * maxtyear  !Tree N.
            Nsoilyb = Nsoilyb + Nsoil  * maxtyear  !Soil N.
            Nlitteryb = Nlitteryb + Nlitter  * maxtyear  !Litter N (total).
            Nsurf_liyb = Nsurf_liyb + Nsurf_li  * maxtyear  !Surface litter N.
            Nsoil_liyb = Nsoil_liyb + Nsoil_li  * maxtyear  !Soil litter N.
            NSOMyb = NSOMyb + NSOM  * maxtyear  !SOM N (total).
            Nptrdyb = Nptrdyb + Nptrd  * maxtyear  !ptrd N = N in products of
                                            !thinning and rotation, decaying.
                 
         !Water fluxes, rainfall, and output fluxes (!kg water m-2 year-1):
!           rainyb =         rainyb +         rain * maxt  See above.
            OWsysyb =        OWsysyb +        OWsys * maxt
            OWrain_intyb =   OWrain_intyb +   OWrain_int * maxt       
            OWle_atm_gndyb = OWle_atm_gndyb + OWle_atm_gnd * maxt 
            OWle_rad_gndyb = OWle_rad_gndyb + OWle_rad_gnd * maxt
            OWle_vdg_gndyb = OWle_vdg_gndyb + OWle_vdg_gnd * maxt
            OWso_atmyb =     OWso_atmyb +     OWso_atm * maxt             
            OWprdyb =    OWprdyb +    OWprd * maxt             
            OWso_drainyb =   OWso_drainyb +   OWso_drain * maxt

         !Products:
            IVptyb = IVptyb + IVpt * maxt  !m3 wood (m2 ground)-1 year-1.
                                           !Input, volume, from products of
                                           !thinning.
            !N fluxes (kg N m-2 year-1):
            INth_pryb = INth_pryb + INth_pr * maxt
                                            !N input, thinning, to products.
            !Outputs of C, N from decaying product pools to environment:
            OCprdyb = OCprdyb + OCprd * maxt
            ONprdyb = ONprdyb + ONprd * maxt
            !Input to products from pruning (kg C m-2 year-1)
            ICprune_prodyb = ICprune_prodyb + ICprune_prod * maxt
            
   ENDIF  !End of procedure for calculating YEARLY AVERAGES


!AVERAGES OVER THE SIMULATION, i.e. t = 0 to tstop or termt .EQ. true.

   !Tree:
       Int_LAI =          INTEG( LAI, Int_LAI0 )
       Int_SLA =          INTEG( SLA, Int_SLA0 )
       Int_Cle =          INTEG( Cle, Int_Cle0 )
       Int_Nle =          INTEG( Nle, Int_Nle0 )
       Int_Cphloem =      INTEG( Cphloem, Int_Cphloem0 )
       Int_Nphloem =      INTEG( Nphloem, Int_Nphloem0 )
       Int_Cfi =          INTEG( Cfi, Int_Cfi0 )
       Int_Nfi =          INTEG( Nfi, Int_Nfi0 )
       Int_Nph =          INTEG( Nph, Int_Nph0 )
       Int_Nph_A =        INTEG( Nph_A, Int_Nph_A0 )
       Int_fjPAR_Nph =    INTEG( fjPAR_Nph, Int_fjPAR_Nph0 )
       Int_fNSle_Nph =    INTEG( fNSle_Nph, Int_fNSle_Nph0 )
       Int_rCNle =        INTEG( rCNle, Int_rCNle0 )
       Int_rCNfi =        INTEG( rCNfi, Int_rCNfi0 )
       Int_CStree =       INTEG( CStree, Int_CStree0 )
       Int_NStree =       INTEG( NStree, Int_NStree0 )
       Int_Nletot =       INTEG( Nletot, Int_Nletot0 )
       Int_Nletot_A =     INTEG( Nletot_A, Int_Nletot_A0 )
       Int_Ctree =        INTEG( Ctree, Int_Ctree0 )
       Int_Ntree =        INTEG( Ntree, Int_Ntree0 )
       Int_fCSmai_tree =  INTEG( fCSmai_tree, Int_fCSmai_tree0 )
       Int_PXDMbrm_gnd =      INTEG( PXDMbrm_gnd, Int_PXDMbrm_gnd0 )
       Int_PXDMbud_gnd =      INTEG( PXDMbud_gnd, Int_PXDMbud_gnd0 )
       Int_PXDMstm_gnd =      INTEG( PXDMstm_gnd, Int_PXDMstm_gnd0 )
       Int_PXDMcom_gnd =      INTEG( PXDMcom_gnd, Int_PXDMcom_gnd0 )
       Int_PXDMfim_gnd =      INTEG( PXDMfim_gnd, Int_PXDMfim_gnd0 )
       Int_Onstems_fire =     INTEG( Onstems_fire, Int_Onstems_fire0 )
   !Products:
       Int_Cptrd =        INTEG( Cptrd, Int_Cptrd0 )
       Int_Nptrd =        INTEG( Nptrd, Int_Nptrd0 )
    !Soil, litter:
       Int_Namm =         INTEG( Namm, Int_Namm0 )
       Int_Nnit =         INTEG( Nnit, Int_Nnit0 )
       Int_Cbio =         INTEG( Cbio, Int_Cbio0 )
       Int_Csol =         INTEG( Csol, Int_Csol0 )
       Int_Csurf_li =     INTEG( Csurf_li, Int_Csurf_li0 )
       Int_Csoil_li =     INTEG( Csoil_li, Int_Csoil_li0 )
       Int_Nsurf_li =     INTEG( Nsurf_li, Int_Nsurf_li0 )
       Int_Nsoil_li =     INTEG( Nsoil_li, Int_Nsoil_li0 )
       Int_Clitter =      INTEG( Clitter, Int_Clitter0 )
       Int_Nlitter =      INTEG( Nlitter, Int_Nlitter0 )
       Int_Csoil =        INTEG( Csoil, Int_Csoil0 )
       Int_Nsoil =        INTEG( Nsoil, Int_Nsoil0 )
       Int_CSOM =         INTEG( CSOM, Int_CSOM0 )
       Int_NSOM =         INTEG( NSOM, Int_NSOM0)
       Int_CliSOM =       INTEG( CliSOM, Int_CliSOM0 )
       Int_NliSOM =       INTEG( NliSOM, Int_NliSOM0)
   !Tree and litter:
       Int_Ctreelitter =  INTEG( Ctreelitter, Int_Ctreelitter0 )
       Int_Ntreelitter =  INTEG( Ntreelitter, Int_Ntreelitter0 )
   !Water:
       Int_rMSleWle =     INTEG( rMSleWle, Int_rMSleWle0 )
       Int_psiOle =       INTEG( psiOle, Int_psiOle0 )
       Int_psile =        INTEG( psile, Int_psile0 )
       Int_psiPle =       INTEG( psiPle, Int_psiPle0 )
       Int_thetale =      INTEG( thetale, Int_thetale0 )
       Int_thetasoil =    INTEG( thetasoil, Int_thetasoil0 )
   !System:
       Int_Csys =         INTEG( Csys, Int_Csys0)
       Int_Nsys =         INTEG( Nsys, Int_Nsys0 )

   !Environment fluxes:
       Int_jPARsc =       INTEG( jPARscday, Int_jPARsc0 )
       Int_jPARscabs =    INTEG( jPARscabsday, Int_jPARscabs0 )
                         !Remember, integ integrates with respect to t (day).
   !Carbon fluxes:
       Int_ICsys =        INTEG( ICsys, Int_ICsys0 )
    !As ICsys = Pcan + ICimm_alaa_m2, we also calculate
       Int_ICimm_alaa_m2 = INTEG( ICimm_alaa_m2, Int_ICimm_alaa_m20 )

       Int_OCsys =        INTEG( OCsys, Int_OCsys0 )
       Int_OCprd =        INTEG( OCprd, Int_OCprd0 )
       Int_Pcan =         INTEG( Pcan, Int_Pcan0 )
       Int_Pcan_IP =      INTEG( Pcan_IP, Int_Pcan_IP0 )
       Int_Pnet =         INTEG( Pnet, Int_Pnet0 )
       Int_Pmax20 =       INTEG( Pmax20, Int_Pmax200 )
       Int_Rtree_gnd =    INTEG( Rtree_gnd, Int_Rtree_gnd0 )
       Int_Rtreem_gnd =   INTEG( Rtreem_gnd, Int_Rtreem_gnd0 )
       Int_RtreeG_gnd =   INTEG( RtreeG_gnd, Int_RtreeG_gnd0 )
       Int_Rphloem_loading_gnd = INTEG( Rphloem_loading_gnd, &
                                         Int_Rphloem_loading_gnd0 )
       Int_RNnit_red_tree_gnd = INTEG( RNnit_red_tree_gnd, &
                                        Int_RNnit_red_tree_gnd0 )
       Int_Rmin_upt_gnd = INTEG( Rmin_upt_gnd, Int_Rmin_upt_gnd0 )
       Int_RNmin_upt_gnd = INTEG( RNmin_upt_gnd, Int_RNmin_upt_gnd0 )

       Int_ICsurf_li_Csol = INTEG( ICsurf_li_Csol, Int_ICsurf_li_Csol0 )
       Int_ICsoil_li_Csol = INTEG( ICsoil_li_Csol, Int_ICsoil_li_Csol0 )
       Int_ICfi_Csol =      INTEG( ICfi_Csol, Int_ICfi_Csol0 )
       Int_ICbioD_Csol =    INTEG( ICbioD_Csol, Int_ICbioD_Csol0 )
       Int_ICuSOM_Csol =    INTEG( ICuSOM_Csol, Int_ICuSOM_Csol0 )
       Int_ICpSOM_Csol =    INTEG( ICpSOM_Csol, Int_ICpSOM_Csol0 )
       Int_ICsSOM_Csol =    INTEG( ICsSOM_Csol, Int_ICsSOM_Csol0 )

       Int_OCtree_fire_atm = &
                          integ( OCtree_fire_atm, Int_OCtree_fire_atm0 )
       Int_OCsurf_li_fire_atm = &
                     integ( OCsurf_li_fire_atm, Int_OCsurf_li_fire_atm0 )

       Int_OCsol_bioG =     INTEG( OCsol_bioG, Int_OCsol_bioG0 )
       Int_OCsolR =         INTEG( OCsolR, Int_OCsolR0 )
       Int_OCsol_lch =      INTEG( OCsol_lch, Int_OCsol_lch0 )

       Int_Rsoil =        INTEG( Rsoil, Int_Rsoil0 )
   !Nitrogen fluxes:
       Int_uN_gnd =       INTEG( uN_gnd, Int_uN_gnd0 )
       Int_INSOM_Namm =   INTEG( INSOM_Namm, Int_INSOM_Namm0 )
       Int_INSle_Nph =    INTEG( INSle_Nph, Int_INSle_Nph0 )
       Int_INbud_Nph =    INTEG( INbud_Nph, Int_INbud_Nph0 )
       Int_INsys =        INTEG( INsys, Int_INsys0 )
       Int_INfix_Namm =   INTEG( INfix_Namm, Int_INfix_Namm0 )
       Int_INenv_dep =    INTEG( INenv_dep, Int_INenv_dep0 )
       Int_ONsys =        INTEG( ONsys, Int_ONsys0 )
       Int_ONprd =        INTEG( ONprd, Int_ONprd0 )
       Int_ONsoil_fi =    INTEG( ONsoil_fi, Int_ONsoil_fi0 )
       Int_ONSle_atm_gnd = INTEG( ONSle_atm_gnd, Int_ONSle_atm_gnd0 )
       Int_ONnit_lch =    INTEG( ONnit_lch, Int_ONnit_lch0 )
       Int_ONamm_vol =    INTEG( ONamm_vol, Int_ONamm_vol0 )
       Int_ONamm_nitrif_env = INTEG( ONamm_nitrif_env, &
                                      Int_ONamm_nitrif_env0 )
       Int_ONnit_denit =  INTEG( ONnit_denit, Int_ONnit_denit0 )
       Int_ONamm_nit =    INTEG( ONamm_nit, Int_ONamm_nit0 )
       Int_ONtree_fire_atm = &
                          integ( ONtree_fire_atm, Int_ONtree_fire_atm0 )
       Int_ONsurf_li_fire_atm = &
                       integ( ONsurf_li_fire_atm, Int_ONsurf_li_fire_atm0 )
       Int_ONsoil_env =   integ( ONsoil_env, Int_ONsoil_env0 )
       Int_ONprthd = integ( ONprthd, Int_ONprthd0 )
       Int_ONprrod = integ( ONprrod, Int_ONprrod0 )

   !Water fluxes (kg water m-2 day-1):
       Int_OWrain_int =   INTEG( OWrain_int, Int_OWrain_int0 )
       Int_OWle_atm_gnd = INTEG( OWle_atm_gnd, Int_OWle_atm_gnd0 )
       Int_OWso_atm =     INTEG( OWso_atm, Int_OWso_atm0 )
       Int_OWso_drain =      INTEG( OWso_drain, Int_OWso_drain0 )
       Int_OWprthd =      INTEG( OWprthd, Int_OWprthd0 )
       Int_IWsys =        INTEG( IWsys, Int_IWsys0 )  !Rainfall.
       Int_OWsys =        INTEG( OWsys, Int_OWsys0 )
   !Thinning fluxes:
       Int_OCtree_th =    INTEG( OCtree_th, Int_OCtree_th0 )
       Int_ONtree_th =    INTEG( ONtree_th, Int_ONtree_th0 )
       Int_ICth_pr =  INTEG( ICth_pr, Int_ICth_pr0 )
       Int_INth_pr =  INTEG( INth_pr, Int_INth_pr0 )
       Int_ICth_litter =  INTEG( ICth_litter, Int_ICth_litter0 )
       Int_INth_litter =  INTEG( INth_litter, Int_INth_litter0 )
          Int_ICth_litter_and_pr = Int_ICth_litter + Int_ICth_pr
          Int_INth_litter_and_pr = Int_INth_litter + Int_INth_pr
   !Self-thinning:
       Int_sn_exp =       INTEG( sn_exp, Int_sn_exp0 )
       Int_sn_expMXst =   INTEG( sn_expMXst, Int_sn_expMXst0 )
       Int_sn_expMXtree = INTEG( sn_expMXst, Int_sn_expMXtree0 )

   !Product fluxes:
       Int_IVpt =         INTEG( IVpt,  Int_IVpt0 )

         !Output of debug data every maxt to file, debugdi2.dat,
            !if switched on.
            !Constant debug_di = 0.0, default value.
            IF ( debug_di .EQ. one ) &
                 WRITE ( 64, 631 ) t, year, idaymo, imonth
            631..FORMAT ( 1x, f14.7, 1x, f11.2, 10x, i2, 10x, i2)

   !Tree quantities
      !N substrate concentration in foliage:
         IF ( Aleaf .GT. zero ) Nle_A = MNSle / Aleaf    !kg N substrate m-2.
                                NSle_Ae3 = c1000 * Nle_A  !g N substrate m-2.

      !Branch area index, BAI [m2 (m2 ground)-1]:
         BAI = nstems * Abr   !Branch surface area per unit area ground. 
   
      !Ratio of substrate C to substrate N in stem:
         IF ( Nst .GT. zero ) rCNst = Cst / Nst              !kg C (kg N)-1. 
      !Ratio stem meristem : stem structure:
         IF ( MXst .GT. zero ) rXstmXst = MXstm / MXst
      !Stem area index, SAI [m2 (m2 ground)-1]:
          SAI = nstems * Ast        !Stem surface area per unit area ground.


      !Tree buds + meristem dry matter (kg XDM stem-1):
         MbudXmer = Mbud + MXbrm + MXstm + MXcom + MXfim    !Not used.
      !Tree structural dry matter (non-meristematic) (kg XDM stem-1):
         MXtree_nonm = MXle + MXbr + MXst + MXco + MXfi     !Not used.
      !Tree meristem dry matter (kg mXDM stem-1):
         MXtreem = MXbrm + MXstm + MXcom + MXfim 
      
      !Stem volume per unit ground area:
         Vstem_gnd = Vstem * nstems            !m3 m-2.
      !Stem volume per ha per year (averaged from planting):
            IF ( year .NE. zero ) Vstem_hayr = c10000 * Vstem_gnd / year   
                                   !m3 ha-1 year-1.
      !Mean stem structural DM growth rate
         IF ( year .NE. zero ) MXstyrs = MXst / year  !kg XDM stem-1 year-1.
      
      !Fraction of total structural dry matter in foliage, branches, etc
         IF ( MXtree .GT. zero ) THEN
            fbud = Mbud / MXtree
            fleX = MXle / MXtree;   fbrX = MXbrtot / MXtree
            fstX = MXsttot / MXtree;   fcoX = MXcotot / MXtree
            ffiX = MXfitot / MXtree
         ENDIF

      !Mean C content of tree structure:
         fCtreeX = fleX * fCleX + fbrX * fCbrX + fstX * fCstX &
                  + fcoX * fCcoX + ffiX * fCfiX  !kg C (kg structural DM)-1.
         !This assumes that, in each case (i = le, br, st, co, fi), 
         !meristem and structure have the composition, namely fC??X = fC??m.
   
         IF ( MXstm .GT. zero ) THEN 
            !Leaf area / stem meristem ratio:
               rAleafMXstm = Aleaf / MXstm !m2 leaf (kg stem meristem XDM)-1.
         ENDIF
      !Leaf area ratio = foliage area / total tree mass:
          IF ( Mtree .GT. zero ) LAR = Aleaf / Mtree   !m2 (kg total DM)-1.
      !Leaf area / branch meristem ratio:
         IF ( MXbrm .GT. zero ) rAleafMXbrm = Aleaf / MXbrm 
                               !m2 leaf (kg branch meristem XDM)-1.
      !Leaf area / Stem meristem cross-sectional area:
         IF ( CSAstm .GT. zero ) rAleafCSAstm = Aleaf / CSAstm !Dimensionless.
                                                          !Test of pipe-model?
        
      !C:N ratio in tree:
         IF ( Ntree .GT. zero ) rCNtree = Ctree / Ntree                      
   ! kg C (kg N)-1.

      !Growth rates:
         DMXtree = DMbud + DMXle + DMXbr + DMXst + DMXco + DMXfi
         DMmtree = DMXbrm + DMXstm + DMXcom + DMXfim
         DMCStree = DMCSle + DMCSbr + DMCSst + DMCstorest + DMCSco + DMCSfi
         DMNStree = DMNSle + DMNSbr + DMNSst + DMNSco + DMNSfi
         DMStree = rmmCS12 * DMCStree + rmmNS14 * DMNStree
         DMtree = DMXtree + DMmtree + DMStree
         IF ( Mtree .GT. zero ) sgrMtree = DMtree / Mtree
                                             !Whole-tree specific growth rate.
      !Specific growth rates:
         sgrMXtree = DMXtree / MXtree

      !Fractions growth activity in the different compartments are:
         IF ( PXDMtree .NE. zero ) THEN
            fGleX = PXDMbud / PXDMtree   
            fGbrX = PXDMbrm / PXDMtree
            fGstX = PXDMstm / PXDMtree   
            fGcoX = PXDMcom / PXDMtree
            fGfiX = PXDMfim / PXDMtree
         ENDIF
      
      !Put some quantities on to an annualized basis, tonnes of DM ha-1 yr-1,
            !for the practical chaps.
             znstems3650 = 3650.0 * nstems 
            !3650.0 * nstems converts kg stem-1 day-1 to tonnes ha-1 year-1
         !Annualized growth of gross photosynthesis (put onto a DM basis):
            IF ( fCtreeX .GT. zero ) &
               Ph_tDM_year = znstems3650 * ICph_CSle / fCtreeX
         !Annualized growth rate of foliage structure:
            PXDMbud_tXDM_year = znstems3650 * PXDMbud
         !Annualized growth rate of branch structure:
            PXDMbrm_tons_year = znstems3650 * PXDMbrm
         !Annualized growth rate of stem structure:
            PXDMstm_tons_year = znstems3650 * PXDMstm
         !Annualized growth rate of coarse root structure:
            PXDMcom_tons_year = znstems3650 * PXDMcom
         !Annualized growth rate of fine roots and mycorrhiza structure:
            PXDMfim_tons_year = znstems3650 * PXDMfim
      
      !Rate of N uptake by tree on a ground area basis:
         uN_hayr = c3650000 * uN_gnd       !kg N ha-1 year-1

   IF ( hstem .GT. zero ) log10hstem = LOG10 ( hstem )
   Dhsteme3 = c1000 * Dhstem     !Multiply by 1000 for output.
   Dhsteme6 = c1E6 * Dhstem  !Multiply by 1000000 for output.

   !Turnover rates of water pools:
      IF ( Wfi .GT. zero ) TRWfi = OWfi_Wle  / Wfi  !day-1.
      IF ( Wle .GT. zero ) TRWle = OWle_atm / Wle  !day-1.


!Quantum basis of photosynthesis (P).
   !Quantum efficiency of photosynthesis (initial slope of P:light response):
      alpha_qe = c_qe_ph * alpha               !mol CO2 (mol PAR)-1.
                                               !Current value.
      alphamax15_qe = c_qe_ph * alphamax15     !mol CO2 (mol PAR)-1.
                                               !15 deg C saturating CO2 value.
      Constant c_qe_ph = 0.0494e8  !mol CO2 (kg CO2)-1 J PAR (mol PAR)-1.

   !Light-saturated value of photosynthesis, Pmax_qe6
      Pmax_qe6 = r_MCO2_qCO2 * c1E6 * Pmax          !micromols CO2 m-2 s-1.
      Pmax20_qe6 = r_MCO2_qCO2 * c1E6 * Pmax20      !micromols CO2 m-2 s-1.
                  Constant r_MCO2_qCO2 = 22.72     ! = 1000 g / 44.01 g mol-1.

   !Light incident on canopy:
      qPARsce6 = jPARsc * r_moles_JPAR * c1E6       !micromols PAR m-2 s-1.
                 Constant r_moles_JPAR = 4.598e-6   !moles PAR (J PAR)-1.
                !See Thornley, 1998, Grasslanad Dynamics, p. 217.

   !CO2 concentrations:
      CO2air_mol = CO2air * c1000 / rmmCO2 !mol CO2 m-3.
         Constant rmmCO2 = 44.01

   !Photosynthetic rates:
      PmolCO2sce6 = PCO2sc * c1E6 * r_MCO2_qCO2       !micromoles CO2 m-2 s-1.

   !Efficiency of photosynthesis:
      IF ( qPARsce6 .GT. zero ) THEN
           rPmolqPAR = PmolCO2sce6 / qPARsce6       !mol CO2 (mol PAR)-1.
      ELSE
           rPmolqPAR = 9.9999e20
      ENDIF


!WATER AND LIGHT USE EFFICIENCIES
   !Fluxes over a day:
      OWle_atm_gndmoleda = c1000 * OWle_atm_gndda / rmmW
                                                   !moles water m-2 day-1.
      Pnetmoleda = c1000 * Pnetda / rmmC          !moles carbon m-2 day-1.
         Constant rmmC = 12.011 !Relative molecular mass of carbon (C).
      jPARscmoleda = jPARscda * r_moles_JPAR
                                     !moles incident quanta (PAR) m-2 day-1.
      jPARscabsmoleda = jPARscabsda * r_moles_JPAR
                                     !moles absorbed quanta (PAR) m-2 day-1.

   !Fluxes over a year:
      OWle_atm_gndmoleya = c1000 * OWle_atm_gndya / rmmW
                                                    !moles water m-2 year-1.
      Pnetmoleya = c1000 * Pnetya / rmmC           !moles carbon m-2 year-1.
      jPARscmoleya = jPARscya * r_moles_JPAR
                                     !moles incident quanta (PAR) m-2 year-1.
      jPARscabsmoleya = jPARscabsya * r_moles_JPAR
                                     !moles absorbed quanta (PAR) m-2 year-1.

   !Water use efficiency:
      !Over a day:
         IF ( OWle_atm_gndda .NE. zero ) THEN
            WUEday =  Pnetda / OWle_atm_gndda
                                           !kg C fixed (kg transpired W)-1.
            WUEdaymole = Pnetmoleda / OWle_atm_gndmoleda
                                     !moles C fixed (moles transpired W)-1.
         ELSE
            WUEday = zero; WUEdaymole = zero
         ENDIF
      !Over a year:
         IF ( OWle_atm_gndya .NE. zero ) THEN
            WUEyr = Pnetya / OWle_atm_gndya
                                           !kg C fixed (kg transpired W)-1.
            WUEyrmole = Pnetmoleya / OWle_atm_gndmoleya
                                     !moles C fixed (moles transpired W)-1.
         ELSE
            WUEyr = zero; WUEyrmole = zero
         ENDIF

   !Light use efficiency:
      !Over a day:
         IF ( jPARscabsda .NE. zero ) THEN
            LUEday = Pnetda / jPARscabsda
                                            !kg C fixed (J absorbed PAR)-1.
            LUEdaymole = Pnetmoleda / jPARscabsmoleda
                                      !moles C fixed (moles absorbed PAR)-1.
         ELSE
            LUEday = zero; LUEdaymole = zero
         ENDIF
      !Over a year:
         IF ( jPARscabsya .NE. zero ) THEN
            LUEyr = Pnetya / jPARscabsya    !kg C fixed (J absorbed PAR)-1.
            LUEyrmole = Pnetmoleya / jPARscabsmoleya
                                      !moles C fixed (moles absorbed PAR)-1.
         ELSE
            LUEyr = zero; LUEyrmole = zero
         ENDIF


!YIELD CLASS.
      !Products from clearfelling now:
          Cbr_pr = fbr_rot_prod * nstems * MCbr  !kg C m-2.  From branches.
          Cst_pr = fst_rot_prod * nstems * MCst  !kg C m-2.  From stems.
      !After clearfelling, the felled trees go into the litter pools except
      !for fractions of the branches, fbr_rot_prod, and of the stems,
      !fst_rot_prod, which enter the rotation products pool:
         Constant fbr_rot_prod = 0.5
         Constant fst_rot_prod = 0.8
          Cpr = Cbr_pr + Cst_pr

          Nbr_pr = fbr_rot_prod * nstems * MNbr  !kg N m-2.  From branches.
          Nst_pr = fst_rot_prod * nstems * MNst  !kg N m-2.  From stems.
          Npr = Nbr_pr + Nst_pr

          Wpr = zero   !There are now no branch or stem water pools.
   
      !Total C, N, W in the products from thinning during the rotation
      !(no decay) and clearfelling at the end of the rotation:
          Cptr = Cpt + Cpr  !kg C m-2.
          Nptr = Npt + Npr  !kg N m-2.
          Wptr = Wpt + Wpr  !kg water m-2.   
                            !Wpr = 0 as there is now no stem water pool.

      !Total volume of these products is:
          Xpr = Cbr_pr * rbrX_Ctot + Cst_pr * rstX_Ctot
                                    !kg structural DM m-2.
          Xptr = Xpt + Xpr          !kg structural DM m-2.

          Vpt_ha =  10000.0 * Xpt  / rostem  !m3 ha-1.  Thinning products.
          Vpr_ha =  10000.0 * Xpr  / rostem  !m3 ha-1.  Rotation products.
          Vptr_ha = 10000.0 * Xptr / rostem  !m3 ha-1.  Total products.
                                    !Here we assume that a single density
                                    !rostem applies both to the branches and
                                    !the stems.
      IF ( year .NE. 0.0 ) THEN
          Vpt_hayr =  Vpt_ha  / year  !m3 ha-1 yr-1. Thinnings.
          Vpr_hayr =  Vpr_ha  / year  !m3 ha-1 yr-1. Rotation.
          Vptr_hayr = Vptr_ha / year  !m3 ha-1 yr-1. Thinnings and rotation.
          YC = Vptr_hayr !Yield class.   ditto.
      ELSE
          Vpt_hayr =  zero
          Vpr_hayr =  zero
          Vptr_hayr = zero
          YC = zero
      ENDIF

   !Testing simple exponential decay (Euler), from an initial value of 1:
      Dyst_fire = - kst_firez * yst_fire
       yst_fire = integ( Dyst_fire, yst_fire0 )
      Dysurf_li_fire = - ksurf_li_firez * ysurf_li_fire
       ysurf_li_fire = integ( Dysurf_li_fire, ysurf_li_fire0 )
          !These initial values are always set to 1 in Initial section.
             ysf_li_fire = ysurf_li_fire !For output only.
!   PROCEDURAL
!    ilogd = i18
!     IF ( calllogd ) CALL LOGD( .true. ) !6
!   END
   yrstop = tstop / c365 !tstop expressed in years. 
          !Not used anywhere above here. Just calculated for convenience.
   s_decid = s_deciduous !For output only, not used otherwise.
END !DERIVATIVE.  Derivative begins on p 55.


TERMINAL !Begin the terminal section, It is performed at the end of each run.
     !It is not sorted, but sorting can be specified .

!ilogd = i19
!CALL LOGD(.TRUE.) 

!Calculate some potential new tstops so that they can be used in command
   !procedures to continue the run.  Check that these are ok after a failure
   !which might mean that the terminal block is not executed. 
   !See beginning of the Derivative block above.
    t_maxt = t - maxt ! maxt = 0.00781250
    t_2maxt = t - 2.0 * maxt 
    tplus1hr = t + onehourdy ! onehourdy = 0.04166667 = 1/24.
    tplusmaxt = t + maxt     ! maxt = 0.00781250
    tplus2maxt = t + two * maxt
    tplus5maxt = t + five * maxt
    tplus10maxt = t + ten * maxt
    tplushalfdy = t + half
    tplus1dy = t + one
    tplus10dy = t + ten
    tplus50dy = t + 50
    tplus65dy = t + 65
    tplus100dy = t + c100
    tplus200dy = t + c200
    tplus300dy = t + 300
    tplus1yr = t + c365
    tplus2yr = t + 730
    tplus5yr = t + 1825
    tplus10yr = t + 3650

    yearplus1yr = year + 1

   !C, N, W accumulated over the simulation:
      DEL_Csys = Csys - Csys_t0;  DEL_Nsys = Nsys - Nsys_t0; 
      DEL_Wsys = Wsys - Wsys_t0
      DEL_Csoil = Csoil - Csoil_t0;  DEL_Nsoil = Nsoil - Nsoil_t0; 
      DEL_Wsoil = Wsoil - Wsoil_t0
      DEL_Ctree = Ctree - Ctree_t0
      DEL_Ntree = Ntree - Ntree_t0
      DEL_Wtree = Wtree - Wtree_t0
      DEL_Cptrd = Cptrd - Cptrd_t0;  DEL_Nptrd = Nptrd - Nptrd_t0; 
      DEL_Wptrd = Wptrd - Wptrd_t0
   !Checks on these quantities:
      DEL_Csys_chk = Int_ICsys - Int_OCsys  !Int_ denotes integral of.
      DEL_Nsys_chk = Int_INsys - Int_ONsys
      DEL_Wsys_chk = Int_IWsys - Int_OWsys

   !Averages of daily sums:
      !Check:
          sum_dy_av = chk_dy_sum / ( t + one )     !This should = 1.
      !Leaf area ratio = foliage mass / total tree mass (m2 kg-1):
          LAR_0h_sum_av = LAR_0h_sum / ( t + one )
      !Specific leaf area = foliage area / total foliage mass (m2 kg-1):
          SLA_0h_sum_av = SLA_0h_sum / ( t + one )
             SLA_0h_av = SLA_0h_sum_av !For output only.
   
   !Averages of yearly sums (of 1 Jul, 15 h quantities):
      IF ( year .NE. zero ) THEN
         !Check:
            chk_yr_av = chk_yr_sum / ( year + one ) !This should = 1.
         !Canopy photosynthesis (kg C m-2 day-1):
            Pcan_1Jul15h_av = Pcan_1Jul15h_yr_sum / year
            Pcan_IP_1Jul15h_av = Pcan_IP_1Jul15h_yr_sum / year
         !Asymptote of light response curve (kg CO2 m-2 s-1):
            Pmax_1Jul15h_av = Pmax_1Jul15h_yr_sum / year
         !Initial slope of light response curve [kg CO2 (J PAR)-1]:
            alpha_1Jul15h_av = alpha_1Jul15h_yr_sum / year
         !Foliage (le) relative water content (dimensionless):
            thetale_1Jul15h_av = thetale_1Jul15h_yr_sum / year
         !Stomatal conductance [m s-1 (m2 leaf)-1]:
            gstom_1Jul15h_av = gstom_1Jul15h_yr_sum / year
               gs_1J15h_av = gstom_1Jul15h_av !Output only.
         !Effect of stomatal conductance on Pmax [dimensionless]:
            fgstom_Pmax_1Jul15h_av = fgstom_Pmax_1Jul15h_yr_sum / year
         !Stomatal conductance [m s-1 (m2 leaf)-1]:
            gstom_1Aug15h_av = gstom_1Aug15h_yr_sum / year
         !Effect of stomatal conductance on Pmax [dimensionless]:
            fgstom_Pmax_1Aug15h_av = fgstom_Pmax_1Aug15h_yr_sum / year
         !Foliage (le) pressure potential [J (kg water)-1]:
            psiPle_1Jul15h_av = psiPle_1Jul15h_yr_sum / year
         !Relative soil water content (dimensionless):
            thetasoil_1Jul15h_av = thetasoil_1Jul15h_yr_sum / year

     
      !Average the quantities integrated above over the simulation:
         !Tree:
           !Self-thinning exponents averaged over the run from
           !t = 365 (y1) to the end of the run. This is to avoid transients.
            num_sn_exptl =        log10Mtree_y1   - log10Mtree
            num_sn_expMXsttl =    log10MXst_y1    - log10MXst
            num_sn_expMXtreetl =  log10MXtree_y1  - log10MXtree
            num_sn_expMtreeshtl = log10Mtreesh_y1 - log10Mtreesh
            num_sn_expMtreerttl = log10Mtreert_y1 - log10Mtreert
            den_sn_exptl = log10nstems_y1 - log10nstems
            IF ( ABS ( den_sn_exptl ) .NE. zero ) THEN
                 sn_exptl = - num_sn_exptl / den_sn_exptl 
                 sn_expMXsttl =    - num_sn_expMXsttl    / den_sn_exptl 
                 sn_expMXtreetl =  - num_sn_expMXtreetl  / den_sn_exptl 
                 sn_expMtreeshtl = - num_sn_expMtreeshtl / den_sn_exptl 
                 sn_expMtreerttl = - num_sn_expMtreerttl / den_sn_exptl 
                 alloMXsttl = num_sn_expMXsttl / num_sn_exptl 
                             !Allometric parameter, beta, for
                             !MXst ~ Mtree ** beta.                          
      
            ELSE
                 sn_exptl =        zero
                 sn_expMXsttl =    zero
                 sn_expMXtreetl =  zero
                 sn_expMtreeshtl = zero
                 alloMxsttl =      zero
            ENDIF

            LAI_av = Int_LAI / t
            SLA_av = Int_SLA / t
            Cle_av = Int_Cle / t
            Nle_av = Int_Nle / t
            Cphloem_av = Int_Cphloem / t
            Nphloem_av = Int_Nphloem / t
            Cfi_av = Int_Cfi / t
            Nfi_av = Int_Nfi / t
            Nph_av = Int_Nph / t
        !Average of Pmax20, maximum of light, CO2 response eqn at 20 deg C:
            Pmax20_av = Int_Pmax20 / t  !kg CO2 m-2 s-1. 
            Nph_A_av = Int_Nph_A / t
            fjPAR_Nph_av = Int_fjPAR_Nph / t
            fNSle_Nph_av =  Int_fNSle_Nph /t
            rCNle_av = Int_rCNle / t 
            rCNfi_av = Int_rCNfi / t 
            CStree_av = Int_CStree / t 
            NStree_av = Int_NStree / t 
            Nletot_av = Int_Nletot / t 
            Nletot_A_av = Int_Nletot_A / t 
            Ctree_av = Int_Ctree / t 
            Ntree_av = Int_Ntree / t 
            fCSmai_tree_av = Int_fCSmai_tree / t
           !XDM production in tree compartments:
            PXDMbrm_gnd_av = Int_PXDMbrm_gnd / year !kg XDM stem-1 year-1.
            PXDMbud_gnd_av = Int_PXDMbud_gnd / year
            PXDMstm_gnd_av = Int_PXDMstm_gnd / year
            PXDMcom_gnd_av = Int_PXDMcom_gnd / year
            PXDMfim_gnd_av = Int_PXDMfim_gnd / year
            Onstems_fire_av_yr = Int_Onstems_fire / year
               Ons_f_av_yr = Onstems_fire_av_yr !Output only.

         !Self-thinning:  
            sn_exp_av     = Int_sn_exp     / t   !Dimensionless.
            sn_expMXst_av = Int_sn_expMXst / t   !Dimensionless.
                            sn_exMXst_av = sn_expMXst_av !For output.
            sn_expMXtree_av = Int_sn_expMXtree / t   !Dimensionless.

         !Products:
            Cptrd_av = Int_Cptrd / t
            Nptrd_av = Int_Nptrd / t
            IF ( Nptrd_av .GT. 0.0 ) rCNptrd_av = Cptrd_av / Nptrd_av
         !Soil, litter:
            Namm_av = Int_Namm / t 
            Nnit_av = Int_Nnit / t 
               Nmin_av = Namm_av + Nnit_av 
            Cbio_av =  Int_Cbio / t 
            Csol_av =  Int_Csol / t 
            Csurf_li_av =  Int_Csurf_li / t 
            Csoil_li_av =  Int_Csoil_li / t 
            Nsurf_li_av =  Int_Nsurf_li / t 
            Nsoil_li_av =  Int_Nsoil_li / t 
            Clitter_av = Int_Clitter / t 
            Nlitter_av = Int_Nlitter / t 
            Csoil_av = Int_Csoil / t 
            Nsoil_av = Int_Nsoil / t 
              rCNsoil_av = Csoil_av / Nsoil_av
            CSOM_av = Int_CSOM / t 
            NSOM_av = Int_NSOM / t 
            CliSOM_av = Int_CliSOM / t 
            NliSOM_av = Int_NliSOM / t 
              rCNSOM_av = CSOM_av / NSOM_av
         !Tree and litter:
            Ctreelitter_av = Int_Ctreelitter / t
            Ntreelitter_av = Int_Ntreelitter / t
         !Water:
            rMSleWle_av = Int_rMSleWle / t
            psile_av = Int_psile / t
            psiOle_av = Int_psiOle / t
            psiPle_av = Int_psiPle / t
            thetale_av = Int_thetale / t
            thetasoil_av = Int_thetasoil / t
         !System:
            Csys_av = Int_Csys / t
            Nsys_av = Int_Nsys / t
                  rCNsys_av = Csys_av / Nsys_av

         !Environment fluxes:
            jPARsc_av_yr = Int_jPARsc / year
            jPARscabs_av_yr = Int_jPARscabs / year

         !C fluxes (kg C m-2 year-1):
            !System C inputs and outputs:
               ICsys_av_yr = Int_ICsys / year
               OCsys_av_yr = Int_OCsys / year
               OCprd_av_yr = Int_OCprd / year
               DCsys_av_yr = ICsys_av_yr - OCsys_av_yr 
            !Gross annual primary production:
               Pcan_av_yr = Int_Pcan / year
               Pcan_IP_av_yr = Int_Pcan_IP / year
            !Net annual primary production:
               Pnet_av_yr = Int_Pnet / year
            !Ratio of above:
               IF ( Pcan_av_yr .NE. 0.0 ) &
                  rPnet_Pcan_av_yr = Pnet_av_yr / Pcan_av_yr
                  rPn_Pc_av_yr = rPnet_Pcan_av_yr !Short form for output.
            !Stem density:
               Dnstems_av_yr = ( nstems - nstems_t0 ) / year !stems m-2 y-1.
                  Dnste_av_yr = Dnstems_av_yr    !Output only.
            !Tree respiration:
               Rtree_av_yr = Int_Rtree_gnd / year
            !Maintenance respiration:
               Rtreem_av_yr = Int_Rtreem_gnd / year
            !Growth respiration:
               RtreeG_av_yr = Int_RtreeG_gnd / year
            !Phloem loading respiration:
               Rphloem_loading_gnd_av_yr = Int_Rphloem_loading_gnd / year
            !Nitrate reduction respiration:
               RNnit_red_tree_gnd_av_yr = Int_RNnit_red_tree_gnd / year

            !Mineral (excluding N) uptake:
               Rmin_upt_gnd_av_yr = Int_Rmin_upt_gnd / year
            !Mineral N uptake:
               RNmin_upt_gnd_av_yr = Int_RNmin_upt_gnd / year

            !Csol inputs and outputs:
               ICsurf_li_Csol_av_yr = Int_ICsurf_li_Csol / year 
               ICsoil_li_Csol_av_yr = Int_ICsoil_li_Csol / year 
               ICfi_Csol_av_yr =      Int_ICfi_Csol      / year 
               ICbioD_Csol_av_yr =    Int_ICbioD_Csol    / year 
               ICuSOM_Csol_av_yr =    Int_ICuSOM_Csol    / year 
               ICpSOM_Csol_av_yr =    Int_ICpSOM_Csol    / year 
               ICsSOM_Csol_av_yr =    Int_ICsSOM_Csol    / year 

            !C losses from tree and surface litter to atmosphere due to fire:
               OCtree_fire_atm_av_yr = Int_OCtree_fire_atm / year
               OCsurf_li_fire_atm_av_yr = Int_OCsurf_li_fire_atm / year

               OCsol_bioG_av_yr =     Int_OCsol_bioG     / year 
               OCsolR_av_yr =         Int_OCsolR         / year 
               OCsol_lch_av_yr =      Int_OCsol_lch      / year !C leaching.

            !Soil and litter respiration:
               Rsoil_av_yr = Int_Rsoil / year
            !C removed in products, no decay, per year basis over the rotation:
               OC_ptr_av_yr = Cptr / year !Cptr includes thinning products
                  !without decay, and the products of clear-felling at the
                  !end of the rotation.
         !N fluxes (kg N m-2 year-1):
            !N uptake by roots:
               uN_gnd_av_yr = Int_uN_gnd / year
            !SOM mineralization (goes all into Namm):
               INSOM_Namm_av_yr = Int_INSOM_Namm / year
            !Shoot N substrate into photosynthetic N (Nph):
               INSle_Nph_av_yr = Int_INSle_Nph / year
            !Bud N into  photosynthetic N (Nph):
               INbud_Nph_av_yr = Int_INbud_Nph / year
            !Total N input from atmosphere by deposition and by non-symbiotic
            !N fixation:
               INsys_av_yr = Int_INsys / year
               INsyse4_av_yr = INsys_av_yr * c10000  !kg N ha-1 y-1.
            !N input from non-symbiotic N fixation:
               INfix_Namm_av_yr = Int_INfix_Namm / year
                  INfix_av_yr = INfix_Namm_av_yr !Output only.
            !N input from atmosphere by deposition:
               INenv_dep_av_yr = Int_INenv_dep / year
            !Total N output from system:
               ONsys_av_yr = Int_ONsys / year
               ONsyse4_av_yr = ONsys_av_yr * c10000  !kg N ha-1 y-1.
            !Average rate of change of system N:
               DNsys_av_yr = INsys_av_yr - ONsys_av_yr
            !Ratio of N output to N input (in steady state this should be 1):
               IF ( Int_INsys .NE. 0.0 ) &
                  rONsysINsys_av = Int_ONsys / Int_INsys    !Dimensionless.
            !N output to products of thinning and rotation:
               ONprd_av_yr = Int_ONprd / year
            !Tree N uptake:
               ONsoil_fi_av_yr = Int_ONsoil_fi / year
            !Ammonia flux, foliage to/from environment:
               ONSle_atm_gnd_av_yr = Int_ONSle_atm_gnd / year
            !Leaching:
               ONnit_lch_av_yr = Int_ONnit_lch / year
            !Volatilization:
               ONamm_vol_av_yr = Int_ONamm_vol / year
            !Nitrification (loss to environment):
               ONamm_nitrif_env_av_yr = Int_ONamm_nitrif_env / year
            !Denitrification:
               ONnit_denit_av_yr = Int_ONnit_denit / year
            !Nitrification flux, output from Namm to Nnit:
               ONamm_nit_av_yr = Int_ONamm_nit / year
            !N losses from tree and surface litter to atmosphere due to fire:
               ONtree_fire_atm_av_yr = Int_ONtree_fire_atm / year
               ONsurf_li_fire_atm_av_yr = Int_ONsurf_li_fire_atm / year
            !Total N losses from soil to environment:
               ONsoil_env_av_yr = Int_ONsoil_env/ year
            !N losses from decaying thinning products pool:
               ONprthd_av_yr = Int_ONprthd /year
            !N losses from decaying rotation products pool:
               ONprrod_av_yr = Int_ONprrod / year

            !Gaseous losses:
               ONsoil_gas_av_yr = ONamm_vol_av_yr + ONamm_nitrif_env_av_yr &
                                                  + ONnit_denit_av_yr
               ONsys_gas_av_yr = ONsoil_gas_av_yr + ONSle_atm_gnd_av_yr
            !N removed in products:
               ONtree_ptr_yr = Nptr / year !Nptr includes thinning products
                  !without decay, and the products of clear-felling at the
                  !end of the rotation.
         !Water fluxes (kg water m-2 year-1 = 1 mm water year-1):
            !Rainfall = IWsys_av_yr below.
            !Flux of water from foliage to atmosphere by direct evaporation:
               OWrain_int_av_yr = Int_OWrain_int / year
            !Evapotranspiration flux:
               OWle_atm_gnd_av_yr = Int_OWle_atm_gnd / year
            !Flux of water from direct soil evaporation:
               OWso_atm_av_yr = Int_OWso_atm / year
            !Drainage:
               OWso_drain_av_yr = Int_OWso_drain / year    !kg water m-2 y-1.
               OWso_drain_mm_av_yr = c1000 * OWso_drain_av_yr / roW 
                                                           !mm water y-1.
            !System:
               IWsys_av_yr = Int_IWsys / year
               OWsys_av_yr = Int_OWsys / year

         !Products:
            IVpt_av_yr = Int_IVpt / year       !m3 wood products m-2 year-1.
            IVpte4_av_yr = c10000 * IVpt_av_yr !m3 wood products ha-1 year-1.
   ELSE
      Vptr_hayr = zero
   ENDIF

!WATER AND LIGHT USE EFFICIENCIES OVER THE RUN (SINCE START)
      Int_OWle_atm_gndmole = c1000 * Int_OWle_atm_gnd / rmmW !moles water m-2.
      Int_Pnetmole = c1000 * Int_Pnet / rmmC                !moles carbon m-2.
      Int_jPARscmole = Int_jPARsc * r_moles_JPAR
                                           !moles incident quanta (PAR) m-2.
      Int_jPARscabsmole = Int_jPARscabs * r_moles_JPAR
                                      !moles absorbed quanta (PAR) m-2.
        !For r_moles_JPAR = 4.598e-6 mole PAR (J PAR)-1 factor,
        !see Thornley, 1998, Grassland Dynamics, p. 217.

   !Water use efficiency:
         IF ( Int_OWle_atm_gnd .NE. zero )  THEN
            WUErun = Int_Pnet / Int_OWle_atm_gnd
                                     !kg C fixed (kg transpired water)-1.
            WUErunmole = Int_Pnetmole / Int_OWle_atm_gndmole 
                                !moles C fixed (moles transpired water)-1.
         ELSE
               WUErun = zero; WUErunmole = zero
         ENDIF

   !Light use efficiency:
         IF ( Int_jPARscabs .NE. zero )  THEN
            LUErun = Int_Pnet / Int_jPARscabs
                                         !kg C fixed (J absorbed PAR)-1.
            LUErunmole = Int_Pnetmole / Int_jPARscabsmole 
                                   !moles C fixed (moles absorbed PAR)-1.
         ELSE
               LUErun = zero; LUErunmole = zero
         ENDIF

   
   !Dump some final quantities for output/printing (these are the only
      !variables ending in tl (tl denotes terminal).
      !Thus prepar *tl prepares all these variables.
         ttl = t; tstoptl = tstop
         yrstoptl = yrstop
         nstarttl = nstart
         INTEGER runnotl; runnotl = runno
         year_calendartl = year_calendar; year_indextl = year_index 
         yeartl = year; irotatetl = irotate;  
         IF ( yeartl .GT. zero ) log10yeartl = LOG10( yeartl )
         year_accumtl = year_accum 
      !Management:
         s_thintl = s_thin
      !Environment:
         Tairyatl = Tairya;          Tsoilyatl = Tsoilya
         Tair_inctl = Tair_inc; Tsoil_inctl = Tsoil_inc
         CO2vpmtl = CO2vpm
         jPARscyatl = jPARscya;      jNetRscyatl = jNetRscya
         jPARscabsyatl = jPARscabsya
         jPARdyem6yatl = jPARdyem6ya
         m_raintl = m_rain
         rainyatl = rainya;          RHyatl = RHya
         windyatl = windya
         INenv_Namm_m12tl = INenv_Namm_m12
         INenv_Namm_hayrtl = INenv_Namm_hayr

      !Fire:
         tfire1tl = tfire(1)

      !Mineralization multiplier:
         m_kminyatl = m_kminya
         lnm_kminyatl = LOG( m_kminyatl ) !Log to base e.
         ln2m_kminyatl = lnm_kminyatl / ln2

      !Phenology:
         dorm2tl = dorm2; comptl = comp; budbtl = budb; dorm1tl = dorm1
         INTEGER jbudbtl, jdorm1tl, jleaf_falltl, jdorm2tl 
         jbudbtl = jbudb             !Julian day of budburst.
         jdorm1tl = jdorm1           !Julian day of dormancy beginning.
         jleaf_falltl = jleaf_fall   !Julian day of leaf fall.
         jdorm2tl = jdorm2           !Julian day of dormancy ending.

         tbudbtl = tbudb             !Time of budburst.
         tdorm1tl = tdorm1           !Time of dormancy beginning.
         tleaf_falltl = tleaf_fall   !Time of leaf fall.
         tdorm2tl = tdorm2           !Time of dormancy ending.

         dormanttl = dormant         !Dormant? 1, yes; 0 no.
         s_leafyatl = s_leafya       !Number of days when there are leaves.
         dormantyatl = dormantya     !Days of dormancy during calendar year.
         days_dormanttl = days_dormant !Days of dormancy during the last
                                     !completed period of dormancy.
         days_dormancytl = days_dormancy !Accumulator of days of dormancy.

        !Constants.
         Tbudb_dorm1maxtl = Tbudb_dorm1max
                                  !Max temp for progress -> dormancy onset.
         kbudb_dorm120tl = kbudb_dorm120 !Rate constant -> dormancy onset.
         Tdorm1_budbmintl = Tdorm1_budbmin !Min temp for dormancy delay.
         kdorm1_budb20tl =  kdorm1_budb20 !Rate constant for dormancy delay.
         Tdorm1_2mintl = Tdorm1_2min !Min temp for -> dormancy ending.
         kdorm1_220tl = kdorm1_220 !Rate constant for -> dormancy ending.

         fpruneyrtl = fpruneyr       !year-1. Pruning rate constant.
         yrch_15hyatl = yrch_15hya
         fWph_15hyatl = fWph_15hya
         fgstom_Pmax_15hyatl = fgstom_Pmax_15hya 
         LAItl = LAI;  
            IF ( LAItl .GT. zero ) THEN
                 log10LAItl = LOG10( LAItl )
            ELSE

                 log10LAItl = csmall
            ENDIF
         SLAtl = SLA;  hstemtl = hstem;  dstemtl = dstem
            IF ( hstemtl .GT. zero ) THEN
                 log10hstemtl = LOG10( hstemtl )
            ELSE
                 log10hstemtl = csmall
            ENDIF
                 log10hsttl = log10hstemtl 
         LAIyatl = LAIya;  DLAIyatl = DLAIya;  SLAyatl = SLAya
         roaphtl = roaph  !Aphid density on leaves. 
         aph_gndtl = aph_gnd !Aphids per unit ground area.
         aphyatl = aphya !aph = total aphid number.
         s_aphidtl = s_aphid !Switch fo aphid submodel.
         MXletl = MXle
         Mtreetl = Mtree;  Mtree_gndtl = Mtree_gnd
         rshrtyatl = rshrtya;   rlefiyatl = rlefiya
         rlefiGXyatl = rlefiGXya
         s_Pcantl = s_Pcan 

         fint_ht0ztl = fint_ht0z
         ! = Acanmax_hstem / Acanmax_nstems !Dimensionless.
         fint_ht0tl = fint_ht0 !MIN( fint_ht0z , one ) !Dimensionless.
            !Define a dimensionless function, ufint_ht:
               gap_canopytl = gap_canopy 
                  !MAX( zero, dcanmax_nstems - dcanmax_hstem ) !m.
               ufint_httl = ufint_ht !hstem/(hstem + cufint_ht * gap_canopy)
                    !Constant cufint_ht = 1    !Dimensionless.
               fint_httl = fint_httl 
               !fint_ht0 + ( one - fint_ht0 ) * ufint_ht
         s_Tblackctl = s_Tblackc ; Tblackctl = Tblackc
         Tblacktl = Tblack

         PCO2sc4tl = PCO2sc4
            IF ( PCO2sc4tl .GT. zero ) THEN
                 log10PCO2sc4tl = LOG10( PCO2sc4tl )
            ELSE

                 log10PCO2sc4tl = csmall
            ENDIF
                 log10Psc4tl = log10PCO2sc4tl 

         PCO2sc5tl = PCO2sc5
            IF ( PCO2sc5tl .GT. zero ) THEN
                 log10PCO2sc5tl = LOG10( PCO2sc5tl )
            ELSE

                 log10PCO2sc5tl = csmall
            ENDIF
                 log10Psc5tl = log10PCO2sc5tl 

         Pmax20yatl = Pmax20ya; 
         Pcanyatl = Pcanya;    !kg C m-2 y-1.
         Pmax20e6yatl = Pmax20e6ya; Pm20e6yatl = Pmax20e6yatl !Output only.
         Nphyatl = Nphya;  Nph_Ayatl = Nph_Aya
         Pcan_IPyatl = Pcan_IPya; Pnetyatl = Pnetya

         Pcandatl = Pcanda    !kg C m-2 day-1.

         OCprdyatl = OCprdya
         OCprd_envyatl = OCprdyatl 
         rPnet_Pcanyatl = rPnet_Pcanya
         RGtree_gndyatl = RGtree_gndya; Rmai_tree_gndyatl = Rmai_tree_gndya
         rRmai_RGtreeyatl = rRmai_RGtreeya
  !Selfthinning parameters:
         s_selfthintl = s_selfthin
         sntl = s_selfthin         
         allovrtl = allovr
         s_seedstl = s_seeds
         FGRnstemsyatl = FGRnstemsya 
         FGRnstyatl = FGRnstya != FGRnstemsya.
         FBRnstemsyatl = FBRnstemsya
         FDRnstemsyatl = FDRnstemsya
         FGRnstems_snyatl = FGRnstems_snya
         FBRnstems_snyatl = FBRnstemsya
         FDRnstems_snyatl = FDRnstemsya
         ICtree_soilyatl = ICtree_soilya;  INtree_soilyatl = INtree_soilya
         INenv_soilyatl = INenv_soilya
  !Fractions of total structural dry matter in foliage, branches, etc
         fleXtl = fleX;  fbrXtl = fbrX;  fstXtl = fstX
         fcoXtl = fcoX;  ffiXtl = ffiX

         Cleyatl = Cleya;  Cbryatl = Cbrya;  Cstyatl = Cstya
         Ccoyatl = Ccoya;  Cfiyatl = Cfiya
         Cletotyatl = Cletotya
         CSletotyatl = CSletotya
         CXletotyatl = CXletotya
         Nleyatl = Nleya;  Nbryatl = Nbrya;  Nstyatl = Nstya
         Ncoyatl = Ncoya;  Nfiyatl = Nfiya
         Cphloemyatl = Cphloemya;  Nphloemyatl = Nphloemya
         CNleyatl = CNleya;  CNbryatl = CNbrya;  CNstyatl = CNstya
         CNcoyatl = CNcoya;  CNfiyatl = CNfiya
         CNtreeyatl = CNtreeya
         fNXle_recyatl = fNXle_recya
         Nletotyatl = Nletotya; 
         NSletotyatl = NSletotya; 
         Nphtotyatl = Nphtotya; 
         NXletotyatl = NXletotya; 
         Nletot_Xyatl = Nletot_Xya;           Nletot_Ayatl = Nletot_Aya;
         CStreeyatl = CStreeya; NStreeyatl = NStreeya
         Ntree_mai_gndyatl = Ntree_mai_gndya
         Nminyatl = Nminya;  Nmine3yatl = Nmine3ya; Nmine4yatl = Nmine4ya;
         Cptrdtl = Cptrd;  Nptrdtl = Nptrd
         rCNptrd_avtl = rCNptrd_av
         Vpth_hayatl = Vpth_haya
         Neff_uNyatl = Neff_uNya;   Neff_bioyatl = Neff_bioya
         Nammyatl = Nammya;  Nnityatl = Nnitya;
         rNammNnityatl = rNammNnitya !Ratio of Namm / Nnit.
         Csolyatl = Csolya;  

         DCbioyatl = DCbioya;  Cbioyatl = Cbioya;
         Gbioyatl = Gbioya;  Dbioyatl = Dbioya;
         fCNbioyatl = fCNbioya;   fbiomaxyatl = fbiomaxya;
         fbiominyatl = fbiominya;

         rhdstemtl = rhdstem;  MXsttl = MXst;  Aleaftl = Aleaf
         ISGRletl = ISGRle;  ISGRcotl = ISGRco
         psiPletl = psiPle;  
         rpsiPle_fitl = rpsiPle_fi 

         gstom_1Jul15htl = gstom_1Jul15h
            gs_1Jul15htl = gstom_1Jul15htl 
            gs_1J15htl = gs_1Jul15htl 
            gse3_1Jul15htl = gse3_1Jul15h 
         LAI_1Aug15htl = LAI_1Aug15h
         LAI_t0tl = LAI_t0
         LAI_y1tl = LAI_y1
         LAI_y2tl = LAI_y2
         LAI_y3tl = LAI_y3
         LAI_y5tl = LAI_y5

         Ctreetl = Ctree;  Ntreetl = Ntree
         IF ( Ntree .GT. 0.0 ) rCNtreetl = Ctree / Ntree
         nstemstl = nstems;  nstemse1tl = c10 * nstemstl
         nstemse2tl = c100 * nstemstl
         Dnstemsyatl = Dnstemsya;
         nstems_1yrtl = nstems_1yr 

         Onstems_fireyatl = Onstems_fireya
         Vstemtl = Vstem;  Vstem_gndtl = Vstem_gnd
         RDhDdstemtl = RDhDdstem 
         dhstemyatl = dhstemya;  ddstemyatl = ddstemya
         rDhDdstemyatl = rDhDdstemya
         Cpttl = Cpt;  Cprtl = Cpr;  Cptrtl = Cptr
         Npttl = Npt;  Nprtl = Npr;  Nptrtl = Nptr

         INammyatl = INammya
         INfi_Nammyatl = INfi_Nammya
         INbio_Nammyatl = INbio_Nammya
         INenv_Nammyatl = INenv_Nammya;  
                          INe_Ne4yatl = INen_Nae4ya != INenv_Nammya
         Nenv_Nnityatl = INenv_Nnitya
            yearINenv_Nammyatl = yeartl + INenv_Nammyatl !For output purposes.
         INenv_Nminyatl = INenv_Nminya
         INfert_Nammyatl = INfert_Nammya;  INfert_Nnityatl = INfert_Nnitya
         INfert_Nminyatl = INfert_Nminya
         INfix_Nammyatl = INfix_Nammya;
         INfixe4yatl = INfx_Nae4ya !kg N fixed ha-1 year-1.
         INlitter_Nammyatl = INlitter_Nammya
         INlitter_Namme4yatl = c10000 * INlitter_Nammya

         ksurf_li_celyatl = ksurf_li_celya; ksoil_li_celyatl = ksoil_li_celya
         ksurf_li_ligyatl = ksurf_li_ligya; ksoil_li_ligyatl = ksoil_li_ligya

         INSOM_Nammyatl = INSOM_Nammya
         INSOM_Namme4yatl = INSOM_Namme4ya
         ONmin_immyatl = ONmin_immya
                         ONmin_imme4yatl = c10000 * ONmin_immyatl 
         netSOM_minfluxe4yatl = netSOM_minfluxe4ya
         INliSOM_Nammyatl = INliSOM_Nammya
         uN_gndyatl = uN_gndya;  uN_gnde4yatl = uN_gnde4ya; 
         ONSle_atm_gndyatl = ONSle_atm_gndya
         ONamm_volyatl = ONamm_volya
         ONamm_nitrif_envyatl = ONamm_nitrif_envya
         ONnit_denityatl = ONnit_denitya
         ONnit_lchyatl = ONnit_lchya
         ONnit_lche4yatl = ONnit_lche4ya
         ONlche4yatl = ONnit_lche4yatl 
         ONsoil_gasyatl = ONsoil_gasya;  ONsys_gasyatl = ONsys_gasya
         ONsys_envyatl = ONsys_envya
         ONprdyatl = ONprdya;
         ONprd_envyatl = ONprdyatl
         !System:
         DCsysyatl = DCsysya;  Csysyatl = Csysya
         ICsysyatl = ICsysya;  OCsysyatl = OCsysya

         DNsysyatl = DNsysya                               !kg N m-2 year-1.
         DNsyse4yatl = DNsyse4ya                           !kg ha-1 year-1.
         Nsysyatl = Nsysya                                 !kg N m-2.
         INsysyatl = INsysya;  ONsysyatl = ONsysya         !kg N m-2 year-1.
         INsyse4yatl = INsyse4ya;  ONsyse4yatl = ONsyse4ya !kg ha-1 year-1.
         I_ONsysyatl = I_ONsysya                           !kg N m-2 year-1.
         I_ONsy4yatl = c10000 * I_ONsysyatl                !kg ha-1 year-1.

         Ctreeyatl = Ctreeya;  Csoilyatl = Csoilya
         Cptrdyatl = Cptrdya

         OC_ptr_av_yrtl = OC_ptr_av_yr; Vstem_hayrtl = Vstem_hayr
         Vptr_hayrtl = Vptr_hayr; YCtl = Vptr_hayrtl
         Vpt_hayrtl = Vpt_hayr;  Vpr_hayrtl = Vpr_hayr


         !Water fluxes:
            rainyatl = rainya
            IWsysyatl = rainyatl
            OWsysyatl = OWsysya
            OWso_drainyatl = OWso_drainya
            OWso_drain_myatl = OWso_drain_mya
            OWso_drain_mmyatl = OWso_drain_mmya 
            OWrain_intyatl = OWrain_intya
            OWle_atm_gndyatl = OWle_atm_gndya
            OWle_atmyatl = OWle_atmya
            OWle_rad_gndyatl = OWle_rad_gndya
            OWle_vdg_gndyatl = OWle_vdg_gndya
            OWso_atmyatl = OWso_atmya
            OWprdyatl = OWprdya
         
         Nammtl = Namm;       Nnittl = Nnit;       Nmintl = Nmin
         Csoiltl = Csoil;     Nsoiltl = Nsoil
         Clittertl = Clitter; Nlittertl = Nlitter
         rCNlittertl = rCNlitter
         Ctreelittertl = Ctreelitter; Ntreelittertl = Ntreelitter
         Csoltl = Csol;       Cbiotl = Cbio
         CSOMtl = CSOM;       CSOMe4tl = CSOMe4
         NSOMtl = NSOM;       NSOMe4tl = NSOMe4
         CSOM_t0tl = CSOM_t0; NSOM_t0tl = NSOM_t0
         CpSOM_t0tl = CpSOM_t0;  NpSOM_t0tl = NpSOM_t0
         CuSOMtl = CuSOM;     NuSOMtl = NuSOM
         CpSOMtl = CpSOM;     NpSOMtl = NpSOM
         CsSOMtl = CsSOM;     NsSOMtl = NsSOM
         Csystl = Csys;       Nsystl = Nsys
         Csys_t0tl = Csys_t0; Nsys_t0tl = Nsys_t0
         rCNsystl = rCNsys;   rCNSOMtl = rCNSOM

         !sSOM pool:
             DCsSOMyatl = DCsSOMya
             ICsSOMyatl = ICsSOMya
             ICuSOM_sSOMyatl = ICuSOM_sSOMya
             ICpSOM_sSOMyatl = ICpSOM_sSOMya
             OCsSOM_minyatl =  OCsSOM_minya
             INsSOMyatl =      INsSOMya
             ONsSOM_Nammyatl = ONsSOM_Nammya
             rCNsSOMnyatl =    rCNsSOMnya

      !Variables averaged over the last rotation:
         !Tree:
            LAI_avtl = LAI_av
            SLA_avtl = SLA_av
            Cle_avtl = Cle_av
            Nle_avtl = Nle_av
            Cfi_avtl = Cfi_av
            Nfi_avtl = Nfi_av
            rCNle_avtl = rCNle_av;         rCNfi_avtl = rCNfi_av
            CStree_avtl = CStree_av;       NStree_avtl = NStree_av
            Nletot_avtl = Nletot_av;       Nletot_A_avtl =  Nletot_A_av  
            Nph_avtl = Nph_av
            Nph_A_avtl = Nph_A_av
            fjPAR_Nph_avtl = fjPAR_Nph_av
            fNSle_Nph_avtl = fNSle_Nph_av
            Ctree_avtl = Ctree_av;  Ntree_avtl = Ntree_av
            fCSmai_tree_avtl = fCSmai_tree_av
            Dnstems_av_yrtl = Dnstems_av_yr
            Onstems_fire_av_yrtl = Onstems_fire_av_yr

            OCtree_fire_atm_av_yrtl = OCtree_fire_atm_av_yr 
            OCsurf_li_fire_atm_av_yrtl = OCsurf_li_fire_atm_av_yr

         !Products:
            Cptrd_avtl = Cptrd_av;  Nptrd_avtl = Nptrd_av
         !Soil, litter:
            Namm_avtl = Namm_av;  Nnit_avtl = Nnit_av
            Nmin_avtl = Namm_avtl + Nnit_avtl 
               Nmin_e3avtl = c1000 * Nmin_avtl 
            Cbio_avtl = Cbio_av
            Csol_avtl = Csol_av
            Csurf_li_avtl = Csurf_li_av 
            Csoil_li_avtl = Csoil_li_av 
            Nsurf_li_avtl = Nsurf_li_av 
            Nsoil_li_avtl = Nsoil_li_av 
            Clitter_avtl = Clitter_av;  Nlitter_avtl = Nlitter_av
            Csoil_avtl = Csoil_av;  Nsoil_avtl = Nsoil_av
            rCNsoil_avtl = rCNsoil_av
            CSOM_avtl = CSOM_av;  NSOM_avtl = NSOM_av
            CliSOM_avtl = CliSOM_av;  NliSOM_avtl = NliSOM_av
            Ctreelitter_avtl = Ctreelitter_av
            Ntreelitter_avtl = Ntreelitter_av
            rCNSOM_avtl = rCNSOM_av
         !Water:
            rMSleWle_avtl = rMSleWle_av;  psile_avtl = psile_av
            psiOle_avtl = psiOle_av
            psiPle_avtl = psiPle_av
            thetale_avtl = thetale_av;    thetasoil_avtl = thetasoil_av
         !System:
            Csys_avtl = Csys_av;  Nsys_avtl = Nsys_av
      
         !Environment fluxes:
            jPARsc_av_yrtl = jPARsc_av_yr 
            jPARscabs_av_yrtl = jPARscabs_av_yr 
         !C fluxes (kg C m-2 year-1):
            ICsys_av_yrtl = ICsys_av_yr
            OCsys_av_yrtl = OCsys_av_yr
            OCprd_av_yrtl = OCprd_av_yr
            DCsys_av_yrtl = DCsys_av_yr
            Pcan_av_yrtl = Pcan_av_yr;  Pcan_IP_av_yrtl = Pcan_IP_av_yr;
               Pca_av_yrtl = Pcan_av_yrtl !11 chars. Output only.
            Pnet_av_yrtl = Pnet_av_yr;  
               Pn_av_yrtl = Pnet_av_yrtl 
            rPnet_Pcan_av_yrtl = rPnet_Pcan_av_yr
               rPnPc_a_ytl = rPnet_Pcan_av_yrtl  !11 chars. Output only.  
            Pmax20_avtl = Pmax20_av
            Pmax20e6_avtl = Pmax20_avtl * c1E6 !mg CO2 m-2 s-1.
                  Pm20e6_avtl = Pmax20e6_avtl !Output only.
            Rtree_av_yrtl = Rtree_av_yr
               Rtr_av_yrtl = Rtree_av_yrtl !Output only.
            Rtreem_av_yrtl = Rtreem_av_yr
            RtreeG_av_yrtl = RtreeG_av_yr
            Rphloem_loading_gnd_av_yrtl = Rphloem_loading_gnd_av_yr
               RNnit_red_tree_gnd_av_yrtl = RNnit_red_tree_gnd_av_yrtl
            Rmin_upt_gnd_av_yrtl = Rmin_upt_gnd_av_yr
            RNmin_upt_gnd_av_yrtl = RNmin_upt_gnd_av_yr

            ICsurf_li_Csol_av_yrtl = ICsurf_li_Csol_av_yr
            ICsoil_li_Csol_av_yrtl = ICsoil_li_Csol_av_yr
            ICfi_Csol_av_yrtl = ICfi_Csol_av_yr
            ICbioD_Csol_av_yrtl = ICbioD_Csol_av_yr
            ICuSOM_Csol_av_yrtl = ICuSOM_Csol_av_yr
            ICpSOM_Csol_av_yrtl = ICpSOM_Csol_av_yr
            ICsSOM_Csol_av_yrtl = ICsSOM_Csol_av_yr

            OCsol_bioG_av_yrtl = OCsol_bioG_av_yr
            OCsolR_av_yrtl = OCsolR_av_yr
            OCsol_lch_av_yrtl = OCsol_lch_av_yr

            Rsoil_av_yrtl = Rsoil_av_yr

         !N fluxes (kg N m-2 year-1):
            uN_gnd_av_yrtl = uN_gnd_av_yr
               uN_gnde4_av_yrtl = c10000 * uN_gnd_av_yrtl !kg N ha-1 y-1.
            INSOM_Namm_av_yrtl = INSOM_Namm_av_yr
               INSOM_Namme4_av_yrtl = c10000 * INSOM_Namm_av_yrtl
                                                           !kg N ha-1 y-1.
            INSle_Nph_av_yrtl = INSle_Nph_av_yr
            INbud_Nph_av_yrtl = INbud_Nph_av_yr
            INsys_av_yrtl = INsys_av_yr
            INsyse4_av_yrtl = INsyse4_av_yr
            INfix_Namm_av_yrtl = INfix_Namm_av_yr
               INfix_Namme4_av_yrtl = c10000 * INfix_Namm_av_yrtl 
               INfixe4aytl = INfix_Namme4_av_yrtl !Output only.
            INenv_dep_av_yrtl = INenv_dep_av_yr
               INenv_depe4_av_yrtl = c10000 * INenv_dep_av_yrtl
            ONsys_av_yrtl = ONsys_av_yr
            ONsyse4_av_yrtl = ONsyse4_av_yr
            DNsys_av_yrtl = DNsys_av_yr
               DNsyse4_av_yrtl = c10000 * DNsys_av_yrtl
            rONsysINsys_avtl = rONsysINsys_av
            ONprd_av_yrtl = ONprd_av_yr
               ONprde4_av_yrtl = c10000 * ONprd_av_yrtl
            ONnit_lch_av_yrtl = ONnit_lch_av_yr
               ONnit_lche4_av_yrtl = c10000 * ONnit_lch_av_yrtl
            ONamm_vol_av_yrtl = ONamm_vol_av_yr
            ONamm_nitrif_env_av_yrtl = ONamm_nitrif_env_av_yr
               ONamm_nitrif_enve4_av_yrtl = c10000 * ONamm_nitrif_env_av_yrtl
            ONnit_denit_av_yrtl = ONnit_denit_av_yr
               ONnit_denite4_av_yrtl = c10000 * ONnit_denit_av_yrtl
            ONtree_ptr_yrtl = ONtree_ptr_yr
               ONtree_ptre4_yrtl = c10000 * ONtree_ptr_yrtl
            ONsoil_fi_av_yrtl = ONsoil_fi_av_yr  
               ONsoil_fie4_av_yrtl = c10000 * ONsoil_fi_av_yrtl

            ONtree_fire_atm_av_yrtl = ONtree_fire_atm_av_yr 
            ONsurf_li_fire_atm_av_yrtl = ONsurf_li_fire_atm_av_yr
            
            Nletottl = Nletot

         !Water fluxes (kg water m-2 year-1 = 1 mm water year-1):
            IWsys_av_yrtl = IWsys_av_yr  !This is the rainfall.
            OWso_drain_av_yrtl = OWso_drain_av_yr  !kg water m-2 y-1.
            OWso_drain_mm_av_yrtl = c1000 * OWso_drain_av_yrtl / roW
                                                   !mm water y-1.
            OWle_atm_gnd_av_yrtl = OWle_atm_gnd_av_yr
            OWso_atm_av_yrtl = OWso_atm_av_yr
            OWrain_int_av_yrtl = OWrain_int_av_yr
         !Midnight daily values averaged over the rotation:
            sum_dy_avtl = sum_dy_av !This is a check.
                                            !It should be equal to t.
         !Leaf area ratio = foliage mass / total tree mass (m2 kg-1):
            LAR_0h_sum_avtl = LAR_0h_sum_av
         !Specific leaf area = foliage area / total foliage mass (m2 kg-1):
            SLA_0h_sum_avtl = SLA_0h_sum_av; SLA_0h_avtl = SLA_0h_sum_avtl 
         !Averages over the rotation of 1 July 15h values:
            chk_yr_avtl = chk_yr_av  !This is a check.  It should = 1.
            Pcan_1Jul15h_avtl = Pcan_1Jul15h_av
            Pcan_IP_1Jul15h_avtl = Pcan_IP_1Jul15h_av
            Pmax_1Jul15h_avtl = Pmax_1Jul15h_av
            alpha_1Jul15h_avtl = alpha_1Jul15h_av
            thetale_1Jul15h_avtl = thetale_1Jul15h_av
            gstom_1Jul15h_avtl = gstom_1Jul15h_av
               gs1J15_avtl = gstom_1Jul15h_avtl !Output only.
               gs1J15e3_avtl = c1000 * gs1J15_avtl 
            psiPle_1Jul15h_avtl = psiPle_1Jul15h_av
            thetasoil_1Jul15h_avtl = thetasoil_1Jul15h_av

         !Check variables:
            yst_firetl = yst_fire
            ysurf_li_firetl = ysurf_li_fire
   !End of terminal dump section into variables *tl.
   
   
   !ROTATION
      !This section simulates clearfelling, and immediate replanting.
      !After a rotation, the next rotation begins at t = 0, with a "start".
      !Litter pools are incremented - ie, the initial values for the next 
      !rotation are incremented.
      !Also, product pools are incremented.

      !Rotation is switched on (1) / off (0) with
         !Constant s_rotate = 0  !Default is no rotation.

      !Length of the rotation is equal to tstop.  This should not be
         !more than 200 years (tstop = 73000 days). See kpulse_thin function.
   
      !INTEGER irotate
      !irotate = number of current rotation, initialized to 1. 
         !See Initial block for initialization.
            !irotate = 1, 2, & .  If irotate = 2, the plantation has been
            !cleared once, and we are in the 2nd rotation.
            !Rotation counter is incremented in the initial block.
   
   IF ( s_rotate .EQ. one ) THEN !execute this section. Updating 
      !for the beginning of the next rotation.

      !Reset the year_calendar counter:
         IF ( t .NE. tdumpterminal ) iyearcd_A(1) = iyearcd_A(1) + yearno
            !iyearcd_A(1) is the 1st year in the climate.dat file.
            !yearno is integer year number = int(year) + 1.
            !If statement is required otherwise when using cont(inue) at
            !runtime increments iyearcd_A(1) when it should not.

      !Reset the year integrator:
            year_accum_rot0 = year_accum_rot
   
      !Reset the litter and soil initial values
         !First calculate inputs of C, N from felled and partially removed
            !trees into litter pools:
         !Foliage (le) and buds (bud)
            IleCSrot = nstems * MCSle; IleNSrot = nstems * MNSle 
                                       IleNphrot = nstems * MNph
                              !kg substrate C, N, photosythetic N m-2.
            IleCXrot = nstems * MCXle;  IleNXrot = nstems * MNXle
                                               !kg structural C,N m-2.
            IbudCrot = nstems * MCbud;  IbudNrot = nstems * MNbud
              !Assume that bud C and N are structural: kg structural C,N m-2.
         !Branches (br)
            IbrCSrot = ( one - fbr_rot_prod ) * nstems * MCSbr
            IbrNSrot = ( one - fbr_rot_prod ) * nstems * MNSbr 
                                                !kg substrate C,N m-2.
            IbrCXrot = ( one - fbr_rot_prod ) * nstems * MCXbrtot
            IbrNXrot = ( one - fbr_rot_prod ) * nstems * MNXbrtot 
                                               !kg structural C,N m-2 day-1.

         !Stems (st). A fraction fst_rot_prod of the stems are removed as
                     !products.
            IstCSrot = ( one - fst_rot_prod ) * nstems &
                                              * ( MCSst + MCstorest )
                                         !kg substrate C, storage C m-2.
            IstNSrot = ( one - fst_rot_prod ) * nstems * MNSst 
                                                !kg substrate N m-2.
            IstCXrot = ( one - fst_rot_prod ) * nstems * MCXsttot
            IstNXrot = ( one - fst_rot_prod ) * nstems * MNXsttot 
                                               !kg structural C,N m-2.
            Cpr_chk = nstems * ( fst_rot_prod &
                                   * ( MCSst + MCstorest + MCXsttot ) &
                               + fbr_rot_prod * ( MCSbr + MCXbrtot ) )

         !Coarse roots (co)
            IcoCSrot = nstems * MCSco; IcoNSrot = nstems * MNSco 
                                                !kg substrate C,N m-2.
            IcoCXrot = nstems * MCXcotot; IcoNXrot = nstems * MNXcotot 
                                               !kg structural C,N m-2.
         !Fine roots:
            IfiCSrot = nstems * MCSfi; IfiNSrot = nstems * MNSfi 
                                                !kg substrate C,N m-2.
            IfiCXrot = nstems * MCXfitot; IfiNXrot = nstems * MNXfitot 
                                               !kg structural C,N m-2.
         !Aphids.  These are the total C, N coming from the aphids on
            !clear felling at the end of the rotation:
               IaphCrot = Caph_m2; IaphNrot = Naph_m2    !kg C,N m-2.
            !These will be added as an input: ICXsurf_li_rot, 
   
         !The total SC, SN, phN, XC, XN inputs to surface litter are:
            ICSsurf_li_rot = IleCSrot + IbrCSrot + IstCSrot 
            ICXsurf_li_rot = IbudCrot + IleCXrot + IbrCXrot + IstCXrot &
                           + IaphCrot 
            INSsurf_li_rot = IleNSrot + IbrNSrot + IstNSrot + IleNphrot
            INXsurf_li_rot = IbudNrot + IleNXrot + IbrNXrot + IstNXrot &
                           + IaphNrot 
   
         !Total C, N inputs to surface litter are:
            ICsurf_li_rot = ICSsurf_li_rot + ICXsurf_li_rot 
            INsurf_li_rot = INSsurf_li_rot + INXsurf_li_rot 
   
         !Substrate C (CS), N  (NS) are put straight into the two met pools.

         !Structural C fluxes are divided between met, cel, lig.
            !fCshli_met = 0.2, !fCshli_mel = 0.65, !fCshli_lig = 0.15
            ICsurf_li_met_rot = ICSsurf_li_rot + fCshli_met * ICXsurf_li_rot 
            ICsurf_li_cel_rot = fCshli_cel * ICXsurf_li_rot 
            ICsurf_li_lig_rot = fCshli_lig * ICXsurf_li_rot 
         !As the cel and lig pools have fixed C/N ratios the N input to met is:
            INsurf_li_met_rot = INsurf_li_rot &
                            - ICsurf_li_cel_rot / rCNcel &
                            - ICsurf_li_lig_rot / rCNlig
               ! rCNcel = 150, rCNlig = 100 !kg C (kg N)-1.
         !The total SC, SN, XC, XN inputs to soil litter are:
            ICSsoil_li_rot = IcoCSrot + IfiCSrot 
            ICXsoil_li_rot = IcoCXrot + IfiCXrot 
            INSsoil_li_rot = IcoNSrot + IfiNSrot 
            INXsoil_li_rot = IcoNXrot + IfiNXrot 
   
         !Total C, N inputs to soil litter are:
            ICsoil_li_rot = ICSsoil_li_rot + ICXsoil_li_rot 
            INsoil_li_rot = INSsoil_li_rot + INXsoil_li_rot 
   
         !Substrate C, N are put straight into the two met pools.
         !Structural C fluxes are divided between met, cel, lig.
            ICsoil_li_met_rot = ICSsoil_li_rot + fCshli_met * ICXsoil_li_rot 
            ICsoil_li_cel_rot = fCshli_cel * ICXsoil_li_rot 
            ICsoil_li_lig_rot = fCshli_lig * ICXsoil_li_rot 
         !As the cel and lig pools have fixed C/N ratios the N input to met is:
            INsoil_li_met_rot = INsoil_li_rot &
                            - ICsoil_li_cel_rot / rCNcel &
                            - ICsoil_li_lig_rot / rCNlig
   
         !Now update the soil and litter submodel initial values:
            !Surface litter:
               Csurf_li_met0 = Csurf_li_met + ICsurf_li_met_rot &
                               - Ctree_t0 - Caph_m2_t0
               Nsurf_li_met0 = Nsurf_li_met + INsurf_li_met_rot &
                               - Ntree_t0 - Naph_m2_t0
               Csurf_li_cel0 = Csurf_li_cel + ICsurf_li_cel_rot
               Csurf_li_lig0 = Csurf_li_lig + ICsurf_li_lig_rot
                  !Here we have substracted off the initial values of C and
                  !N in the tree and the aphids, so that, each rotation, we
                  !do not add a small quantity of C and N in the seedlings.

            !Soil litter;
               Csoil_li_met0 = Csoil_li_met + ICsoil_li_met_rot
               Nsoil_li_met0 = Nsoil_li_met + INsoil_li_met_rot
               Csoil_li_cel0 = Csoil_li_cel + ICsoil_li_cel_rot
               Csoil_li_lig0 = Csoil_li_lig + ICsoil_li_lig_rot
   
         !Other soil submodel initial values:
               Char0 = Char !Assuming no fire at end of rotation.
               Csol0 = Csol
               Cbio0 = Cbio
               Namm0 = Namm
               Nnit0 = Nnit
               CuSOM0 = CuSOM
               CpSOM0 = CpSOM
               CsSOM0 = CsSOM
               NuSOM0 = NuSOM
               NpSOM0 = NpSOM
               NsSOM0 = NsSOM
   
     
         !Tree submodel initial values are not reset.
            !These are Mbud0, Aleaf0,
            !MCSle0, MNSle0, MXle10, MXle20, MXle30, MXle40
            !MCSbr0, MXbrm0, MNSbr0, MXbr0
            !MCSst0, MCstorest0, MXstm0, MNSst0, MXst0
            !nstems0
            !MCSco0, MXcom0, MNSco0, MXco0
            !MCSfi0, MXfim0, MNSfi0, MXfi0
            !hstem0, dstem0
      
         !Water submodel:
              !Wle, Wfi are not reset.
              !Wsoil0, soil water is also not reset.
                                !See comment above after "Csurf_li_met0 = ".
                                !At the end of the rotation, the water which
                                !was in the tree is simply lost from the
                                !system.  We assume it is lost to evaporation,
                                !as most of it presumably is.  If the tree
                                !water components are added to soil water, 
                                !then the soil goes above field capacity,
                                !and we can get an unrealistic leaching rate.
                                !I have checked the water balance over the
                                !rotation (Wsys at t = 0, Wsys at 60 years,
                                !integral of IWsys - OWsys over the rotation)
                                !and it is ok.

         !Products:
              !Cpt, Npt, Wpt  Non-decaying products of thinning. Not reset.
      
         !Products of thinning with decay.  These are reset:
             Cptd0 = Cptd;  Nptd0 = Nptd;  Wptd0 = Wptd
      
         !Products of rotation with decay.  These are reset:
             Cprd0 = Cprd + Cpr
             Nprd0 = Nprd + Npr
             Wprd0 = Wprd + Wpr
      
         !Climate change
            !of CO2:
                CO2vpmcz = CO2vpm
            !of temperature:
                Tairmaxmnz = Tairmaxmnz1 
                Tairminmnz = Tairminmnz1 
                Tsoilmnz = Tsoilmnz1 

   ENDIF  !End of rotation updating section.
      !IF ( s_rotate .EQ. one ) THEN !execute this section. Updating 
      !for the beginning of the next rotation.

!ilogd = 5
!CALL LOGD(.TRUE.) !5

END !TERMINAL
END !PROGRAM
!        1         2         3         4         5         6         7       
!234567891123456789212345678931234567894123456789512345678961234567897123456789
